{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Proxyshop is a Photoshop automation app that generates high-quality Magic the Gathering card renders.  Inspired by Chilli-Axe's original Photoshop automation scripts. If you need help with this app or wish to troubleshoot an issue, please join our discord!</p> <p> </p>"},{"location":"#requirements","title":"\ud83d\udee0\ufe0fRequirements","text":"<ul> <li>Photoshop (2017-2024 Supported)</li> <li>Windows (currently incompatible with Mac/Linux)</li> <li>The Photoshop templates (Can be downloaded in the app)</li> <li>Required fonts (included in <code>fonts/</code>):<ul> <li>Beleren Proxy Bold \u2014 For Card Name, Typeline, Power/Toughness</li> <li>Proxyglyph \u2014 For mana symbols, a fork of Chilli's NDPMTG font</li> <li>Plantin MT Pro \u2014 For rules text, install all variants included</li> <li>Beleren Smallcaps \u2014 For Artist credit line and miscellaneous</li> <li>Gotham Medium \u2014 For collector text</li> </ul> </li> <li>Optional (but recommended) fonts:<ul> <li>Magic The Gathering \u2014 Required by Classic template</li> <li>Matrix Bold \u2014 Required by Colorshifted template</li> <li>Keyrune \u2014 Required for \"Font\" expansion symbol mode</li> <li>Mana \u2014 For various additional card symbols</li> </ul> </li> </ul>"},{"location":"#setup-guide","title":"\ud83d\ude80 Setup Guide","text":"<ol> <li>Download the latest release, extract it to a folder of your choice.</li> <li>Install the fonts included in the <code>fonts/</code> folder, please note that <code>Keyrune</code> and <code>Proxyglyph</code> may need to be updated in future releases.</li> <li>Place card arts for cards you wish to render in the <code>art/</code> folder. These arts should be named according to the card (see Art File Naming for more info).</li> <li>Launch <code>Proxyshop.exe</code>. Click the Update button. Proxyshop will load templates available to download, grab what you want.</li> <li>Hit Render All to render every card art in the <code>art/</code> folder. Hit Render Target to render one or more specific card arts.</li> <li>You can also drag art images or folders containing art images onto the Proxyshop app, Proxyshop will automatically start rendering those cards.</li> <li>During the render process the console at the bottom will display the current progress and prompt you if any failures occur.</li> </ol>"},{"location":"#art-file-naming","title":"\u2712\ufe0f Art File Naming","text":"<ul> <li>Art file types currently supported are: <code>jpg</code>, <code>jpeg</code>, <code>jpf</code>, <code>png</code>, <code>tif</code>, and <code>webp</code>. NOTE: <code>webp</code> requires Photoshop 2022+.</li> <li>Art files should be named after real Magic the Gathering cards and should be named as accurately as possible, e.g. <code>Damnation.jpg</code>.</li> <li>Proxyshop supports several optional tags when naming your art files, to give you more control over how the card is rendered!<ul> <li>Set <code>[SET]</code> \u2014 Forces Photoshop to render a version of that card from a specific MTG expansion matching the given set code. This tag is not case sensitive, so both \"set\" and \"SET\" will work. <pre><code>Damnation [TSR].jpg\n</code></pre></li> <li>Collector Number <code>{num}</code> \u2014 Only works if Set tag was also provided, render a version of that card with the exact set code and number combination. This is particularly useful in cases where a set has multiple versions of the same card, for example Secret Lair (SLD) has 3 different versions of Brainstorm. <pre><code>Brainstorm [SLD] {175}.jpg\n</code></pre></li> <li>Artist Name <code>(Artist Name)</code> \u2014 When filling in the artist name, Proxyshop will override the name present in the Scryfall data with the name you provide. This change is purely cosmetic and does not affect how the card is fetched, nor does it conflict with other tags. <pre><code>Brainstorm [SLD] {175} (Rusty Shackleford).jpg\n</code></pre></li> <li>Creator Name <code>$Creator Name</code> \u2014 This tag is not widely supported by Proxyshop's default templates. This tag allows you to insert your preferred name as a user/designer/creator, and if the template supports the creator name feature this text will be placed on a specified text layer. Can be used as a kind of signature for your work. NOTE: This tag MUST be placed at the VERY END of the art file name. <pre><code>Brainstorm [SLD] {175}$My Creator Name.jpg\n</code></pre></li> </ul> </li> </ul>"},{"location":"#using-the-proxyshop-gui","title":"\ud83d\udcbb Using the Proxyshop GUI","text":""},{"location":"#render-cards-tab","title":"Render Cards Tab","text":"<ul> <li>The main tab for rendering authentic Magic the Gathering cards.</li> <li>Render All: Renders a card image using each art image found in the <code>art/</code> folder.</li> <li>Render Target: Opens file select in Photoshop, renders a card image using each art image you select.</li> <li>Global Settings: Opens a settings panel used to change app-wide options for:<ul> <li>Main settings: Affects template behavior, can be modified for individual templates. When you click the \u2699\ufe0f icon next to a template, a config file is generated for that template which overrides these settings.</li> <li>System settings: Affects the entire application and cannot be changed for individual templates.</li> </ul> </li> <li>The set of tabs below these buttons represent template types, e.g. Normal, MDFC, Transform, etc.<ul> <li>Template types represent different kinds of templates which require different frame elements or different rendering techniques.</li> <li>If the Normal tab is active, and you click on a template button, that template becomes selected for the Normal template type. Cards which match the Normal type will now render using that template. </li> <li>That template DOES NOT become selected for other types. For example, if Borderless is selected in the Normal tab, but Normal is selected in the MDFC tab. Cards that match the MDFC type will render using Normal MDFC.</li> </ul> </li> <li>Next to each template in the template list there are two icons:<ul> <li>\u2699\ufe0f Lets you change the Main Settings for this template, some templates will also have their own specially designed settings you can change as well.</li> <li>\ud83e\uddf9 Deletes the separate config file generated for this template, effectively returning this template back to default settings. Ensures Main Settings for this template are governed by the Global Settings panel.</li> </ul> </li> <li>The dark grey area below the templates selector is the Console, this is where status messages will be displayed tracking render progress and other user actions.</li> <li>To the right of the Console are some useful buttons:<ul> <li>\ud83d\udccc Pins the Proxyshop window, so it remains above all other running programs</li> <li>\ud83d\udcf7 Takes a screenshot of the Proxyshop window, saves to: <code>out/screenshots/</code></li> <li>\ud83c\udf0d Opens your default web browser, navigating to Proxyshop's GitHub page</li> <li>\u2754 Opens your default web browser, navigating to our community Discord server</li> <li>Continue: Becomes active when app is waiting for a user response, either when manual editing is enabled or an error has occurred.</li> <li>Cancel: Becomes active when cards are being rendered, can cancel the render operation at any time or if an error occurs.</li> <li>Update: Opens the Updater panel which allows you to download new templates and update existing ones.</li> </ul> </li> </ul>"},{"location":"#custom-creator-tab","title":"Custom Creator Tab","text":"<ul> <li>This tab controls the custom card creator.</li> <li>This feature is currently considered experimental beta and may have issues.</li> <li>You can currently render Normal, Planeswalker, or Saga cards, just fill in the appropriate data and hit Render Custom.</li> <li>More features and card types will be added in the near future.</li> </ul>"},{"location":"#tools-tab","title":"Tools Tab","text":"<ul> <li>This tab contains a growing list of helpful tools and utilities.</li> <li>Render All Showcases: Generates a bordered showcase image for each card image in the <code>out/</code> folder, showcases will be placed in <code>out/showcase/</code>.</li> <li>Render Target Showcase: Opens a file select in Photoshop, generates a bordered showcase image for each card image you select.</li> <li>Compress Renders: This tool reduces the size of card images stored in the <code>out/</code> folder. The settings are:<ul> <li>Quality: JPEG save quality of the compressed image, supports a number between 1 and 100. (Recommended: 95-99)</li> <li>Optimize: Enables Pillow's automatic \"optimize\" flag. Lowers filesize by a small margin for no discernible downside. (Recommended: On)</li> <li>800 DPI: Downscales card images above 800 DPI to a maximum of 800 DPI. Most Proxyshop templates are 1200 DPI which is much higher than anyone really needs. Most printing services do not print above 800 DPI. (Recommended: On)</li> </ul> </li> </ul>"},{"location":"#setup-guide-python-environment","title":"\ud83d\udc0d Setup Guide (Python Environment)","text":"<ol> <li>Install Poetry using one of these methods.     <pre><code># Install pipx, then install poetry with pipx (Recommended)\npython -m pip install --user pipx\npython -m pipx ensurepath\npipx install poetry\n\n# Install using Powershell\n(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -\n\n# Install using WSL (Windows Subsystem for Linux)\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Install using scoop\nscoop install poetry\n</code></pre></li> <li>Clone Proxyshop somewhere on your system, we'll call this repository the root directory.     <pre><code>git clone https://github.com/MrTeferi/Proxyshop.git\n</code></pre></li> <li>Navigate to the root directory and install the Proxyshop project with poetry.     <pre><code># Move to the Proxyshop repository we just cloned\ncd Proxyshop\n\n# OPTIONAL: Configure poetry to setup the environment locally\npoetry config virtualenvs.in-project true\n\n# Install the Proxyshop project\npoetry install\n</code></pre></li> <li>Install the fonts included in the <code>fonts/</code> folder. Do not delete these, even after you install them (some are used by the GUI).</li> <li>Optional: Currently, the Python version of Proxyshop cannot download templates using the Update button, because our API keys are not made public. If you wish to download the Proxyshop templates, follow this guide to download them manually.</li> <li>Create a folder called <code>art</code> in the root directory. This is where you place art images for cards you wish to render.</li> <li>Run the app.     <pre><code># OPTION 1) Execute via poetry\npoetry run main.py\n\n# OPTION 2) Enter the poetry environment, then execute normally\npoetry shell\npy main.py\n</code></pre></li> <li>Refer to the usage guide for navigating the GUI.</li> </ol>"},{"location":"#download-templates-manually","title":"\ud83d\udcbe Download Templates Manually","text":"<p>If you wish to download the templates manually, visit this link: - Right-click the Zipped folder and hit Download. - This will download all Proxyshop templates, Google Drive may split this download into multiple zip files. - Once the zips are downloaded, move them into the <code>templates/</code> folder. Select them all, Right-click -&gt; 7-Zip -&gt; Extract here. - Once extracted, you will have a lot of <code>.7z</code> archive files, this is because we compress PSD templates to reduce their hosting footprint. - Once again, select the <code>.7z</code> archives, and extract using the same process. - You will also notice two folders: <code>MrTeferi/</code> and <code>SilvanMTG/</code> - Copy the contents of these folders to: <code>plugins/MrTeferi/templates/</code> and <code>plugins/SilvanMTG/templates/</code> - Once again, extract those <code>.7z</code> archives using the same process as before. All done!</p>"},{"location":"#how-can-i-support-proxyshop","title":"\ud83d\udc8c How can I support Proxyshop?","text":"<p>Feel free to join our discord and participate in the <code>#Proxyshop</code> channel where we are constantly brainstorming and testing new features, dropping beta releases, and sharing new plugins and templates. Also, please consider supporting our Patreon which pays for S3 + Cloudfront hosting of Proxyshop templates and allows us the freedom to work on the app, as well as other applications like MPC Autofill, MTG Art Downloader, and more!</p>"},{"location":"#faq","title":"\u2753 FAQ","text":"How do I change the set symbol to something else?     How do I completely hide the set symbol?  <p>In Global Settings, or settings for a specific template, change \"Symbol Render Mode\" to None. This disables the expansion symbol altogether.</p>    How do I hide a layer in a Proxyshop template, so it doesn't appear in rendered cards?  <p>In the Photoshop template of your choice, change the opacity to 0 on the layer you wish to hide. You can use this method to hide anything. This is safer than just disabling the layer's visibility because layers may be forcibly enabled and disabled by the app, it's also safer than deleting the layer because that may cause errors on some templates.</p>    Where is a good place to find high quality MTG art?  <p>Your best resource is going to be MTG Pics, to improve art quality even more you can look into upscaling with Topaz/Chainner/ESRGAN. On our discord we provide a lot of resources for learning how to upscale art easily and effectively. For mass downloading art, view my other project: MTG Art Downloader</p>    The app stops when trying to enter text and Photoshop becomes unresponsive!  <p>There is a known bug where Photoshop crashes when trying to enter too much text into a text box, it should be fixed but could theoretically happen on some plugin templates that don't make the text box big enough. The best way to fix this is to open the template in Photoshop and expand the bottom edge of the Rules text boxes (creature and noncreature).</p>    Required value is missing / RPC server not responding.  <p>This can sometimes be one of the more rare but obnoxious errors that occur on some systems. Sometimes the root cause is unknown, but it can usually be fixed. Try these options in order until something works:</p> <ul> <li>Ensure there is only ONE installation of Photoshop on your computer. Having two versions of Photoshop installed at the same time can prevent making a connection to the app. If you have more than one installed, uninstall all versions of Photoshop and reinstall one version. You must uninstall all of them first, just removing one likely won't fix the issue.</li> <li>Ensure that your Photoshop application was installed using an actual installer. Portable installations of Photoshop do not work with Proxyshop, since Windows needs to know where it is located.</li> <li>Close Photoshop and Proxyshop, then run both Photoshop and Proxyshop as Administrator, try rendering something.</li> <li>Close both of them, then hold ALT + CTRL + SHIFT while launching Photoshop, then launch Proxyshop, try again.</li> <li>Restart your computer, then start both and try again.</li> <li>If you have a particularly over-defensive antivirus software running that may be interfering with Proxyshop  connecting to Photoshop, such as Avast, Norton, etc. close your antivirus software, relaunch both, and try again. You might also try disabling Windows Defender.</li> <li>If there's a chance your Photoshop installation could be damaged, corrupted, or otherwise messed up in some way, it is recommended to completely uninstall Photoshop and install the latest version you have access to.  Generally, Proxyshop works best with newer versions of Photoshop. If using an in-authentic version of Photoshop, verify it is of high quality and uses a real installer.</li> <li>If all of these fail to fix the issue, please join our Discord (linked at the top) and provide the error log from <code>logs/error.txt</code> in your Proxyshop directory, so we can help find the cause :)</li> </ul>    Photoshop is busy!  <p>This error occurs when Photoshop is not responding to commands because it is busy. To prevent this error, you must ensure Photoshop is in a neutral state when you run Proxyshop or render a card:</p> <ul> <li>There should be no dialog boxes or settings menus open in Photoshop. The normal tool panels are fine.</li> <li>There should be no tools performing tasks, for example having text highlighted for editing with the text tool.</li> <li>Ideally Photoshop should be launched fresh, with no documents open.</li> </ul>    I'm getting some other error!  <p>In your proxyshop directory, look for a folder named <code>logs</code>, inside that folder you should see <code>error.txt</code>, check the last error log in that file. If the error isn't obvious, join our Discord and feel free to ask for help in the #Proxyshop channel.</p>"},{"location":"#font-mode","title":"Font Mode","text":"<ul> <li>Under \"Symbol Render Mode\", ensure \"Font\" Mode is enabled in Global Settings, or in the Settings for the template you wish to customize.</li> <li>Head over to https://keyrune.andrewgioia.com/cheatsheet.html, choose a symbol.</li> <li>Copy the set code of the symbol you want, it'll be the 2-4 letters after \"ss-\" in the code next to the symbol, for example SOI (Shadows Over Innistrad).</li> <li>In the same settings panel, enter this code for the \"Default Symbol\" setting.</li> <li>In the same settings panel, enable \"Force Default Symbol\", doing so will ensure this symbol is used for all cards rendered globally/using this template.</li> <li>[Optional] To customize the look of this symbol, you'll need to:     1) Add an entry to <code>src/data/custom_symbols.json</code>.     2) Look at how symbols are defined in <code>src/data/expansion_symbols.json</code> for examples.</li> </ul>"},{"location":"#svg-mode","title":"SVG Mode","text":"<ul> <li>Ensure SVG mode is enabled under \"Symbol Render Mode\".</li> <li>Change \"Default Symbol\" to a 2-4 letter code of your choice, and enable \"Force Default Symbol\".</li> <li>Head over to <code>src/img/symbols/</code> and create a folder named according to that code, or you can use one of the symbols that already exists.</li> <li>If making a custom symbol, add the SVG files to the folder you created, name each file according to the first letter of its rarity (capitalized).</li> <li>That symbol will now be used, you're good to go!</li> </ul>"},{"location":"#credits","title":"\u2728 Credits","text":"<ul> <li>Our amazing Patreon supporters who literally keep this project going.</li> <li>Chilli Axe for his outstanding MTG Photoshop Automation project that Proxyshop was inspired by, and for producing many of the base PSD templates that have been modified to work with Proxyshop.</li> <li>Additional template and asset support from:<ul> <li>SilvanMTG</li> <li>Nelynes</li> <li>Trix are for Scoot</li> <li>FeuerAmeise</li> <li>michayggdrasil</li> <li>Warpdandy</li> <li>MaleMPC</li> <li>Vittorio Masia</li> <li>iDerp</li> <li>Tupinamb\u00e1 (Pedro Neves)</li> </ul> </li> <li>Andrew Gioia for the Keyrune project that enables high quality expansion symbols.</li> <li>John Prime, Haven King, and members of CCGHQ for providing expansion symbol SVG's.</li> <li>Hal and the other contributors over at Photoshop Python API.</li> <li>Wizards of the Coast and all the talented artists who make Magic the Gathering a reality.</li> <li>Countless others who have provided help and other assets to the community that made various features possible.</li> <li>All contributors to the code base.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v1120-2023-10-01","title":"v1.12.0 (2023-10-01)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>fonts: Add checking user font folder as a fallback for startup font checking step</li> <li>tools: New tools: Render Target Showcase, Compress Rendered Images</li> <li>gui: Add support for multi-modal preview images and front/back face toggle preview images on click</li> <li>symbols: Added support for CC2, LTC, LTR, PWOE, WHO, WOC, and WOE svg symbols</li> <li>templates: New template: Modern Classic, a modern-framed vector-based template with a mix of classic textures</li> <li>CLI: Initial architecture introduced for a headless (CLI) Proxyshop interface for quick testing, batch generation, and commands</li> <li>templates: New template type: Battles supporting a Normal and Universes Beyond treatment, as well as a new BattleMod modifier class</li> <li>settings: New setting: Collector Promo Star, decide whether to enable the promo star in collector info when appropriate</li> <li>BorderlessVectorTemplate: Add setting: Legendary Crown Texture, allows user to toggle the texture on crowns</li> </ul>"},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>SplitTemplate: Disable artifact and vehicle flag for Split cards</li> <li>enums/settings: Swap cached_property to classproperty</li> <li>check_app_version: Control against all request exceptions</li> <li>saga: Support edge case \"Greatest Show in the Multiverse\", i.e. saga with static ability</li> <li>expansion_symbol: When expansion symbol fails to render, revert to disabling expansion symbol and warn the user</li> <li>check_app_version: Skip this check if Github isn't reached in 3 seconds</li> <li>frame_logic: Support \"Demolition Field\" non-colored land case</li> <li>templates/normal: Repair pinlines color map and add crown shading for EtchedTemplate, fix name alignment step for Borderless tokens, fix edge case PT drop shadow logic, add preliminary code for ClassicModernTemplate</li> <li>helpers/document: Fix rotate_clockwise orientation to positive 90 degrees</li> <li>fonts: Prevent a crash caused by encountering unrecognized font type in font checking step</li> <li>fonts: Relocate psd-tools font test outside main app scope</li> <li>planar: Fix bug affecting planar cards when Scryfall Extras is disabled</li> </ul>"},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>ClassicModernTemplate: Add MDFC support</li> <li>VectorTemplate: Add default support for MDFC twins shape</li> <li>test_mode: Change output directory of test renders to match their class name</li> <li>app_templates: Add drive ID for Classic Modern template</li> <li>src/core: Move card type map to constants, updater funcs to downloads, plan to deprecate the <code>core</code> module in near future</li> <li>parse_card_info: Move art file parsing logic to scryfall utils</li> <li>updater: Move template update funcs to downloader utils</li> <li>ClassicModernTemplate: Finish Transform implementation on Classic Modern template</li> <li>mkdir: Ensure mkdir across project uses 711 perms</li> <li>main: Add console object as property to main App class</li> <li>tools: Flesh out image compression tool, add process wrapper for tools calls</li> <li>env: Add PS_ERROR_DIALOG env for toggling display error dialog on action descriptor execute calls</li> <li>creator: Import updated creator inputs</li> <li>gui/TemplateModule: Minimize and center template tabs</li> <li>gui: Add dynamic tabbed element subclasses, rewrite validated input classes, fix Planeswalker custom rendering</li> <li>merge_layers: Support returning layer if merge_layers receives list with one item</li> <li>build: Update build script to use new kv directory</li> <li>data: Move kv and spec files to data directory</li> <li>types: Move all types submodules to new 'types' module, add new types TemplateRaw and TemplateManifest</li> <li>BaseTemplate: Improve Vehicle check handling</li> <li>constants: Ensure con.cwd is always the root Proxyshop directory, re-implement the PS_VERSION env variable</li> <li>console.py: Added extensive new infrastructure for handling \"logger\" formatting and output in the headless console class</li> <li>tests/text_logic.py: Readability rewrites and improve logging results</li> <li>enums/settings.py: Add enum for \"Legendary Crown Mode\" setting on Modern Classic template</li> <li>BaseTemplate: Allow 'is_vehicle' to act as a flag for toggling vehicle background behavior</li> <li>BaseTemplate: Add promo star logic to collector info methods, add is_collector_promo bool property, refactor initial photoshop refresh check using new method 'check_photoshop'`</li> <li>VectorTemplate: Remove unneeded alternate card type text layers now handled in modifiers, add crown_group check for legendary crown step, add more typechecking</li> <li>enums: Add new enums tracking recognized card fonts and special icons</li> <li>layers: Add new layer nomenclature for Battle templates</li> <li>main,core: Update photoshop refresh step in render_process_wrapper, add preliminary template data for Classic Modern and Battle templates</li> <li>layouts: Add preliminary BattleLayout class, add is_promo bool property</li> <li>PhotoshopHandler: Refactor Photoshop application refresh mechanism</li> </ul>"},{"location":"changelog/#perf","title":"Perf","text":"<ul> <li>helpers/document: Reduce PNG save size by disabling interlaced, reduce JPEG save size by formatting as optimized baseline</li> <li>templates/saga: Reduce execution time for Saga layer positioning</li> </ul>"},{"location":"changelog/#v1110-2023-08-14","title":"v1.11.0 (2023-08-14)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>paste_scryfall_scan: When scryfall scan is enabled in settings we will now use bleed edge to correctly position the art instead of a reference box</li> <li>ClassicTemplate: Add support for Extended Art setting, fix broken Promo Star setting</li> <li>fonts: Additional step during startup font check that detects outdated fonts</li> <li>Borderless: New settings: Artifact color mode, enable/disable drop shadow text, dark/light toggle for land color, dark/light toggle for front face DFC cards, color treatment toggle for Hybrid cards, color limit mode ranging from 1 to 5, and piecemeal toggle for various multicolor elements</li> <li>leveler: Leveler template now supports automatic ability text sizing and positioning</li> <li>BaseTemplate: Add properties: frame_layer_methods, text_layer_methods, and general_methods. These act as lists where you can inject methods that should be run at various stages of the render sequence</li> <li>gui: Add step to the launch diagnostic that checks if a new version is released</li> <li>settings: Added support for colorpicker settings in plugin Templates</li> <li>Class: Brand new and improved Class template, uses the same PSD as the updated Saga template, also supports Universes Beyond treatment</li> <li>Saga: Brand new and improved Saga template using vector layers, supports both side Transform and a Universes Beyond treatment as well</li> <li>templates: Introduced \"Mod\" templates, reusable template classes that act as modifiers to add piecemeal functionality such as Transform layers, or MDFC layers</li> </ul>"},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>BorderlessVectorTemplate: Fix a bug affecting token cards in custom creator and textless renders</li> <li>BasicLandDarkMode: Artist info now filled properly</li> <li>adventure: Update adventure layout data for alternate language, split AdventureTemplate and AdventureMod</li> <li>planeswalker: Fix alternate language processing logic</li> <li>scryfall: Prevent infinite retry loop</li> <li>basic_land: Additional fixes for alternate languages</li> <li>scryfall: Fix a bug affecting some Planar cards (they count as \"extras\"), fix a bug that returns the wrong face for meld cards</li> <li>text_layers: Prevent a bug that can ruin flavor divider positioning, fix a bug that occurs when both flavor and oracle text are missing</li> <li>basic_land: Fix alternate language bug with Basic Land templates</li> <li>plugins/MrTeferi: Prevent sketch action from running in test mode, fix Crimson fang issues, shift Transform behavior to using modifier class</li> <li>SilvanExtendedTemplate: Fix legendary crowns causing a crash for Colorless cards</li> <li>split: Fix typo that caused split template to break</li> <li>svg: Fixed SVG expansion symbols: M15, AFR</li> <li>ClassicRemasteredTemplate: Rewrote duplicate setting description</li> </ul>"},{"location":"changelog/#refactor_1","title":"Refactor","text":"<ul> <li>normal: Utilize modifiers across some normal template classes, implement new mask and shape enabling steps, update and fix various templates</li> <li>PrototypeMod: Implement prototype modifier class</li> <li>planar: Update scryfall scan step in accordance with new scan importing behavior</li> <li>MutateMod: Implement a mutate modifier class</li> <li>LevelerMod: Implement a leveler modifier class</li> <li>saga-cards: Retool old saga card template class into a modifier which passes the saga card functionality onto the new vector template</li> <li>class-cards: Retool old class card template class into a modifier which passes the class card functionality onto the new vector template</li> <li>VectorTemplate: Implement additional shape and mask enabling steps, optional tooling to improve on the Vector template workflow</li> <li>templates: Continue to improve the template modifier system, moving away from a _mods module and instead placing them in their relevant modules based on template type</li> <li>regex: Implement new regex pattern for matching nested version number strings</li> <li>helpers/masks: New helper utility: copy_vector_mask, works like copy_layer_mask but acts only on vector masks</li> <li>enums: Add new LAYERS nomenclature and remove useless Photoshop enum line</li> <li>utils/objects: Add classproperty decorator, update PhotoshopHandler to fix descriptor conversion bug, deprecate scale_by_height/width in favor of scale_by_dpi</li> <li>split: Improved readability of Split template code</li> <li>token: Improved Token template formatting by aligning typeline and rules text after text formatting</li> <li>double_faced: Rework existing MDFC and Transform templates to use new template Mod infrastructure</li> <li>layouts: Moves remaining Planeswalker data logic out of templates and into layouts, fixes several alternate language issues and missing data issues</li> <li>helpers/adjustments: Updates create_color_layer and create_gradient_layer to accept keyword arguments to modify their behavior, such as rotation and scale</li> <li>helpers/layers: New helper utility: merge_group, merges a target LayerSet into a single ArtLayer</li> <li>helpers/masks: New helper utility: apply_mask, applies a given layer's mask</li> <li>helpers/text: New helper utilities: get_font_size, set_text_size, set_text_leading, set_composer_single_line</li> <li>helpers/position: New helper utility: position_dividers, Positions a list of dividers between a list of text layers</li> <li>get_rgb_from_hex: New function to create SolidColor RGB object from a hex value using hexValue API</li> <li>constants: Remove relocated color maps</li> <li>plugins/SilvanMTG: Update SilvanMTG template classes using new infrastructure</li> <li>enums: Added a host of default color maps for various MTG frame elements</li> <li>settings: StrEnum used to track settings options now supports a \"Default\" enum natively, updated get_option and get_setting methods, added preliminary settings for BorderlessVector</li> <li>layers: Introduced new layer name nomenclature, added new LayerObject type</li> <li>console: Created first draft of headless Console object that responds to the user in terminal/commandline</li> <li>VectorTemplate: Introduced new template module _vector.py for tracking core vector template architecture</li> <li>env: Modify environment variable system to use one clean .env file to govern localized behaviors</li> <li>PhotoshopHandler: Enable error dialogs when executing Action Descriptors in development environment</li> <li>exceptions: Start building out a comprehensive library of known COMErrors</li> <li>masks: Add new helper function: delete_mask</li> <li>transform_icon: Default transform icon will now be considered the triangle formerly called \"convertdfc\"</li> <li>console: Use Logger for printing exceptions during development, improve formatting of error.txt log file</li> <li>env: Remove unused kivy logging ENV, remove KIVY_NO_CONSOLELOG toggle for development mode</li> <li>layers: Add new terminology for Saga layers</li> <li>logging: Kivy logging now only prints for error messages</li> <li>target_replace: Deprecated Targeted Text Replace setting as it is no longer needed</li> </ul>"},{"location":"changelog/#perf_1","title":"Perf","text":"<ul> <li>text_layers: Disable seemingly unnecessary steps during text formatting, needs further bulk testing to verify</li> <li>helpers/position: Continue to improve performance of layer aligning and positioning</li> <li>planeswalker: Reworked Planeswalker code for better performance and readability, updated method hierarchy to delineate planeswalker-specific steps from ordinary steps</li> <li>format_text: Improve execution time of text scaling and positioning functions, deprecate format_flavor_text</li> <li>expansion_symbol: Improve coverage of SVG symbols by checking for a replacement set code in the symbol library</li> </ul>"},{"location":"changelog/#v1101-2023-07-09","title":"v1.10.1 (2023-07-09)","text":""},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>console: Fix render operation cancelled unexpectedly without console output on bad scryfall data</li> <li>test: Fix test rendering not using the correct fullart image, fixed image testing for Split template</li> <li>test: Fix thread not cancelling in Deep Test Target mode</li> </ul>"},{"location":"changelog/#v1100-2023-07-06","title":"v1.10.0 (2023-07-06)","text":""},{"location":"changelog/#feat_2","title":"Feat","text":"<ul> <li>New-template-type:-Split-Cards: Split cards now supported, default Split template included</li> <li>helpers: New helper functions for rotate_document</li> <li>gui: Add pinned to top button and link buttons to discord and github</li> </ul>"},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>ClassicTemplate: Fix incorrect backgrounds on ClassicTemplate, fix some crashes on Photoshop not connected</li> <li>regex: Fix italicized ability bug with \"Council's Dilemma\"</li> <li>prototype: Fix prototype layer select bug</li> <li>console: Fix multiple cancellation prompts issue</li> <li>BasicLandLayout: Ensure Artist provided by Scryfall data can be used</li> <li>layouts: Allow basic lands to pull Collector Info, move text logic for prototype and mutate into layout object, implement layout checking in Scryfall utils</li> <li>collector_info: Fix bug on some systems which re-enables hidden paintbrush</li> <li>prototype: Fix prototype layout linkage now that Scryfall has added layout type \"prototype\"</li> <li>main: Prevent stacking error prompts in console when missing document is closed</li> <li>check_playable_card: Block broken \"reversible_card\" layout from Scryfall results</li> <li>TokenTemplate: Add missing preview image for TokenTemplate</li> <li>card_types: Add missing \"Token\" card type to template card_types dictionary, rename Basic Land -&gt; Basic</li> <li>format_text: Add guard clause for using LayerSet object as reference in ensure_visible_reference</li> <li>symbols: Fix broken BNG common SVG, use better looking WTH symbols</li> </ul>"},{"location":"changelog/#refactor_2","title":"Refactor","text":"<ul> <li>scryfall: Completely revamped logic for assigning card layout based on Scryfall data, added new settings for Scryfall data collection</li> <li>enums: Add non_italics_abilities and update TransformIcons</li> <li>dimensions: Add dimensions enum</li> <li>dimensions: Add additional dimensions information to get_dimensions_from_bounds</li> <li>watermark: Add support for \"desparked\" and \"judgeacademy\"</li> <li>download: Move update -&gt; utils/download, add 7z compression support</li> <li>basic_land: Enable content aware fill on BasicLandUnstableTemplate</li> <li>token: Enable fullart toggle on Token template</li> <li>compression: Add compression functions/tests, add italicized ability test</li> <li>config: Remove config.ini from repository and from built releases as it is auto-generated for the user</li> <li>BorderlessVector: Make \"Automatic\" the default for \"Textbox Size\" setting</li> <li>templates: Enable Borderless Vector for Basic Land type</li> <li>enums: Add basic lands and transform icons to MTG enums</li> <li>BorderlessVectorTemplate: Add support for MDFC, Textless, and Nickname features to BorderlessVectorTemplate</li> <li>DynamicVectorTemplate: Added default functionality for MDFC card type in DynamicVectorTemplate class, added guard clause for reset function</li> <li>layer_names: Add more terminology to the layer names Enum class</li> <li>font: New helper function: set_font</li> <li>align: Add two more align utility definitions: align_left, align_right</li> <li>layers: Add helper function: unpack_smart_layer</li> <li>expansion_symbol: Add support for special/bonus rarities, move to YAML symbol library</li> <li>expansion_symbols: Final commit before deprecating json version</li> </ul>"},{"location":"changelog/#perf_2","title":"Perf","text":"<ul> <li>alignment: Vastly improved execution time of layer alignments and positioning, huge improvements to Planeswalker generation</li> <li>text: Improve execution time of formatting text and positioning flavor divider</li> </ul>"},{"location":"changelog/#v190-2023-06-13","title":"v1.9.0 (2023-06-13)","text":""},{"location":"changelog/#feat_3","title":"Feat","text":"<ul> <li>templates: New Template: Borderless Vector, our most advanced template yet</li> <li>settings: Added Generative Fill setting that replaces content aware fill when supported, and Vertical Fullart which forces Fullart templates to always use vertical framing</li> <li>GUI: Added new \"Tools\" tab, for various app utilities</li> <li>templates: New templates: ClassicRemastered (credit to iDerp), Etched (credit to Warpdandy, Kyle of CC, and myself), Lord of the Rings (credit to Tupinamb\ufffd). Updated Normal Fullart, Stargazing, and Universes Beyond. Renamed WomensDay -&gt; Borderless, NormalClassic -&gt; Classic, NormalExtended -&gt; Extended, NormalFullart -&gt; Fullart</li> <li>templates: Separated templates.py into full templates module, delineated by template types. Added new utility template classes: NormalEssentials, NormalVectorTemplate, and DynamicVectorTemplate</li> <li>setting: Added new setting: Collector Mode, changes how collector info is rendered. Also added get_option for processing valid multi-choice options</li> <li>templates: New templates: Etched and Classic Remastered</li> </ul>"},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>divider: Improved positioning of flavor divider when layer effects are present</li> <li>constants: Update Photoshop refreshing mechanism to avoid more error conditions, added new module for tracking MTG related constants like rarities</li> <li>SilvanExtendedTemplate: Fix crash caused by inserting hollow crown</li> <li>scryfall: Fix exclusion check to ensure playable memorabilia like 30A isn't excluded</li> <li>helpers: Fix SolidColor being instantiated as a default parameter, added copy_layer_effects helper function</li> <li>frame_logic: Added case for gold land cards like Thran Portal</li> <li>expansion_symbol: Improve both A25 and MOM expansion symbols</li> <li>main: Refactored the render pipeline to fix some common Photoshop issues and implemented a launch diagnostic system that detects if the required fonts are installed and Photoshop can be reached by the app</li> <li>layouts: Fix missing set code on basic lands</li> <li>expansion_symbol: Fix SVG symbol filename mismatch for VOW</li> </ul>"},{"location":"changelog/#refactor_3","title":"Refactor","text":"<ul> <li>main: Add Tools tab to build procedure, moved expansion symbol library update to on_start call</li> <li>env: Added kivy_logging and photoshop_version as private ENV's, pending functionality</li> <li>create_color_layer: Updated to recieve a SolidColor object</li> <li>colors: Added new colors helper functions: hex_to_rgb, fill_layer_primary</li> <li>exceptions: Improved code readability</li> <li>expansion_symbols.json: Transitioned to dictionary notation for all stroke definitions, in preparation for eventually moving to YAML</li> <li>generative_fill: Added two new design helper funtions: generative_fill, generative_fill_edges</li> <li>document: Added new document helper function: pixels_to_points</li> <li>layers: Add new layers helper functions: edit_smart_layer, select_vector_layer_pixels</li> <li>expansion_symbol: Improved readability of code and added robust default value generation</li> <li>masks: Add new masks helper function: apply_mask_to_layer_fx</li> <li>align: Use select_layer_bounds for alignment selection</li> <li>text: Add new text helper function: get_line_count</li> <li>format_text: Refactored text scaling to use DPI scaling methods of PhotoshopHandler, updated the SymbolMapper to use a dictionary instead of disperate attributes of the constants object, allowing creators to assign a custom color map easier</li> <li>helpers: Separate helpers.py into entire module divided by Photoshop scope</li> <li>configs: Add config json for ClassicRemasteredTemplate, updated config json for BasicLandClassic, Invention, and NormalClassic templates</li> <li>SilvanMTG: Updated plugin to utilize the new content aware fill naming conventions</li> <li>MaleMPCTemplate: Deprecated the MaleMPC template, pending addition to the base app as \"Extended Dark\", a small modification to the Extended template</li> <li>main: Remove download step for app template manifest, disabled Kivy debugger log</li> <li>constants: Added dictionaries for layer maks and pinline colors, removed some deprecated variables</li> <li>layouts: Updated logic for 'card_count', 'collector_number', and 'collector_data'. Added 'identity', 'is_artifact', and 'is_hybrid'</li> <li>frame_logic: Updated frame_logic to return 'is_hybrd' value, added contains_frame_colors function for testing frame layer names given</li> <li>previews: Update preview image naming for updated template naming conventions</li> <li>app_templates: app_manifest.json -&gt; app_templates.json</li> <li>enums: Created new directory for delineating enums, created new enums for settings values</li> <li>strings: Remove deprecated ps_version_check, add method for StrEnum to check if the class \"contains\" a string</li> <li>types: Add is_hybrid to FrameDetails type</li> <li>types: Add LayerContainer type for objects that can contain artLayer or layerSet objects</li> <li>PhotoshopHandler: Add scale_by_height and scale_by_width to get a dimension scaled based on DPI ratio</li> <li>photoshop: Move Photoshop version checks to app object</li> <li>format_text: Improve scale_text_right_overlap, scale_text_left_overlap, and scale_text_to_fit_textbox functions</li> <li>photoshop: Update Photoshop enums to only make typeID conversion when an Enum is accessed, added DescriptorEnum parent class</li> <li>fonts: Added font utility functions for determining what necessary fonts are installed at launch</li> <li>photoshop: Update Photoshop application object to better control over Photoshop communication</li> <li>scryfall: Moved scryfall exception decorator to new exceptions util, added get_photoshop_error_message to exceptions util for choosing correct Photoshop error</li> <li>strings: Added string utility for appending bulletpoints to each line in a string</li> </ul>"},{"location":"changelog/#v180-2023-04-27","title":"v1.8.0 (2023-04-27)","text":""},{"location":"changelog/#feat_4","title":"Feat","text":"<ul> <li>templates: New template type: Token. Now ships with one included token template (credit to Chilli Axe). Emblems are also rolled into this template type. Also implemented better Expansion Symbol positioning and scaling, reworked the rendering chain, implemented better error handling and thread procedures, and merged most transform and MDFC template classes into single classes that can handle both faces</li> <li>threading: Implemented sophisticated thread tracking, locking, and release. Threads will now shut down properly when the Cancel button is pressed. The Console class was completely rewritten to faciliate management of the current render thread. \"Render Target\" can now select more than one card art to render</li> <li>settings: Added new settings. Scryfall Sorting: Change order of Scryfall results. Watermark Default Opacity: Change the defeault opacity of generated Watermarks. Renamed Dev mode to Test mode. Implemented get_default_symbol utility function</li> </ul>"},{"location":"changelog/#fix_5","title":"Fix","text":"<ul> <li>text_layers: Implemented new properties governing scaling behavior such as scale_height, scale_width, fix_overflow_width, fix_overflow_height. Added a step that ensures text does not overflow the bounding box of the text area when needed</li> <li>fonts: Updated the NDPMTG font to fix Phyrexian hybrid and implement acorn symbol</li> </ul>"},{"location":"changelog/#refactor_4","title":"Refactor","text":"<ul> <li>templates: Move duplicate filename logic to file utils</li> <li>frame_logic: Completely rewrote the frame logic step for efficiency, introduced efficient mapping and utility function to find the correctly ordered color identity sequence. Creators can now use this sequence to implement 3+ color frame elements with accuracy</li> <li>expansion_symbols.json: Updated symbol library, removed reference keys as they are now deprecated</li> <li>constants: Updated constants object to use new env variables, added new utility methods, added new lock objects, added global PhotoshopHandler object</li> <li>plugins: Updated included plugins to use new LAYERS library and updated console handler</li> <li>tests,-build,-deps: Added pathvalidate dependency, updated tests, implemented env module for tracking environment variables and flags</li> <li>img: Renamed some preview images and SVG symbol directories</li> <li>update: Refactored download functions for better readability</li> <li>enums_layers: Moved our layer names library to a StrEnum class, con.layers refrences this</li> <li>modules: Implemented module utilities for retrieving and refreshing plugin modules</li> <li>objects: Implemented a PhotoshopHandler class to maintain one global Photoshop Application instance and refresh across new threads</li> <li>scryfall: Updated scryfall set utilities to support token cards</li> <li>utils.strings: Moved headless console to string utilities, updated console output utility functions</li> <li>utils: Added import comments, implemented new types and updated existing types</li> </ul>"},{"location":"changelog/#perf_3","title":"Perf","text":"<ul> <li>format_text: Improved execution time on multiple format_text functions, refactored SymbolMapper, implemented new function scale_text_to_fit_textbox</li> <li>helpers: Improved efficiency of some helper functions. Introduced new helpers: check_textbox_overflow, get_textbox_bounds, get_textbox_dimensions, enable/disable_vector_mask, undo/redo_action, convert_points_to_pixels, check_active_document, get_document</li> <li>regex: Implemented a regex pattern dataclass to pre-compile all regex patterns used by the app</li> </ul>"},{"location":"changelog/#v170-2023-04-06","title":"v1.7.0 (2023-04-06)","text":""},{"location":"changelog/#feat_5","title":"Feat","text":"<ul> <li>settings: Importing scryfall art for reference is now a toggle setting, has been removed from individual templates in favor of a base template function that can be modified by child classes</li> <li>gui: Settings for each template can now be cleared to defaults with a helpful button, templates will now be disabled unless the PSD file is installed, the updater will enable the template after a download is complete</li> <li>scryfall: Rewrote Scryfall data collection completely to use efficient rate limiting and error handling as well as improved caching and overall execution time of this step</li> <li>settings: Seperate core system settings from the base template settings which can be overwritten for each template</li> </ul>"},{"location":"changelog/#fix_6","title":"Fix","text":"<ul> <li>classic: Fixed promo star setting on classic templates</li> <li>creature: Fix mistake in creature vertically nudge text function</li> <li>dev_mode: Skip uninstalled templates during dev mode testing</li> <li>planeswalker: Update Planeswalker logic to enforce uniform spacing for 2 ability Planeswalkers</li> <li>layouts: Fixed a bug affecting Saga and Class cards that have multiline abilities</li> <li>frame_logic: Fixed frame logic for ca1rds like Maelstrome Muse and Ajani, Sleeper Agent and added both to our test cases</li> <li>creator: Custom Creator now works for Planeswalker and Saga cards again</li> <li>updater: Fix templates downloading to incorrect folder</li> </ul>"},{"location":"changelog/#refactor_5","title":"Refactor","text":"<ul> <li>planeswalker: Adjust vertically nudge text function</li> <li>helpers: Updated getLayer(), getLayerSet(), spread_layers_over_reference(), and art importing functionality</li> <li>format_text: Added new text function check_for_text_overlap() and refactored the vertical nudge functions for Creature and Planeswalker cards</li> <li>data: Update project toml, fonts,  and expansion symbol data</li> </ul>"},{"location":"changelog/#v160-2023-03-16","title":"v1.6.0 (2023-03-16)","text":""},{"location":"changelog/#feat_6","title":"Feat","text":"<ul> <li>settings: New Setting: Template Border, default is black. Other options are white, silver and gold</li> <li>template: New Template: Universes Beyond, used in crossover sets like WH40K, Transformers, etc</li> <li>expansion_symbol: Rewrite expansion symbol settings to allow 4 distinct modes, including SVG</li> <li>watermarks: Add support for optional Watermark generation</li> <li>fonts: New font utility functions: register_font(), unregister_font(), get_all_fonts(), check_fonts()</li> <li>helpers: New helper functions: set_fx_visibility(), enable_layer_fx(), disable_layer_fx(), set_fill_opacity(), apply_fx_color_overlay()</li> <li>files: Restructure directory structure, allow self contained plugins</li> </ul>"},{"location":"changelog/#fix_7","title":"Fix","text":"<ul> <li>settings: Back face to MDFC/Transform now uses the same ini as front face</li> <li>console: Add missing newline</li> <li>symbols: Updated some expansion symbols</li> <li>kivy: Replace unused MPlantin font with PlantinMTPRo</li> <li>scryfall: Improved MTG Set data caching to fix inconsistencies with collector information</li> <li>sketch: Fix bug causing some pencil sketch filters to fail</li> <li>constants: Fix cwd not working properly in executable version</li> </ul>"},{"location":"changelog/#refactor_6","title":"Refactor","text":"<ul> <li>tests: Update tests for directory restructure and expansion symbol rewrite</li> <li>layouts: Improve handling of card_count, pre-cache set data, reorganize properties pertaining to all double faced cards</li> <li>SilvanMTG: Remove default configurations for cfg.remove_reminder</li> <li>types_photoshop: Specify NotRequired for some values</li> </ul>"},{"location":"changelog/#v150-2023-03-02","title":"v1.5.0 (2023-03-02)","text":""},{"location":"changelog/#feat_7","title":"Feat","text":"<ul> <li>expansion-symbol: New layer effects helpers implemented, Expansion Symbol now rendered using these effects</li> <li>helpers: Import art directly into the document, add new helper utilities</li> <li>templates: New template type: Class</li> </ul>"},{"location":"changelog/#fix_8","title":"Fix","text":"<ul> <li>ixalan: Ixalan now renders without an error at create_expansion_symbol()</li> <li>layouts: Transform front sides now work when name is lowercase</li> <li>layouts: Added support for meld transform icon, added support for non-Ixalan back face lands</li> <li>symbols: Add support for ONE, ONC, DMR, and SCD</li> <li>console: Improve error logging dramatically</li> <li>fonts: Updated keyrune font to latest</li> <li>layouts: Patch a bug that causes alternate language to not identify creatures</li> </ul>"},{"location":"changelog/#refactor_7","title":"Refactor","text":"<ul> <li>helpers: Deprecated solidcolor(), Added new helpers</li> <li>layouts: BaseLayout &gt; NormalLayout, made BasicLandLayout extend to NormalLayout</li> <li>cwd: Use con.cwd to find the current directory across Proxyshop, always use root directory of project</li> <li>DoubleFeature: Explicit definitions for layer groups</li> <li>creator: Added scryfall formatting step to custom creator which in the future will help keep data in-line with what is expected for the layout object</li> <li>symbols: Allow use of old Expansion Symbol rendering, pending potential future deprecation</li> <li>frame_logic: Improved formatting and refactored</li> <li>format_text: Code readability improvements</li> </ul>"},{"location":"changelog/#v140-2023-01-30","title":"v1.4.0 (2023-01-30)","text":""},{"location":"changelog/#feat_8","title":"Feat","text":"<ul> <li>saga: Implemented full automation for sagas</li> <li>symbols: Update symbol library and template manifest on launch</li> <li>gui: Add preview image to showcase each template</li> <li>settings: New automatic settings panels</li> </ul>"},{"location":"changelog/#fix_9","title":"Fix","text":"<ul> <li>CrimsonFangTemplate: Fixed dual color frame generation</li> <li>settings: Additional fixes for new panel config system</li> <li>frame_logic: Fix frame logic for some transform cards</li> <li>settings: Small patches to settings logic</li> <li>creator: Fix template logic for creator tab</li> <li>scryfall: Add special exception for championship cards</li> <li>expansion_symbol: Default stroke now uses config value</li> <li>meld: Fix meld card layout data</li> </ul>"},{"location":"changelog/#refactor_8","title":"Refactor","text":"<ul> <li>planeswalker: Refactored planeswalker text generation</li> <li>templates: Add scaling to Planeswalker spacing</li> <li>configs: Rename configs to match new nomenclature</li> <li>settings: Rewrite settings to use class name for ini/json naming convention</li> <li>layouts: Trimmed down layout classes and properties</li> <li>frame_logic: Add FrameDetails type</li> <li>sketch: Switch sketch config to new settings system</li> <li>plugin-templates: Make adjustments to included plugin templates</li> <li>templates: Remove useless print statements</li> <li>symbols: Add missing symbols to library</li> <li>config: Reformat config for Kivy settings panel</li> <li>text_layers.py: Refactored classic quote alignment</li> <li>gui: Seperate GUI elements into modules</li> </ul>"},{"location":"changelog/#v130-2023-01-06","title":"v1.3.0 (2023-01-06)","text":""},{"location":"changelog/#fix_10","title":"Fix","text":"<ul> <li>updater: Fixed Google Drive downloads, moved S3 downloading to Cloudfront</li> </ul>"},{"location":"changelog/#refactor_9","title":"Refactor","text":"<ul> <li>env: Moved environment variables to py file</li> <li>gui.py: Removed unnecessary newline</li> <li>templates.py: Added app reference to BaseTemplate as property</li> <li>main.py: Added proper version tracking, refactored console output</li> <li>constants: Update HTTP header used for requests</li> </ul>"},{"location":"license/","title":"License","text":""},{"location":"license/#mozilla-public-license-version-20","title":"Mozilla Public License Version 2.0","text":""},{"location":"license/#1-definitions","title":"1. Definitions","text":"<p>1.1. \u201cContributor\u201d     means each individual or legal entity that creates, contributes to     the creation of, or owns Covered Software.</p> <p>1.2. \u201cContributor Version\u201d     means the combination of the Contributions of others (if any) used     by a Contributor and that particular Contributor's Contribution.</p> <p>1.3. \u201cContribution\u201d     means Covered Software of a particular Contributor.</p> <p>1.4. \u201cCovered Software\u201d     means Source Code Form to which the initial Contributor has attached     the notice in Exhibit A, the Executable Form of such Source Code     Form, and Modifications of such Source Code Form, in each case     including portions thereof.</p> <p>1.5. \u201cIncompatible With Secondary Licenses\u201d     means</p> <ul> <li>(a) that the initial Contributor has attached the notice described     in Exhibit B to the Covered Software; or</li> <li>(b) that the Covered Software was made available under the terms of     version 1.1 or earlier of the License, but not also under the     terms of a Secondary License.</li> </ul> <p>1.6. \u201cExecutable Form\u201d     means any form of the work other than Source Code Form.</p> <p>1.7. \u201cLarger Work\u201d     means a work that combines Covered Software with other material, in      a separate file or files, that is not Covered Software.</p> <p>1.8. \u201cLicense\u201d     means this document.</p> <p>1.9. \u201cLicensable\u201d     means having the right to grant, to the maximum extent possible,     whether at the time of the initial grant or subsequently, any and     all of the rights conveyed by this License.</p> <p>1.10. \u201cModifications\u201d     means any of the following:</p> <ul> <li>(a) any file in Source Code Form that results from an addition to,     deletion from, or modification of the contents of Covered     Software; or</li> <li>(b) any new file in Source Code Form that contains any Covered     Software.</li> </ul> <p>1.11. \u201cPatent Claims\u201d of a Contributor     means any patent claim(s), including without limitation, method,     process, and apparatus claims, in any patent Licensable by such     Contributor that would be infringed, but for the grant of the     License, by the making, using, selling, offering for sale, having     made, import, or transfer of either its Contributions or its     Contributor Version.</p> <p>1.12. \u201cSecondary License\u201d     means either the GNU General Public License, Version 2.0, the GNU     Lesser General Public License, Version 2.1, the GNU Affero General     Public License, Version 3.0, or any later versions of those     licenses.</p> <p>1.13. \u201cSource Code Form\u201d     means the form of the work preferred for making modifications.</p> <p>1.14. \u201cYou\u201d (or \u201cYour\u201d)     means an individual or a legal entity exercising rights under this     License. For legal entities, \u201cYou\u201d includes any entity that     controls, is controlled by, or is under common control with You. For     purposes of this definition, \u201ccontrol\u201d means (a) the power, direct     or indirect, to cause the direction or management of such entity,     whether by contract or otherwise, or (b) ownership of more than     fifty percent (50%) of the outstanding shares or beneficial     ownership of such entity.</p>"},{"location":"license/#2-license-grants-and-conditions","title":"2. License Grants and Conditions","text":""},{"location":"license/#21-grants","title":"2.1. Grants","text":"<p>Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license:</p> <ul> <li>(a) under intellectual property rights (other than patent or trademark)     Licensable by such Contributor to use, reproduce, make available,     modify, display, perform, distribute, and otherwise exploit its     Contributions, either on an unmodified basis, with Modifications, or     as part of a Larger Work; and</li> <li>(b) under Patent Claims of such Contributor to make, use, sell, offer     for sale, have made, import, and otherwise transfer either its     Contributions or its Contributor Version.</li> </ul>"},{"location":"license/#22-effective-date","title":"2.2. Effective Date","text":"<p>The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution.</p>"},{"location":"license/#23-limitations-on-grant-scope","title":"2.3. Limitations on Grant Scope","text":"<p>The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor:</p> <ul> <li>(a) for any code that a Contributor has removed from Covered Software;     or</li> <li>(b) for infringements caused by: (i) Your and any other third party's     modifications of Covered Software, or (ii) the combination of its     Contributions with other software (except as part of its Contributor     Version); or</li> <li>\u00a9 under Patent Claims infringed by Covered Software in the absence of     its Contributions.</li> </ul> <p>This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4).</p>"},{"location":"license/#24-subsequent-licenses","title":"2.4. Subsequent Licenses","text":"<p>No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3).</p>"},{"location":"license/#25-representation","title":"2.5. Representation","text":"<p>Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License.</p>"},{"location":"license/#26-fair-use","title":"2.6. Fair Use","text":"<p>This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents.</p>"},{"location":"license/#27-conditions","title":"2.7. Conditions","text":"<p>Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1.</p>"},{"location":"license/#3-responsibilities","title":"3. Responsibilities","text":""},{"location":"license/#31-distribution-of-source-form","title":"3.1. Distribution of Source Form","text":"<p>All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form.</p>"},{"location":"license/#32-distribution-of-executable-form","title":"3.2. Distribution of Executable Form","text":"<p>If You distribute Covered Software in Executable Form then:</p> <ul> <li> <p>(a) such Covered Software must also be made available in Source Code     Form, as described in Section 3.1, and You must inform recipients of     the Executable Form how they can obtain a copy of such Source Code     Form by reasonable means in a timely manner, at a charge no more     than the cost of distribution to the recipient; and</p> </li> <li> <p>(b) You may distribute such Executable Form under the terms of this     License, or sublicense it under different terms, provided that the     license for the Executable Form does not attempt to limit or alter     the recipients' rights in the Source Code Form under this License.</p> </li> </ul>"},{"location":"license/#33-distribution-of-a-larger-work","title":"3.3. Distribution of a Larger Work","text":"<p>You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s).</p>"},{"location":"license/#34-notices","title":"3.4. Notices","text":"<p>You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies.</p>"},{"location":"license/#35-application-of-additional-terms","title":"3.5. Application of Additional Terms","text":"<p>You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction.</p>"},{"location":"license/#4-inability-to-comply-due-to-statute-or-regulation","title":"4. Inability to Comply Due to Statute or Regulation","text":"<p>If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it.</p>"},{"location":"license/#5-termination","title":"5. Termination","text":"<p>5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice.</p> <p>5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate.</p> <p>5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination.</p>"},{"location":"license/#6-disclaimer-of-warranty","title":"6. Disclaimer of Warranty","text":"<p>Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer.</p>"},{"location":"license/#7-limitation-of-liability","title":"7. Limitation of Liability","text":"<p>Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You.</p>"},{"location":"license/#8-litigation","title":"8. Litigation","text":"<p>Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims.</p>"},{"location":"license/#9-miscellaneous","title":"9. Miscellaneous","text":"<p>This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor.</p>"},{"location":"license/#10-versions-of-the-license","title":"10. Versions of the License","text":""},{"location":"license/#101-new-versions","title":"10.1. New Versions","text":"<p>Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number.</p>"},{"location":"license/#102-effect-of-new-versions","title":"10.2. Effect of New Versions","text":"<p>You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward.</p>"},{"location":"license/#103-modified-versions","title":"10.3. Modified Versions","text":"<p>If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License).</p>"},{"location":"license/#104-distributing-source-code-form-that-is-incompatible-with-secondary-licenses","title":"10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses","text":"<p>If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached.</p>"},{"location":"license/#exhibit-a-source-code-form-license-notice","title":"Exhibit A - Source Code Form License Notice","text":"<pre><code>This Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n</code></pre> <p>If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice.</p> <p>You may add additional accurate notices of copyright ownership.</p>"},{"location":"license/#exhibit-b-incompatible-with-secondary-licenses-notice","title":"Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice","text":"<pre><code>This Source Code Form is \"Incompatible With Secondary Licenses\", as\ndefined by the Mozilla Public License, v. 2.0.\n</code></pre>"},{"location":"text_layers/","title":"Text Layer Classes","text":"<p>TEXT LAYER MODULE</p>"},{"location":"text_layers/#src.text_layers.NO_DIALOG","title":"<code>NO_DIALOG = DialogModes.DisplayNoDialogs</code>  <code>module-attribute</code>","text":"<p>Text Layer Classes</p>"},{"location":"text_layers/#src.text_layers.CreatureFormattedTextArea","title":"<code>CreatureFormattedTextArea</code>","text":"<p>             Bases: <code>FormattedTextArea</code></p> <p>FormattedTextArea which also respects the bounds of creature card's power/toughness boxes. If the rasterized and centered text layer overlaps with another specified reference layer (which should represent the bounds of the power/toughness box), the layer will be shifted vertically to ensure that it doesn't overlap.</p> Source code in <code>src/text_layers.py</code> <pre><code>class CreatureFormattedTextArea (FormattedTextArea):\n    \"\"\"\n    FormattedTextArea which also respects the bounds of creature card's power/toughness boxes.\n    If the rasterized and centered text layer overlaps with another specified reference layer\n    (which should represent the bounds of the power/toughness box), the layer will be shifted\n    vertically to ensure that it doesn't overlap.\n    \"\"\"\n\n    \"\"\"\n    PROPERTIES\n    \"\"\"\n\n    @cached_property\n    def pt_reference(self) -&gt; Optional[ArtLayer]:\n        return self.kwargs.get('pt_reference', None)\n\n    @cached_property\n    def pt_top_reference(self) -&gt; Optional[ArtLayer]:\n        return self.kwargs.get('pt_top_reference', None)\n\n    \"\"\"\n    METHODS\n    \"\"\"\n\n    def execute(self):\n        super().execute()\n\n        # Shift vertically if the text overlaps the PT box\n        if self.pt_reference and self.pt_top_reference:\n            delta = ft.vertically_nudge_creature_text(self.layer, self.pt_reference, self.pt_top_reference)\n            # Shift the divider as well\n            if delta &lt; 0 and self.divider:\n                self.divider.translate(0, delta)\n</code></pre>"},{"location":"text_layers/#src.text_layers.FormattedTextArea","title":"<code>FormattedTextArea</code>","text":"<p>             Bases: <code>FormattedTextField</code></p> <p>A FormattedTextField where the text is required to fit within a given area. An instance of this class will step down the font size until the text fits within the reference layer's bounds, then rasterize the text layer, and center it vertically with respect to the reference layer's selection area.</p> Source code in <code>src/text_layers.py</code> <pre><code>class FormattedTextArea (FormattedTextField):\n    \"\"\"\n    A FormattedTextField where the text is required to fit within a given area.\n    An instance of this class will step down the font size until the text fits\n    within the reference layer's bounds, then rasterize the text layer, and\n    center it vertically with respect to the reference layer's selection area.\n    \"\"\"\n\n    \"\"\"\n    PROPERTIES\n    \"\"\"\n\n    @cached_property\n    def divider(self) -&gt; Optional[Union[ArtLayer, LayerSet]]:\n        if (divider := self.kwargs.get('divider')) and all([self.flavor_text, self.contents, cfg.flavor_divider]):\n            divider.visible = True\n            return divider\n        return\n\n    @cached_property\n    def scale_height(self) -&gt; bool:\n        # Scale text to fit reference height (Default: True)\n        if scale_height := self.kwargs.get('scale_height'):\n            return scale_height\n        return True\n\n    @cached_property\n    def scale_width(self) -&gt; bool:\n        # Scale text to fit reference width (Default: False)\n        if scale_width := self.kwargs.get('scale_width'):\n            return scale_width\n        return False\n\n    @cached_property\n    def fix_overflow_width(self) -&gt; bool:\n        # Scale text to fit bounding box width (Default: False)\n        if fix_overflow_width := self.kwargs.get('fix_overflow_width'):\n            return fix_overflow_width\n        return True\n\n    @cached_property\n    def fix_overflow_height(self) -&gt; bool:\n        # Scale text to fit bounding box height (Default: If overflow the bounds)\n        if len(self.contents + self.flavor_text) &gt; 280:\n            return True\n        if fix_overflow_height := self.kwargs.get('fix_overflow_height'):\n            return fix_overflow_height\n        return False\n\n    \"\"\"\n    METHODS\n    \"\"\"\n\n    def insert_divider(self):\n        \"\"\"\n        Inserts and correctly positions flavor text divider.\n        \"\"\"\n        # Create a reference layer with no effects\n        flavor = self.layer.duplicate()\n        rules = flavor.duplicate()\n        flavor.rasterize(RasterizeType.EntireLayer)\n        remove_trailing_text(rules, len(self.rules_text_updated) + 1)\n        # TODO: Test if this line is necessary\n        # rules.rasterize(RasterizeType.EntireLayer)\n        select_layer_bounds(rules)\n        self.docref.activeLayer = flavor\n        self.docref.selection.expand(2)\n        self.docref.selection.clear()\n\n        # Move flavor text to bottom, then position divider\n        flavor.translate(0, get_text_layer_bounds(self.layer)[3] - flavor.bounds[3])\n        position_between_layers(self.divider, rules, flavor)\n        self.docref.selection.deselect()\n        flavor.remove()\n        rules.remove()\n\n    def execute(self):\n\n        # Skip if both are empty\n        if not self.contents and not self.flavor_text:\n            self.layer.visible = False\n            return\n\n        # Fix height overflow before formatting text\n        if self.fix_overflow_height and self.reference:\n            contents = self.contents if not self.flavor_text else str(self.contents + \"\\r\" + self.flavor_text)\n            self.layer.textItem.contents = contents\n            ft.scale_text_to_fit_reference(\n                self.layer, int(get_layer_dimensions(self.reference)['height']*1.01)\n            )\n\n        # Execute text formatting\n        super().execute()\n\n        # Resize the text until it fits the reference vertically\n        if self.scale_height:\n            ft.scale_text_to_fit_reference(self.layer, self.reference)\n\n        # Resize the text until it fits the reference horizontally\n        if self.scale_width:\n            ft.scale_text_to_fit_reference(self.layer, self.reference, height=False, step=0.2)\n\n        # Resize the text until it fits the TextLayer bounding box\n        if self.fix_overflow_width:\n            ft.scale_text_to_fit_textbox(self.layer)\n\n        # Ensure the layer is centered vertically\n        ft.vertically_align_text(self.layer, self.reference)\n\n        # Ensure the layer is centered horizontally if needed\n        if self.contents_centered and self.flavor_centered:\n            align_horizontal(self.layer, self.reference)\n\n        # Insert flavor divider if needed\n        if self.divider:\n            self.insert_divider()\n</code></pre>"},{"location":"text_layers/#src.text_layers.FormattedTextArea.insert_divider","title":"<code>insert_divider()</code>","text":"<p>Inserts and correctly positions flavor text divider.</p> Source code in <code>src/text_layers.py</code> <pre><code>def insert_divider(self):\n    \"\"\"\n    Inserts and correctly positions flavor text divider.\n    \"\"\"\n    # Create a reference layer with no effects\n    flavor = self.layer.duplicate()\n    rules = flavor.duplicate()\n    flavor.rasterize(RasterizeType.EntireLayer)\n    remove_trailing_text(rules, len(self.rules_text_updated) + 1)\n    # TODO: Test if this line is necessary\n    # rules.rasterize(RasterizeType.EntireLayer)\n    select_layer_bounds(rules)\n    self.docref.activeLayer = flavor\n    self.docref.selection.expand(2)\n    self.docref.selection.clear()\n\n    # Move flavor text to bottom, then position divider\n    flavor.translate(0, get_text_layer_bounds(self.layer)[3] - flavor.bounds[3])\n    position_between_layers(self.divider, rules, flavor)\n    self.docref.selection.deselect()\n    flavor.remove()\n    rules.remove()\n</code></pre>"},{"location":"text_layers/#src.text_layers.FormattedTextField","title":"<code>FormattedTextField</code>","text":"<p>             Bases: <code>TextField</code></p> <p>A utility class for packing in the required infrastructure to format text with action descriptors.</p> Source code in <code>src/text_layers.py</code> <pre><code>class FormattedTextField (TextField):\n    \"\"\"\n    A utility class for packing in the required infrastructure to format text with action descriptors.\n    \"\"\"\n\n    \"\"\"\n    PROPERTIES\n    \"\"\"\n\n    @cached_property\n    def text_details(self) -&gt; dict:\n\n        # Generate italic text arrays from things in (parentheses), ability words, and the given flavor text\n        italic_text = ft.generate_italics(self.contents) if self.contents else []\n\n        # Add flavor text to italics array\n        flavor_text = self.flavor_text\n        if self.flavor_text.count(\"*\") &gt;= 2:\n            # Don't italicize text between asterisk\n            flavor_text_split = self.flavor_text.split(\"*\")\n            italic_text.extend([v for i, v in enumerate(flavor_text_split) if not i % 2 and not v == ''])\n            flavor_text = ''.join(flavor_text_split)\n        elif self.flavor_text:\n            # Regular flavor text\n            italic_text.append(self.flavor_text)\n\n        # Locate symbols and update the input string\n        ret = ft.locate_symbols(self.contents)\n        input_string = f\"{ret['input_string']}\\r{flavor_text}\" if self.contents else flavor_text\n\n        # Locate italics text indices\n        italics_indices = ft.locate_italics(input_string, italic_text)\n\n        return {\n            'input_string': input_string,\n            'symbol_indices': ret['symbol_indices'],\n            'italics_indices': italics_indices,\n            'rules_text': ret['input_string'],\n            'flavor_text': flavor_text,\n        }\n\n    @property\n    def italics_indices(self) -&gt; list[dict]:\n        return self.text_details['italics_indices']\n\n    @property\n    def symbol_indices(self) -&gt; list[dict]:\n        return self.text_details['symbol_indices']\n\n    @property\n    def input(self) -&gt; str:\n        return self.text_details['input_string']\n\n    @property\n    def flavor_text_updated(self) -&gt; str:\n        return self.text_details['flavor_text']\n\n    @property\n    def rules_text_updated(self) -&gt; str:\n        return self.text_details['rules_text']\n\n    @cached_property\n    def flavor_text(self) -&gt; str:\n        return self.kwargs.get('flavor', '').replace('\\n', '\\r')\n\n    @property\n    def divider(self) -&gt; Optional[ArtLayer]:\n        # Default to None unless overridden\n        return\n\n    @cached_property\n    def contents_centered(self) -&gt; bool:\n        return self.kwargs.get('centered', False)\n\n    @cached_property\n    def flavor_centered(self) -&gt; bool:\n        return self.kwargs.get('flavor_centered', self.contents_centered)\n\n    @cached_property\n    def line_break_lead(self) -&gt; Union[int, float]:\n        return self.kwargs.get(\n            'line_break_lead',\n            0 if self.contents_centered else con.line_break_lead\n        )\n\n    @cached_property\n    def flavor_text_lead(self) -&gt; Union[int, float]:\n        # Lead with divider\n        if self.divider:\n            return self.kwargs.get('flavor_text_lead_divider', con.flavor_text_lead_divider)\n        # Lead without divider\n        return self.kwargs.get('flavor_text_lead', con.flavor_text_lead)\n\n    @cached_property\n    def flavor_index(self) -&gt; int:\n        return len(self.contents) if len(self.flavor_text) &gt; 0 else -1\n\n    @cached_property\n    def quote_index(self) -&gt; int:\n        return self.input.find(\"\\r\", self.flavor_index + 3) if self.flavor_index &gt;= 0 else -1\n\n    @cached_property\n    def bold_rules_text(self) -&gt; bool:\n        return self.kwargs.get('bold_rules_text', False)\n\n    @cached_property\n    def right_align_quote(self) -&gt; bool:\n        return self.kwargs.get('right_align_quote', False)\n\n    @cached_property\n    def flavor_color(self) -&gt; Optional[SolidColor]:\n        return self.kwargs.get('flavor_color', None)\n\n    @cached_property\n    def font_size(self) -&gt; float:\n        if font_size := self.kwargs.get('font_size'):\n            return font_size * get_text_scale_factor(self.layer)\n        return self.layer.textItem.size * get_text_scale_factor(self.layer)\n\n    \"\"\"\n    METHODS\n    \"\"\"\n\n    def format_text(self):\n        \"\"\"\n        Inserts the given string into the active layer and formats it according to defined parameters with symbols\n        from the NDPMTG font.\n        \"\"\"\n        # Set up main descriptors and lists\n        main_descriptor = ActionDescriptor()\n        style_list = ActionList()\n        main_list = ActionList()\n\n        # Descriptor ID's\n        idTo = sID(\"to\")\n        size = sID(\"size\")\n        idFrom = sID(\"from\")\n        leading = sID(\"leading\")\n        fontName = sID(\"fontName\")\n        textStyle = sID(\"textStyle\")\n        pointsUnit = sID(\"pointsUnit\")\n        spaceAfter = sID(\"spaceAfter\")\n        autoLeading = sID(\"autoLeading\")\n        startIndent = sID(\"startIndent\")\n        spaceBefore = sID(\"spaceBefore\")\n        leadingType = sID(\"leadingType\")\n        styleRange = sID(\"textStyleRange\")\n        paragraphStyle = sID(\"paragraphStyle\")\n        firstLineIndent = sID(\"firstLineIndent\")\n        fontPostScriptName = sID(\"fontPostScriptName\")\n        paragraphStyleRange = sID(\"paragraphStyleRange\")\n\n        # Spin up the text insertion action\n        main_style = ActionDescriptor()\n        main_range = ActionDescriptor()\n        main_descriptor.putString(sID(\"textKey\"), self.input)\n        main_range.putInteger(idFrom, 0)\n        main_range.putInteger(idTo, len(self.input))\n        main_style.putString(fontPostScriptName, con.font_rules_text)  # MPlantin default\n        main_style.putString(fontName, con.font_rules_text)  # MPlantin default\n        main_style.putUnitDouble(size, pointsUnit, self.font_size)\n        apply_color(main_style, self.color)\n        main_style.putBoolean(autoLeading, False)\n        main_style.putUnitDouble(leading, pointsUnit, self.font_size)\n        main_range.putObject(textStyle, textStyle, main_style)\n        main_list.putObject(styleRange, main_range)\n\n        # Bold the contents if necessary\n        if self.bold_rules_text and self.flavor_index != 0:\n            bold_range = ActionDescriptor()\n            bold_style = ActionDescriptor()\n            contents_index = len(self.input) - 1 if self.flavor_index &lt; 0 else self.flavor_index - 1\n            bold_range.putInteger(idFrom, 0)  # bold start index\n            bold_range.putInteger(idTo, contents_index)  # bold end index\n            bold_style.putString(fontPostScriptName, con.font_rules_text_bold)\n            bold_style.putString(fontName, con.font_rules_text_bold)\n            bold_style.putUnitDouble(size, pointsUnit, self.font_size)\n            apply_color(bold_style, self.color)\n            bold_style.putBoolean(autoLeading, False)\n            bold_style.putUnitDouble(leading, pointsUnit, self.font_size)\n            bold_range.putObject(textStyle, textStyle, bold_style)\n            main_list.putObject(styleRange, bold_range)\n\n        # Italicize text from our italics indices\n        for i in self.italics_indices:\n            italic_range = ActionDescriptor()\n            italic_style = ActionDescriptor()\n            italic_range.putInteger(idFrom, i['start_index'])  # italics start index\n            italic_range.putInteger(idTo, i['end_index'])  # italics end index\n            italic_style.putString(fontPostScriptName, con.font_rules_text_italic)\n            italic_style.putString(fontName, con.font_rules_text_italic)\n            italic_style.putUnitDouble(size, pointsUnit, self.font_size)\n            apply_color(italic_style, self.color)\n            italic_style.putBoolean(autoLeading, False)\n            italic_style.putUnitDouble(leading, pointsUnit, self.font_size)\n            italic_range.putObject(textStyle, textStyle, italic_style)\n            main_list.putObject(styleRange, italic_range)\n\n        # Format each symbol correctly\n        for symbol_index in self.symbol_indices:\n            ft.format_symbol(\n                action_list=main_list,\n                symbol_index=symbol_index['index'],\n                symbol_colors=symbol_index['colors'],\n                font_size=self.font_size,\n            )\n\n        # Insert actions for bold, italics, and symbol formatting\n        main_descriptor.putList(styleRange, main_list)\n\n        # Paragraph formatting\n        desc141 = ActionDescriptor()\n        desc142 = ActionDescriptor()\n        desc141.putInteger(idFrom, 0)\n        desc141.putInteger(idTo, len(self.input))  # input string length\n        desc142.putUnitDouble(firstLineIndent, pointsUnit, 0)\n        desc142.putUnitDouble(startIndent, pointsUnit, 0)\n        desc142.putUnitDouble(sID(\"endIndent\"), pointsUnit, 0)\n        desc142.putUnitDouble(spaceBefore, pointsUnit, self.line_break_lead)\n        desc142.putUnitDouble(spaceAfter, pointsUnit, 0)\n        desc142.putInteger(sID(\"dropCapMultiplier\"), 1)\n        desc142.putEnumerated(leadingType, leadingType, sID(\"leadingBelow\"))\n\n        # Adjust formatting for modal card with bullet points\n        if \"\\u2022\" in self.input:\n            desc143 = ActionDescriptor()\n            startIndexBullet = self.input.find(\"\\u2022\")\n            endIndexBullet = self.input.rindex(\"\\u2022\")\n            desc141.putInteger(idFrom, startIndexBullet)\n            desc141.putInteger(idTo, endIndexBullet + 1)\n            desc142.putUnitDouble(firstLineIndent, pointsUnit, -con.modal_indent)  # negative modal indent\n            desc142.putUnitDouble(startIndent, pointsUnit, con.modal_indent)  # modal indent\n            desc142.putUnitDouble(spaceBefore, pointsUnit, 1)\n            desc142.putUnitDouble(spaceAfter, pointsUnit, 0)\n            desc143.putString(fontPostScriptName, con.font_mana)  # NDPMTG default\n            desc143.putString(fontName, con.font_rules_text)  # MPlantin default\n            desc143.putUnitDouble(size, pointsUnit, 12)\n            desc143.putBoolean(autoLeading, False)\n            desc142.putObject(sID(\"defaultStyle\"), textStyle, desc143)\n            desc141.putObject(paragraphStyle, paragraphStyle, desc142)\n            style_list.putObject(paragraphStyleRange, desc141)\n            main_descriptor.putList(paragraphStyleRange, style_list)\n\n        # Flavor text actions\n        if self.flavor_index &gt;= 0:\n            # Add linebreak spacing between rules and flavor text\n            desc141.putInteger(idFrom, self.flavor_index + 3)\n            desc141.putInteger(idTo, self.flavor_index + 4)\n            desc142.putUnitDouble(firstLineIndent, pointsUnit, 0)\n            desc142.putUnitDouble(sID(\"impliedFirstLineIndent\"), pointsUnit, 0)\n            desc142.putUnitDouble(startIndent, pointsUnit, 0)\n            desc142.putUnitDouble(sID(\"impliedStartIndent\"), pointsUnit, 0)\n            desc142.putUnitDouble(spaceBefore, pointsUnit, self.flavor_text_lead)  # Space between rules and flavor text\n            desc141.putObject(paragraphStyle, paragraphStyle, desc142)\n            style_list.putObject(paragraphStyleRange, desc141)\n            main_descriptor.putList(paragraphStyleRange, style_list)\n\n            # Adjust flavor text color\n            if self.flavor_color:\n                colored_range = ActionList()\n                colored_style = ActionDescriptor()\n                desc145 = ActionDescriptor()\n                colored_style.PutInteger(sID(\"from\"), self.flavor_index)\n                colored_style.PutInteger(sID(\"to\"), len(self.input))\n                desc145.putString(fontPostScriptName, con.font_rules_text_italic)  # MPlantin italic default\n                desc145.putString(fontName, con.font_rules_text_italic)  # MPlantin italic default\n                desc145.putUnitDouble(size, pointsUnit, self.font_size)\n                desc145.putBoolean(autoLeading, False)\n                desc145.putUnitDouble(leading, pointsUnit, self.font_size)\n                apply_color(desc145, self.flavor_color)\n                colored_style.PutObject(sID(\"textStyle\"), sID(\"textStyle\"), desc145)\n                colored_range.PutObject(sID(\"textStyleRange\"), colored_style)\n                main_descriptor.putList(sID(\"textStyleRange\"), colored_range)\n\n        # Quote actions flavor text\n        if self.quote_index &gt;= 0:\n            # Adjust line break spacing if there's a line break in the flavor text\n            desc141.putInteger(idFrom, self.quote_index + 3)\n            desc141.putInteger(idTo, len(self.input))\n            desc142.putUnitDouble(spaceBefore, pointsUnit, 0)\n            desc141.putObject(paragraphStyle, paragraphStyle, desc142)\n            style_list.putObject(paragraphStyleRange, desc141)\n\n            # Optional, align quote credit to right\n            if self.right_align_quote and self.input.find('\"\\r\u2014') &gt;= 0:\n                # Get start and ending index of quotation credit\n                index_start = self.input.find('\"\\r\u2014') + 2\n                index_end = len(self.input) - 1\n\n                # Align this part, disable justification reset\n                ft.align_formatted_text_right(style_list, index_start, index_end)\n\n            # Add quote actions to primary action\n            main_descriptor.putList(paragraphStyleRange, style_list)\n\n        # Push changes to text layer\n        textLayer = sID(\"textLayer\")\n        ref101 = ActionReference()\n        desc119 = ActionDescriptor()\n        ref101.putEnumerated(textLayer, sID(\"ordinal\"), sID(\"targetEnum\"))\n        desc119.putReference(sID(\"target\"), ref101)\n        desc119.putObject(idTo, textLayer, main_descriptor)\n        app.executeAction(sID(\"set\"), desc119, NO_DIALOG)\n\n        # Disable hyphenation and set text composer\n        self.docref.activeLayer.textItem.hyphenation = False\n        # TODO: Test if this line is necessary\n        # set_composer_single_line(self.layer)\n\n    def execute(self):\n        super().execute()\n\n        # Format text\n        self.docref.activeLayer = self.layer\n        self.format_text()\n        if self.contents_centered:\n            self.layer.textItem.justification = Justification.Center\n</code></pre>"},{"location":"text_layers/#src.text_layers.FormattedTextField.format_text","title":"<code>format_text()</code>","text":"<p>Inserts the given string into the active layer and formats it according to defined parameters with symbols from the NDPMTG font.</p> Source code in <code>src/text_layers.py</code> <pre><code>def format_text(self):\n    \"\"\"\n    Inserts the given string into the active layer and formats it according to defined parameters with symbols\n    from the NDPMTG font.\n    \"\"\"\n    # Set up main descriptors and lists\n    main_descriptor = ActionDescriptor()\n    style_list = ActionList()\n    main_list = ActionList()\n\n    # Descriptor ID's\n    idTo = sID(\"to\")\n    size = sID(\"size\")\n    idFrom = sID(\"from\")\n    leading = sID(\"leading\")\n    fontName = sID(\"fontName\")\n    textStyle = sID(\"textStyle\")\n    pointsUnit = sID(\"pointsUnit\")\n    spaceAfter = sID(\"spaceAfter\")\n    autoLeading = sID(\"autoLeading\")\n    startIndent = sID(\"startIndent\")\n    spaceBefore = sID(\"spaceBefore\")\n    leadingType = sID(\"leadingType\")\n    styleRange = sID(\"textStyleRange\")\n    paragraphStyle = sID(\"paragraphStyle\")\n    firstLineIndent = sID(\"firstLineIndent\")\n    fontPostScriptName = sID(\"fontPostScriptName\")\n    paragraphStyleRange = sID(\"paragraphStyleRange\")\n\n    # Spin up the text insertion action\n    main_style = ActionDescriptor()\n    main_range = ActionDescriptor()\n    main_descriptor.putString(sID(\"textKey\"), self.input)\n    main_range.putInteger(idFrom, 0)\n    main_range.putInteger(idTo, len(self.input))\n    main_style.putString(fontPostScriptName, con.font_rules_text)  # MPlantin default\n    main_style.putString(fontName, con.font_rules_text)  # MPlantin default\n    main_style.putUnitDouble(size, pointsUnit, self.font_size)\n    apply_color(main_style, self.color)\n    main_style.putBoolean(autoLeading, False)\n    main_style.putUnitDouble(leading, pointsUnit, self.font_size)\n    main_range.putObject(textStyle, textStyle, main_style)\n    main_list.putObject(styleRange, main_range)\n\n    # Bold the contents if necessary\n    if self.bold_rules_text and self.flavor_index != 0:\n        bold_range = ActionDescriptor()\n        bold_style = ActionDescriptor()\n        contents_index = len(self.input) - 1 if self.flavor_index &lt; 0 else self.flavor_index - 1\n        bold_range.putInteger(idFrom, 0)  # bold start index\n        bold_range.putInteger(idTo, contents_index)  # bold end index\n        bold_style.putString(fontPostScriptName, con.font_rules_text_bold)\n        bold_style.putString(fontName, con.font_rules_text_bold)\n        bold_style.putUnitDouble(size, pointsUnit, self.font_size)\n        apply_color(bold_style, self.color)\n        bold_style.putBoolean(autoLeading, False)\n        bold_style.putUnitDouble(leading, pointsUnit, self.font_size)\n        bold_range.putObject(textStyle, textStyle, bold_style)\n        main_list.putObject(styleRange, bold_range)\n\n    # Italicize text from our italics indices\n    for i in self.italics_indices:\n        italic_range = ActionDescriptor()\n        italic_style = ActionDescriptor()\n        italic_range.putInteger(idFrom, i['start_index'])  # italics start index\n        italic_range.putInteger(idTo, i['end_index'])  # italics end index\n        italic_style.putString(fontPostScriptName, con.font_rules_text_italic)\n        italic_style.putString(fontName, con.font_rules_text_italic)\n        italic_style.putUnitDouble(size, pointsUnit, self.font_size)\n        apply_color(italic_style, self.color)\n        italic_style.putBoolean(autoLeading, False)\n        italic_style.putUnitDouble(leading, pointsUnit, self.font_size)\n        italic_range.putObject(textStyle, textStyle, italic_style)\n        main_list.putObject(styleRange, italic_range)\n\n    # Format each symbol correctly\n    for symbol_index in self.symbol_indices:\n        ft.format_symbol(\n            action_list=main_list,\n            symbol_index=symbol_index['index'],\n            symbol_colors=symbol_index['colors'],\n            font_size=self.font_size,\n        )\n\n    # Insert actions for bold, italics, and symbol formatting\n    main_descriptor.putList(styleRange, main_list)\n\n    # Paragraph formatting\n    desc141 = ActionDescriptor()\n    desc142 = ActionDescriptor()\n    desc141.putInteger(idFrom, 0)\n    desc141.putInteger(idTo, len(self.input))  # input string length\n    desc142.putUnitDouble(firstLineIndent, pointsUnit, 0)\n    desc142.putUnitDouble(startIndent, pointsUnit, 0)\n    desc142.putUnitDouble(sID(\"endIndent\"), pointsUnit, 0)\n    desc142.putUnitDouble(spaceBefore, pointsUnit, self.line_break_lead)\n    desc142.putUnitDouble(spaceAfter, pointsUnit, 0)\n    desc142.putInteger(sID(\"dropCapMultiplier\"), 1)\n    desc142.putEnumerated(leadingType, leadingType, sID(\"leadingBelow\"))\n\n    # Adjust formatting for modal card with bullet points\n    if \"\\u2022\" in self.input:\n        desc143 = ActionDescriptor()\n        startIndexBullet = self.input.find(\"\\u2022\")\n        endIndexBullet = self.input.rindex(\"\\u2022\")\n        desc141.putInteger(idFrom, startIndexBullet)\n        desc141.putInteger(idTo, endIndexBullet + 1)\n        desc142.putUnitDouble(firstLineIndent, pointsUnit, -con.modal_indent)  # negative modal indent\n        desc142.putUnitDouble(startIndent, pointsUnit, con.modal_indent)  # modal indent\n        desc142.putUnitDouble(spaceBefore, pointsUnit, 1)\n        desc142.putUnitDouble(spaceAfter, pointsUnit, 0)\n        desc143.putString(fontPostScriptName, con.font_mana)  # NDPMTG default\n        desc143.putString(fontName, con.font_rules_text)  # MPlantin default\n        desc143.putUnitDouble(size, pointsUnit, 12)\n        desc143.putBoolean(autoLeading, False)\n        desc142.putObject(sID(\"defaultStyle\"), textStyle, desc143)\n        desc141.putObject(paragraphStyle, paragraphStyle, desc142)\n        style_list.putObject(paragraphStyleRange, desc141)\n        main_descriptor.putList(paragraphStyleRange, style_list)\n\n    # Flavor text actions\n    if self.flavor_index &gt;= 0:\n        # Add linebreak spacing between rules and flavor text\n        desc141.putInteger(idFrom, self.flavor_index + 3)\n        desc141.putInteger(idTo, self.flavor_index + 4)\n        desc142.putUnitDouble(firstLineIndent, pointsUnit, 0)\n        desc142.putUnitDouble(sID(\"impliedFirstLineIndent\"), pointsUnit, 0)\n        desc142.putUnitDouble(startIndent, pointsUnit, 0)\n        desc142.putUnitDouble(sID(\"impliedStartIndent\"), pointsUnit, 0)\n        desc142.putUnitDouble(spaceBefore, pointsUnit, self.flavor_text_lead)  # Space between rules and flavor text\n        desc141.putObject(paragraphStyle, paragraphStyle, desc142)\n        style_list.putObject(paragraphStyleRange, desc141)\n        main_descriptor.putList(paragraphStyleRange, style_list)\n\n        # Adjust flavor text color\n        if self.flavor_color:\n            colored_range = ActionList()\n            colored_style = ActionDescriptor()\n            desc145 = ActionDescriptor()\n            colored_style.PutInteger(sID(\"from\"), self.flavor_index)\n            colored_style.PutInteger(sID(\"to\"), len(self.input))\n            desc145.putString(fontPostScriptName, con.font_rules_text_italic)  # MPlantin italic default\n            desc145.putString(fontName, con.font_rules_text_italic)  # MPlantin italic default\n            desc145.putUnitDouble(size, pointsUnit, self.font_size)\n            desc145.putBoolean(autoLeading, False)\n            desc145.putUnitDouble(leading, pointsUnit, self.font_size)\n            apply_color(desc145, self.flavor_color)\n            colored_style.PutObject(sID(\"textStyle\"), sID(\"textStyle\"), desc145)\n            colored_range.PutObject(sID(\"textStyleRange\"), colored_style)\n            main_descriptor.putList(sID(\"textStyleRange\"), colored_range)\n\n    # Quote actions flavor text\n    if self.quote_index &gt;= 0:\n        # Adjust line break spacing if there's a line break in the flavor text\n        desc141.putInteger(idFrom, self.quote_index + 3)\n        desc141.putInteger(idTo, len(self.input))\n        desc142.putUnitDouble(spaceBefore, pointsUnit, 0)\n        desc141.putObject(paragraphStyle, paragraphStyle, desc142)\n        style_list.putObject(paragraphStyleRange, desc141)\n\n        # Optional, align quote credit to right\n        if self.right_align_quote and self.input.find('\"\\r\u2014') &gt;= 0:\n            # Get start and ending index of quotation credit\n            index_start = self.input.find('\"\\r\u2014') + 2\n            index_end = len(self.input) - 1\n\n            # Align this part, disable justification reset\n            ft.align_formatted_text_right(style_list, index_start, index_end)\n\n        # Add quote actions to primary action\n        main_descriptor.putList(paragraphStyleRange, style_list)\n\n    # Push changes to text layer\n    textLayer = sID(\"textLayer\")\n    ref101 = ActionReference()\n    desc119 = ActionDescriptor()\n    ref101.putEnumerated(textLayer, sID(\"ordinal\"), sID(\"targetEnum\"))\n    desc119.putReference(sID(\"target\"), ref101)\n    desc119.putObject(idTo, textLayer, main_descriptor)\n    app.executeAction(sID(\"set\"), desc119, NO_DIALOG)\n\n    # Disable hyphenation and set text composer\n    self.docref.activeLayer.textItem.hyphenation = False\n</code></pre>"},{"location":"text_layers/#src.text_layers.ScaledTextField","title":"<code>ScaledTextField</code>","text":"<p>             Bases: <code>TextField</code></p> <p>A TextField which automatically scales down its font size until the right bound no longer overlaps with a reference layer's left bound.</p> Source code in <code>src/text_layers.py</code> <pre><code>class ScaledTextField (TextField):\n    \"\"\"\n    A TextField which automatically scales down its font size until the right bound\n    no longer overlaps with a reference layer's left bound.\n    \"\"\"\n    @cached_property\n    def flip_scale(self) -&gt; bool:\n        return self.kwargs.get('flip_scale', False)\n\n    @cached_property\n    def scale_action(self) -&gt; Callable:\n        if self.flip_scale:\n            return ft.scale_text_left_overlap\n        return ft.scale_text_right_overlap\n\n    def execute(self):\n        super().execute()\n\n        # Scale down the text layer until it doesn't overlap with a reference layer\n        if self.reference:\n            self.scale_action(self.layer, self.reference)\n</code></pre>"},{"location":"text_layers/#src.text_layers.ScaledWidthTextField","title":"<code>ScaledWidthTextField</code>","text":"<p>             Bases: <code>TextField</code></p> <p>A TextField which automatically scales down its font size until the width of the layer is within the horizontal bound of a reference layer.</p> Source code in <code>src/text_layers.py</code> <pre><code>class ScaledWidthTextField (TextField):\n    \"\"\"\n    A TextField which automatically scales down its font size until the width of the\n    layer is within the horizontal bound of a reference layer.\n    \"\"\"\n\n    def execute(self):\n        super().execute()\n\n        # Scale down the text layer until it doesn't overlap with a reference layer\n        if self.reference:\n            ft.scale_text_to_fit_reference(self.layer, self.reference, height=False)\n</code></pre>"},{"location":"text_layers/#src.text_layers.TextField","title":"<code>TextField</code>","text":"<p>A generic TextField, which allows you to set a text layer's contents and text color. @param layer: TextItem layer to insert contents. @param contents: Text contents to be inserted. @param color: Font color to use for this TextItem. @param kwargs: Optional keyword parameters.</p> Source code in <code>src/text_layers.py</code> <pre><code>class TextField:\n    \"\"\"\n    A generic TextField, which allows you to set a text layer's contents and text color.\n    @param layer: TextItem layer to insert contents.\n    @param contents: Text contents to be inserted.\n    @param color: Font color to use for this TextItem.\n    @param kwargs: Optional keyword parameters.\n    \"\"\"\n    def __init__(self, layer: ArtLayer, contents: str = \"\", **kwargs):\n        # Mandatory attributes\n        self.kwargs = kwargs\n        self.layer = layer\n        self.layer.visible = True\n        self.contents = contents.replace(\"\\n\", \"\\r\")\n\n        # Change to English formatting if needed\n        if self.layer.kind == LayerKind.TextLayer and cfg.force_english_formatting:\n            self.layer.textItem.language = Language.EnglishUSA\n\n    \"\"\"\n    PROPERTIES\n    \"\"\"\n\n    @property\n    def input(self) -&gt; str:\n        return self.contents\n\n    @cached_property\n    def reference(self) -&gt; Optional[ArtLayer]:\n        return self.kwargs.get('reference', None)\n\n    @cached_property\n    def color(self) -&gt; SolidColor:\n        return self.kwargs.get('color', get_text_layer_color(self.layer))\n\n    @cached_property\n    def docref(self) -&gt; Document:\n        return app.activeDocument\n\n    \"\"\"\n    METHODS\n    \"\"\"\n\n    def execute(self):\n        \"\"\"\n        Executes all text actions.\n        \"\"\"\n        self.layer.textItem.contents = self.input\n        self.layer.textItem.color = self.color\n</code></pre>"},{"location":"text_layers/#src.text_layers.TextField.execute","title":"<code>execute()</code>","text":"<p>Executes all text actions.</p> Source code in <code>src/text_layers.py</code> <pre><code>def execute(self):\n    \"\"\"\n    Executes all text actions.\n    \"\"\"\n    self.layer.textItem.contents = self.input\n    self.layer.textItem.color = self.color\n</code></pre>"},{"location":"helpers/actions/","title":"Actions","text":"<p>ACTION HELPERS</p>"},{"location":"helpers/actions/#src.helpers.actions.run_action","title":"<code>run_action(action_set, action)</code>","text":"<p>Runs a Photoshop action. @param action_set: Name of the group the action is in. @param action: Name of the action.</p> Source code in <code>src/helpers/actions.py</code> <pre><code>def run_action(action_set: str, action: str) -&gt; None:\n    \"\"\"\n    Runs a Photoshop action.\n    @param action_set: Name of the group the action is in.\n    @param action: Name of the action.\n    \"\"\"\n    desc310 = ActionDescriptor()\n    ref7 = ActionReference()\n    desc310.putBoolean(sID(\"dontRecord\"), False)\n    desc310.putBoolean(sID(\"forceNotify\"), True)\n    ref7.putName(sID(\"action\"),  action)\n    ref7.putName(sID(\"actionSet\"),  action_set)\n    desc310.putReference(sID(\"target\"),  ref7)\n    app.ExecuteAction(sID(\"play\"), desc310, NO_DIALOG)\n</code></pre>"},{"location":"helpers/adjustments/","title":"Adjustments","text":""},{"location":"helpers/adjustments/#src.helpers.adjustments.create_color_layer","title":"<code>create_color_layer(color, layer, **kwargs)</code>","text":"<p>Create a solid color adjustment layer. @param color: Color to use for the layer. @param layer: ArtLayer or LayerSet to make active. @keyword clipped (bool): Whether to apply as a clipping mask to the nearest layer, defaults to True. @return: The new solid color adjustment layer.</p> Source code in <code>src/helpers/adjustments.py</code> <pre><code>def create_color_layer(color: SolidColor, layer: Union[ArtLayer, LayerSet, None], **kwargs) -&gt; ArtLayer:\n    \"\"\"\n    Create a solid color adjustment layer.\n    @param color: Color to use for the layer.\n    @param layer: ArtLayer or LayerSet to make active.\n    @keyword clipped (bool): Whether to apply as a clipping mask to the nearest layer, defaults to True.\n    @return: The new solid color adjustment layer.\n    \"\"\"\n    if layer:\n        app.activeDocument.activeLayer = layer\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    desc2 = ActionDescriptor()\n    desc3 = ActionDescriptor()\n    ref1.putClass(sID(\"contentLayer\"))\n    desc1.putReference(sID(\"target\"), ref1)\n    desc2.putBoolean(sID(\"group\"), kwargs.get('clipped', True))\n    desc2.putEnumerated(sID(\"color\"), sID(\"color\"), sID(\"blue\"))\n    apply_color(desc3, color)\n    desc2.putObject(sID(\"type\"), sID(\"solidColorLayer\"), desc3)\n    desc1.putObject(sID(\"using\"), sID(\"contentLayer\"), desc2)\n    app.executeAction(sID(\"make\"), desc1, NO_DIALOG)\n    return app.activeDocument.activeLayer\n</code></pre>"},{"location":"helpers/adjustments/#src.helpers.adjustments.create_gradient_layer","title":"<code>create_gradient_layer(colors, layer, **kwargs)</code>","text":"<p>Create a gradient adjustment layer. @param colors: List of gradient color dicts. @param layer: ArtLayer or LayerSet to make active. @keyword clipped (bool): Whether to apply as a clipping mask to the nearest layer, defaults to True. @keyword rotation (Union[int, float]): Rotation to apply to the gradient, defaults to 90. @keyword scale (Union[int, float]): Scale to apply to the gradient, defaults to 100. @return: The new gradient adjustment layer.</p> Source code in <code>src/helpers/adjustments.py</code> <pre><code>def create_gradient_layer(colors: list[dict], layer: Union[ArtLayer, LayerSet, None], **kwargs) -&gt; ArtLayer:\n    \"\"\"\n    Create a gradient adjustment layer.\n    @param colors: List of gradient color dicts.\n    @param layer: ArtLayer or LayerSet to make active.\n    @keyword clipped (bool): Whether to apply as a clipping mask to the nearest layer, defaults to True.\n    @keyword rotation (Union[int, float]): Rotation to apply to the gradient, defaults to 90.\n    @keyword scale (Union[int, float]): Scale to apply to the gradient, defaults to 100.\n    @return: The new gradient adjustment layer.\n    \"\"\"\n    if layer:\n        app.activeDocument.activeLayer = layer\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    desc2 = ActionDescriptor()\n    desc3 = ActionDescriptor()\n    desc4 = ActionDescriptor()\n    color_list = ActionList()\n    list2 = ActionList()\n    desc9 = ActionDescriptor()\n    desc10 = ActionDescriptor()\n    ref1.putClass(sID(\"contentLayer\"))\n    desc1.putReference(sID(\"target\"),  ref1)\n    desc2.putBoolean(sID(\"group\"), kwargs.get('clipped', True))\n    desc3.putEnumerated(\n        sID(\"gradientsInterpolationMethod\"),\n        sID(\"gradientInterpolationMethodType\"),\n        sID(\"perceptual\")\n    )\n    desc3.putUnitDouble(sID(\"angle\"), sID(\"angleUnit\"), kwargs.get('rotation', 0))\n    desc3.putEnumerated(sID(\"type\"), sID(\"gradientType\"), sID(\"linear\"))\n    desc3.putUnitDouble(sID(\"scale\"), sID(\"percentUnit\"), kwargs.get('scale', 100))\n    desc4.putEnumerated(sID(\"gradientForm\"), sID(\"gradientForm\"), sID(\"customStops\"))\n    desc4.putDouble(sID(\"interfaceIconFrameDimmed\"),  4096)\n    for c in colors:\n        add_color_to_gradient(\n            color_list,\n            get_color(c.get('color', rgb_black())),\n            int(c.get('location', 0)),\n            int(c.get('midpoint', 50))\n        )\n    desc4.putList(sID(\"colors\"),  color_list)\n    desc9.putUnitDouble(sID(\"opacity\"), sID(\"percentUnit\"),  100)\n    desc9.putInteger(sID(\"location\"),  0)\n    desc9.putInteger(sID(\"midpoint\"),  50)\n    list2.putObject(sID(\"transferSpec\"),  desc9)\n    desc10.putUnitDouble(sID(\"opacity\"), sID(\"percentUnit\"),  100)\n    desc10.putInteger(sID(\"location\"),  4096)\n    desc10.putInteger(sID(\"midpoint\"),  50)\n    list2.putObject(sID(\"transferSpec\"),  desc10)\n    desc4.putList(sID(\"transparency\"),  list2)\n    desc3.putObject(sID(\"gradient\"), sID(\"gradientClassEvent\"),  desc4)\n    desc2.putObject(sID(\"type\"), sID(\"gradientLayer\"),  desc3)\n    desc1.putObject(sID(\"using\"), sID(\"contentLayer\"),  desc2)\n    app.executeAction(sID(\"make\"), desc1,  NO_DIALOG)\n    return app.activeDocument.activeLayer\n</code></pre>"},{"location":"helpers/adjustments/#src.helpers.adjustments.create_vibrant_saturation","title":"<code>create_vibrant_saturation(vibrancy, saturation)</code>","text":"<p>Experimental scoot action to add vibrancy and saturation. @param vibrancy: Vibrancy level integer @param saturation: Saturation level integer</p> Source code in <code>src/helpers/adjustments.py</code> <pre><code>def create_vibrant_saturation(vibrancy: int, saturation: int) -&gt; None:\n    \"\"\"\n    Experimental scoot action to add vibrancy and saturation.\n    @param vibrancy: Vibrancy level integer\n    @param saturation: Saturation level integer\n    \"\"\"\n    # dialogMode (Have dialog popup?)\n    desc232 = ActionDescriptor()\n    desc232.putInteger(sID(\"vibrance\"), vibrancy)\n    desc232.putInteger(sID(\"saturation\"), saturation)\n    app.executeAction(sID(\"vibrance\"), desc232, NO_DIALOG)\n</code></pre>"},{"location":"helpers/bounds/","title":"Bounds","text":"<p>BOUNDS HELPERS</p>"},{"location":"helpers/bounds/#src.helpers.bounds.check_textbox_overflow","title":"<code>check_textbox_overflow(layer)</code>","text":"<p>Check if a TextLayer overflows the bounding box. @param layer: ArtLayer with \"kind\" of TextLayer. @return: True if text overflowing, else False.</p> Source code in <code>src/helpers/bounds.py</code> <pre><code>def check_textbox_overflow(layer: ArtLayer) -&gt; bool:\n    \"\"\"\n    Check if a TextLayer overflows the bounding box.\n    @param layer: ArtLayer with \"kind\" of TextLayer.\n    @return: True if text overflowing, else False.\n    \"\"\"\n    if layer.kind != LayerKind.TextLayer:\n        return False\n\n    # Create a test layer to check the difference\n    height = get_text_layer_dimensions(layer)['height']\n    layer.textItem.height = 1000\n    dif = get_text_layer_dimensions(layer)['height'] - height\n    undo_action()\n    if dif &gt; 0:\n        return True\n    return False\n</code></pre>"},{"location":"helpers/bounds/#src.helpers.bounds.get_bounds_no_effects","title":"<code>get_bounds_no_effects(layer)</code>","text":"<p>Returns the bounds of a given layer without its effects applied. @param layer: A layer object @return list: Pixel location top left, top right, bottom left, bottom right.</p> Source code in <code>src/helpers/bounds.py</code> <pre><code>def get_bounds_no_effects(layer: Union[ArtLayer, LayerSet]) -&gt; list[int, int, int, int]:\n    \"\"\"\n    Returns the bounds of a given layer without its effects applied.\n    @param layer: A layer object\n    @return list: Pixel location top left, top right, bottom left, bottom right.\n    \"\"\"\n    reference = ActionReference()\n    reference.putIdentifier(sID('layer'), layer.id)\n    descriptor = app.executeActionGet(reference)\n    try:\n        bounds = descriptor.getObjectValue(sID('boundsNoEffects'))\n    except PS_EXCEPTIONS:\n        bounds = descriptor.getObjectValue(sID('bounds'))\n    return [\n        bounds.getInteger(sID('left')),\n        bounds.getInteger(sID('top')),\n        bounds.getInteger(sID('right')),\n        bounds.getInteger(sID('bottom'))\n    ]\n</code></pre>"},{"location":"helpers/bounds/#src.helpers.bounds.get_dimensions_from_bounds","title":"<code>get_dimensions_from_bounds(bounds)</code>","text":"<p>Compute width and height based on a set of bounds given. @param bounds: List of bounds given. @return: Dict containing height, width, and positioning locations.</p> Source code in <code>src/helpers/bounds.py</code> <pre><code>def get_dimensions_from_bounds(bounds: list) -&gt; dict[str: Union[float, int]]:\n    \"\"\"\n    Compute width and height based on a set of bounds given.\n    @param bounds: List of bounds given.\n    @return: Dict containing height, width, and positioning locations.\n    \"\"\"\n    width = int(bounds[2]-bounds[0])\n    height = int(bounds[3]-bounds[1])\n    return {\n        'width': width,\n        'height': height,\n        'center_x': (width / 2) + bounds[0],\n        'center_y': (height / 2) + bounds[1],\n        'left': bounds[0], 'right': bounds[2],\n        'top': bounds[1], 'bottom': bounds[3]\n    }\n</code></pre>"},{"location":"helpers/bounds/#src.helpers.bounds.get_dimensions_no_effects","title":"<code>get_dimensions_no_effects(layer)</code>","text":"<p>Compute the dimensions of a layer without its effects applied. @param layer: A layer object @return: Dict containing height, width, and positioning locations.</p> Source code in <code>src/helpers/bounds.py</code> <pre><code>def get_dimensions_no_effects(layer: Union[ArtLayer, LayerSet]) -&gt; dict[str: Union[float, int]]:\n    \"\"\"\n    Compute the dimensions of a layer without its effects applied.\n    @param layer: A layer object\n    @return: Dict containing height, width, and positioning locations.\n    \"\"\"\n    bounds = get_bounds_no_effects(layer)\n    return get_dimensions_from_bounds(bounds)\n</code></pre>"},{"location":"helpers/bounds/#src.helpers.bounds.get_layer_dimensions","title":"<code>get_layer_dimensions(layer)</code>","text":"<p>Compute the width and height dimensions of a layer. @param layer: A layer object @return: Dict containing height, width, and positioning locations.</p> Source code in <code>src/helpers/bounds.py</code> <pre><code>def get_layer_dimensions(layer: Union[ArtLayer, LayerSet]) -&gt; dict[str: Union[float, int]]:\n    \"\"\"\n    Compute the width and height dimensions of a layer.\n    @param layer: A layer object\n    @return: Dict containing height, width, and positioning locations.\n    \"\"\"\n    return get_dimensions_from_bounds(layer.bounds)\n</code></pre>"},{"location":"helpers/bounds/#src.helpers.bounds.get_text_layer_bounds","title":"<code>get_text_layer_bounds(layer, legacy=False)</code>","text":"<p>Returns a list of the text layer's bounds [left, top, right, bottom]. @param layer: Layer to get the bounds of. @param legacy: Force old way for legacy Photoshop versions. @return: List of the bounds of a given layer.</p> Source code in <code>src/helpers/bounds.py</code> <pre><code>def get_text_layer_bounds(layer: ArtLayer, legacy: bool = False) -&gt; list[int, int, int, int]:\n    \"\"\"\n    Returns a list of the text layer's bounds [left, top, right, bottom].\n    @param layer: Layer to get the bounds of.\n    @param legacy: Force old way for legacy Photoshop versions.\n    @return: List of the bounds of a given layer.\n    \"\"\"\n    if legacy or int(app.version[0:2]) &lt; 21:\n        layer_copy = layer.duplicate(app.activeDocument, ElementPlacement.PlaceInside)\n        layer_copy.rasterize(RasterizeType.TextContents)\n        layer_bounds = layer.bounds\n        layer_copy.remove()\n        return layer_bounds\n    return layer.bounds\n</code></pre>"},{"location":"helpers/bounds/#src.helpers.bounds.get_text_layer_dimensions","title":"<code>get_text_layer_dimensions(layer, legacy=False)</code>","text":"<p>Return an object with the specified text layer's width and height, on some versions of Photoshop a text layer must be rasterized before pulling accessing its true bounds. @param layer: Layer to get the dimensions of. @param legacy: Force old way for legacy text layers. @return: Dict containing height and width of the given layer.</p> Source code in <code>src/helpers/bounds.py</code> <pre><code>def get_text_layer_dimensions(layer, legacy: bool = False) -&gt; dict[str: Union[int, float]]:\n    \"\"\"\n    Return an object with the specified text layer's width and height, on some versions of Photoshop\n    a text layer must be rasterized before pulling accessing its true bounds.\n    @param layer: Layer to get the dimensions of.\n    @param legacy: Force old way for legacy text layers.\n    @return: Dict containing height and width of the given layer.\n    \"\"\"\n    if legacy or int(app.version[0:2]) &lt; 21:\n        layer_copy = layer.duplicate(app.activeDocument, ElementPlacement.PlaceInside)\n        layer_copy.rasterize(RasterizeType.TextContents)\n        dimensions = get_dimensions_from_bounds(layer_copy.bounds)\n        layer_copy.remove()\n        return dimensions\n    return get_dimensions_from_bounds(layer.bounds)\n</code></pre>"},{"location":"helpers/bounds/#src.helpers.bounds.get_textbox_bounds","title":"<code>get_textbox_bounds(layer)</code>","text":"<p>Get the bounds of a TextLayer's bounding box. @param layer: ArtLayer with \"kind\" of TextLayer. @return: List of bounds integers.</p> Source code in <code>src/helpers/bounds.py</code> <pre><code>def get_textbox_bounds(layer: ArtLayer) -&gt; list[int]:\n    \"\"\"\n    Get the bounds of a TextLayer's bounding box.\n    @param layer: ArtLayer with \"kind\" of TextLayer.\n    @return: List of bounds integers.\n    \"\"\"\n    reference = ActionReference()\n    reference.putIdentifier(sID('layer'), layer.id)\n    descriptor = app.executeActionGet(reference)\n    bounds = descriptor.getObjectValue(sID('boundingBox'))\n    return [\n        bounds.getInteger(sID('left')),\n        bounds.getInteger(sID('top')),\n        bounds.getInteger(sID('right')),\n        bounds.getInteger(sID('bottom'))\n    ]\n</code></pre>"},{"location":"helpers/bounds/#src.helpers.bounds.get_textbox_dimensions","title":"<code>get_textbox_dimensions(layer)</code>","text":"<p>Get the dimensions of a TextLayer's bounding box. @param layer: ArtLayer with \"kind\" of TextLayer. @return: Dict containing width and height.</p> Source code in <code>src/helpers/bounds.py</code> <pre><code>def get_textbox_dimensions(layer: ArtLayer):\n    \"\"\"\n    Get the dimensions of a TextLayer's bounding box.\n    @param layer: ArtLayer with \"kind\" of TextLayer.\n    @return: Dict containing width and height.\n    \"\"\"\n    reference = ActionReference()\n    reference.putIdentifier(sID('layer'), layer.id)\n    descriptor = app.executeActionGet(reference)\n    bounds = descriptor.getObjectValue(sID('boundingBox'))\n    return {\n        'width': bounds.getInteger(sID('width')),\n        'height': bounds.getInteger(sID('height'))\n    }\n</code></pre>"},{"location":"helpers/colors/","title":"Colors","text":"<p>COLOR HELPERS</p>"},{"location":"helpers/colors/#src.helpers.colors.NO_DIALOG","title":"<code>NO_DIALOG = DialogModes.DisplayNoDialogs</code>  <code>module-attribute</code>","text":"<p>CONVERTING COLOR</p>"},{"location":"helpers/colors/#src.helpers.colors.add_color_to_gradient","title":"<code>add_color_to_gradient(action_list, color, location, midpoint)</code>","text":"<p>@param action_list: Action list to add this color to. @param color: SolidColor object @param location: Location of the color along the track. @param midpoint: Percentage midpoint between this color and the next.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def add_color_to_gradient(\n    action_list: ActionList,\n    color: SolidColor,\n    location: int,\n    midpoint: int\n) -&gt; None:\n    \"\"\"\n\n    @param action_list: Action list to add this color to.\n    @param color: SolidColor object\n    @param location: Location of the color along the track.\n    @param midpoint: Percentage midpoint between this color and the next.\n    \"\"\"\n    action = ActionDescriptor()\n    apply_color(action, color)\n    action.putEnumerated(sID(\"type\"), sID(\"colorStopType\"), sID(\"userStop\"))\n    action.putInteger(sID(\"location\"), location)\n    action.putInteger(sID(\"midpoint\"), midpoint)\n    action_list.putObject(sID(\"colorStop\"), action)\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.apply_cmyk","title":"<code>apply_cmyk(action, c, color_type='color')</code>","text":"<p>Apply CMYK SolidColor object to action descriptor. @param action: ActionDescriptor object. @param c: SolidColor object matching CMYK model. @param color_type: Color action descriptor type, defaults to 'color'.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def apply_cmyk(action: ActionDescriptor, c: SolidColor, color_type: str = 'color') -&gt; None:\n    \"\"\"\n    Apply CMYK SolidColor object to action descriptor.\n    @param action: ActionDescriptor object.\n    @param c: SolidColor object matching CMYK model.\n    @param color_type: Color action descriptor type, defaults to 'color'.\n    \"\"\"\n    apply_cmyk_from_list(action, [c.cmyk.cyan, c.cmyk.magenta, c.cmyk.yellow, c.cmyk.black], color_type)\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.apply_cmyk_from_list","title":"<code>apply_cmyk_from_list(action, color, color_type='color')</code>","text":"<p>Applies CMYK color to action descriptor from a list of values. @param action: ActionDescriptor object. @param color: List of integers for R, G, B. @param color_type: Color action descriptor type, defaults to 'color'.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def apply_cmyk_from_list(action: ActionDescriptor, color: list[int], color_type: str = 'color') -&gt; None:\n    \"\"\"\n    Applies CMYK color to action descriptor from a list of values.\n    @param action: ActionDescriptor object.\n    @param color: List of integers for R, G, B.\n    @param color_type: Color action descriptor type, defaults to 'color'.\n    \"\"\"\n    ad = ActionDescriptor()\n    ad.putDouble(sID(\"cyan\"), color[0])\n    ad.putDouble(sID(\"magenta\"), color[1])\n    ad.putDouble(sID(\"yellowColor\"), color[2])\n    ad.putDouble(sID(\"black\"), color[3])\n    action.putObject(sID(color_type), sID(\"CMYKColorClass\"), ad)\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.apply_color","title":"<code>apply_color(action, color, color_type='color')</code>","text":"<p>Applies color to the specified action descriptor. @param action: ActionDescriptor object. @param color: RGB/CMYK SolidColor object, or list of RGB/CMYK values. @param color_type: Color action descriptor type, defaults to 'color'.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def apply_color(action: ActionDescriptor, color: Union[list[int], SolidColor], color_type: str = 'color') -&gt; None:\n    \"\"\"\n    Applies color to the specified action descriptor.\n    @param action: ActionDescriptor object.\n    @param color: RGB/CMYK SolidColor object, or list of RGB/CMYK values.\n    @param color_type: Color action descriptor type, defaults to 'color'.\n    \"\"\"\n    if isinstance(color, list):\n        # List notation\n        return apply_rgb_from_list(action, color, color_type) if (\n            len(color) &lt; 4\n        ) else apply_cmyk_from_list(action, color, color_type)\n    if color.model == ColorModel.RGBModel:\n        # RGB SolidColor object\n        return apply_rgb(action, color, color_type)\n    if color.model == ColorModel.CMYKModel:\n        # CMYK SolidColor object\n        return apply_cmyk(action, color, color_type)\n    raise ValueError(f\"Received unsupported color object: {color}\")\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.apply_rgb","title":"<code>apply_rgb(action, c, color_type='color')</code>","text":"<p>Apply RGB SolidColor object to action descriptor. @param action: ActionDescriptor object. @param c: SolidColor object matching RGB model. @param color_type: Color action descriptor type, defaults to 'color'.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def apply_rgb(action: ActionDescriptor, c: SolidColor, color_type: str = 'color') -&gt; None:\n    \"\"\"\n    Apply RGB SolidColor object to action descriptor.\n    @param action: ActionDescriptor object.\n    @param c: SolidColor object matching RGB model.\n    @param color_type: Color action descriptor type, defaults to 'color'.\n    \"\"\"\n    apply_rgb_from_list(action, [c.rgb.red, c.rgb.green, c.rgb.blue], color_type)\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.apply_rgb_from_list","title":"<code>apply_rgb_from_list(action, color, color_type='color')</code>","text":"<p>Applies RGB color to action descriptor from a list of values. @param action: ActionDescriptor object. @param color: List of integers for R, G, B. @param color_type: Color action descriptor type, defaults to 'color'.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def apply_rgb_from_list(action: ActionDescriptor, color: list[int], color_type: str = 'color') -&gt; None:\n    \"\"\"\n    Applies RGB color to action descriptor from a list of values.\n    @param action: ActionDescriptor object.\n    @param color: List of integers for R, G, B.\n    @param color_type: Color action descriptor type, defaults to 'color'.\n    \"\"\"\n    ad = ActionDescriptor()\n    ad.putDouble(sID(\"red\"), color[0])\n    ad.putDouble(sID(\"green\"), color[1])\n    ad.putDouble(sID(\"blue\"), color[2])\n    action.putObject(sID(color_type), sID(\"RGBColor\"), ad)\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.fill_layer_primary","title":"<code>fill_layer_primary()</code>","text":"<p>Fill active layer using foreground color.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def fill_layer_primary():\n    \"\"\"Fill active layer using foreground color.\"\"\"\n    desc1 = ActionDescriptor()\n    desc1.putEnumerated(sID(\"using\"), sID(\"fillContents\"), sID(\"foregroundColor\"))\n    app.executeAction(sID(\"fill\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.get_cmyk","title":"<code>get_cmyk(c, m, y, k)</code>","text":"<p>Creates a SolidColor object with the given CMYK values. @param c: Float from 0.0 to 100.0 for Cyan component. @param m: Float from 0.0 to 100.0 for Magenta component. @param y: Float from 0.0 to 100.0 for Yellow component. @param k: Float from 0.0 to 100.0 for black component. @return: SolidColor object.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def get_cmyk(c: float, m: float, y: float, k: float) -&gt; SolidColor:\n    \"\"\"\n    Creates a SolidColor object with the given CMYK values.\n    @param c: Float from 0.0 to 100.0 for Cyan component.\n    @param m: Float from 0.0 to 100.0 for Magenta component.\n    @param y: Float from 0.0 to 100.0 for Yellow component.\n    @param k: Float from 0.0 to 100.0 for black component.\n    @return: SolidColor object.\n    \"\"\"\n    color = SolidColor()\n    color.cmyk.cyan = c\n    color.cmyk.magenta = m\n    color.cmyk.yellow = y\n    color.cmyk.black = k\n    return color\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.get_color","title":"<code>get_color(color)</code>","text":"<p>Automatically get either cmyk or rgb color given a range of @param color: Array containing 3 (RGB) or 4 (CMYK) numbers between 0 and 255, or the name of a known color. @return: SolidColor object.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def get_color(color: Union[SolidColor, list[int], str, dict]) -&gt; SolidColor:\n    \"\"\"\n    Automatically get either cmyk or rgb color given a range of\n    @param color: Array containing 3 (RGB) or 4 (CMYK) numbers between 0 and 255, or the name of a known color.\n    @return: SolidColor object.\n    \"\"\"\n    try:\n        if isinstance(color, SolidColor):\n            # Solid color given\n            return color\n        if isinstance(color, dict):\n            # Color dictionary\n            if 'r' in color.keys():\n                # RGB\n                return get_rgb(color['r'], color['g'], color['b'])\n            elif 'c' in color.keys():\n                # CMYK\n                return get_cmyk(color['c'], color['m'], color['y'], color['k'])\n        if isinstance(color, str):\n            # Named color\n            if color in con.colors:\n                return get_color(con.colors[color])\n            # Hexadecimal\n            return get_rgb_from_hex(color)\n        if isinstance(color, list):\n            # List notation\n            if len(color) == 3:\n                # RGB\n                return get_rgb(*color)\n            elif len(color) == 4:\n                # CMYK\n                return get_cmyk(*color)\n    except (ValueError, TypeError):\n        raise ValueError(f\"Invalid color notation given: {color}\")\n    raise ValueError(f\"Unrecognized color notation given: {color}\")\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.get_pinline_gradient","title":"<code>get_pinline_gradient(colors, color_map=None, location_map=None)</code>","text":"<p>Return a gradient color list notation for some given pinline colors. @param colors: Pinline colors to produce a gradient. @param color_map: Color map to color the pinlines. @param location_map: Location map to position gradients. @return: Gradient color list notation.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def get_pinline_gradient(\n        colors: str,\n        color_map: Optional[dict] = None,\n        location_map: dict = None\n) -&gt; Union[SolidColor, list[dict]]:\n    \"\"\"\n    Return a gradient color list notation for some given pinline colors.\n    @param colors: Pinline colors to produce a gradient.\n    @param color_map: Color map to color the pinlines.\n    @param location_map: Location map to position gradients.\n    @return: Gradient color list notation.\n    \"\"\"\n    # Establish the color_map\n    if not color_map:\n        color_map = pinline_color_map\n\n    # Establish the location map\n    if not location_map:\n        location_map = con.gradient_locations\n\n    # Return our colors\n    if not colors:\n        return get_color(color_map.get('Artifact', [0, 0, 0]))\n    if len(colors) == 1:\n        return get_color(color_map.get(colors, [0, 0, 0]))\n    if len(colors) == 2:\n        return [\n            {\n                'color': get_color(color_map.get(colors[0], [0, 0, 0])),\n                'location': location_map[2][0] * 4096, 'midpoint': 50\n            },\n            {\n                'color': get_color(color_map.get(colors[1], [0, 0, 0])),\n                'location': location_map[2][1] * 4096, 'midpoint': 50,\n            }\n        ]\n    if len(colors) == 3:\n        return [\n            {\n                'color': get_color(color_map.get(colors[0], [0, 0, 0])),\n                'location': location_map[3][0] * 4096, 'midpoint': 50\n            },\n            {\n                'color': get_color(color_map.get(colors[1], [0, 0, 0])),\n                'location': location_map[3][1] * 4096, 'midpoint': 50\n            },\n            {\n                'color': get_color(color_map.get(colors[1], [0, 0, 0])),\n                'location': location_map[3][2] * 4096, 'midpoint': 50\n            },\n            {\n                'color': get_color(color_map.get(colors[2], [0, 0, 0])),\n                'location': location_map[3][3] * 4096, 'midpoint': 50\n            }\n        ]\n    if len(colors) == 4 and colors not in [LAYERS.LAND, LAYERS.GOLD]:\n        return [\n            {\n                'color': get_color(color_map.get(colors[0], [0, 0, 0])),\n                'location': location_map[4][0] * 4096, 'midpoint': 50\n            },\n            {\n                'color': get_color(color_map.get(colors[1], [0, 0, 0])),\n                'location': location_map[4][1] * 4096, 'midpoint': 50\n            },\n            {\n                'color': get_color(color_map.get(colors[1], [0, 0, 0])),\n                'location': location_map[4][2] * 4096, 'midpoint': 50\n            },\n            {\n                'color': get_color(color_map.get(colors[2], [0, 0, 0])),\n                'location': location_map[4][3] * 4096, 'midpoint': 50\n            },\n            {\n                'color': get_color(color_map.get(colors[2], [0, 0, 0])),\n                'location': location_map[4][4] * 4096, 'midpoint': 50\n            },\n            {\n                'color': get_color(color_map.get(colors[3], [0, 0, 0])),\n                'location': location_map[4][5] * 4096, 'midpoint': 50\n            }\n        ]\n    return get_color(color_map.get(colors, [0, 0, 0]))\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.get_rgb","title":"<code>get_rgb(r, g, b)</code>","text":"<p>Creates a SolidColor object with the given RGB values. @param r: Integer from 0 to 255 for red spectrum. @param g: Integer from 0 to 255 for green spectrum. @param b: Integer from 0 to 255 for blue spectrum. @return: SolidColor object.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def get_rgb(r: int, g: int, b: int) -&gt; SolidColor:\n    \"\"\"\n    Creates a SolidColor object with the given RGB values.\n    @param r: Integer from 0 to 255 for red spectrum.\n    @param g: Integer from 0 to 255 for green spectrum.\n    @param b: Integer from 0 to 255 for blue spectrum.\n    @return: SolidColor object.\n    \"\"\"\n    color = SolidColor()\n    color.rgb.red = r\n    color.rgb.green = g\n    color.rgb.blue = b\n    return color\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.get_rgb_from_hex","title":"<code>get_rgb_from_hex(hex_code)</code>","text":"<p>Creates an RGB SolidColor object with the given hex value. Allows prepending # or without. @param hex_code: Hexadecimal color code. @return: SolidColor object.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def get_rgb_from_hex(hex_code: str) -&gt; SolidColor:\n    \"\"\"\n    Creates an RGB SolidColor object with the given hex value. Allows prepending # or without.\n    @param hex_code: Hexadecimal color code.\n    @return: SolidColor object.\n    \"\"\"\n    # Remove hashtag\n    hex_code = hex_code.lstrip('#')\n    # Hexadecimal abbreviated\n    if len(hex_code) == 3:\n        hex_code = \"\".join([n * 2 for n in hex_code])\n    # Convert to RGB\n    color = SolidColor()\n    color.rgb.hexValue = hex_code\n    return color\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.get_text_layer_color","title":"<code>get_text_layer_color(layer)</code>","text":"<p>Occasionally, Photoshop has issues with retrieving the color of a text layer. This helper guards against errors and null values by defaulting to rgb_black() in the event of a problem. @param layer: Layer object that must be TextLayer @return: SolidColor object representing the color of the text item.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def get_text_layer_color(layer: ArtLayer) -&gt; SolidColor:\n    \"\"\"\n    Occasionally, Photoshop has issues with retrieving the color of a text layer. This helper guards\n    against errors and null values by defaulting to rgb_black() in the event of a problem.\n    @param layer: Layer object that must be TextLayer\n    @return: SolidColor object representing the color of the text item.\n    \"\"\"\n    if isinstance(layer, ArtLayer) and layer.kind == LayerKind.TextLayer:\n        if hasattr(layer.textItem, 'color'):\n            return layer.textItem.color\n        print(f\"Couldn't retrieve color of layer: {layer.name}\")\n    return rgb_black()\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.hex_to_rgb","title":"<code>hex_to_rgb(color)</code>","text":"<p>Convert a hexadecimal color code into RGB value list. @param color: Hexadecimal color code, e.g. #F5D676 @return: Color in RGB list notation.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def hex_to_rgb(color: str) -&gt; list[int]:\n    \"\"\"\n    Convert a hexadecimal color code into RGB value list.\n    @param color: Hexadecimal color code, e.g. #F5D676\n    @return: Color in RGB list notation.\n    \"\"\"\n    if '#' in color:\n        color = color[1:]\n    return [int(color[i:i+2], 16) for i in (0, 2, 4)]\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.rgb_black","title":"<code>rgb_black()</code>","text":"<p>Creates a black SolidColor object. @return: SolidColor object.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def rgb_black() -&gt; SolidColor:\n    \"\"\"\n    Creates a black SolidColor object.\n    @return: SolidColor object.\n    \"\"\"\n    return get_rgb(0, 0, 0)\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.rgb_grey","title":"<code>rgb_grey()</code>","text":"<p>Creates a grey SolidColor object. @return: SolidColor object.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def rgb_grey() -&gt; SolidColor:\n    \"\"\"\n    Creates a grey SolidColor object.\n    @return: SolidColor object.\n    \"\"\"\n    return get_rgb(170, 170, 170)\n</code></pre>"},{"location":"helpers/colors/#src.helpers.colors.rgb_white","title":"<code>rgb_white()</code>","text":"<p>Creates a white SolidColor object. @return: SolidColor object.</p> Source code in <code>src/helpers/colors.py</code> <pre><code>def rgb_white() -&gt; SolidColor:\n    \"\"\"\n    Creates a white SolidColor object.\n    @return: SolidColor object.\n    \"\"\"\n    return get_rgb(255, 255, 255)\n</code></pre>"},{"location":"helpers/design/","title":"Design","text":"<p>DESIGN HELPERs</p>"},{"location":"helpers/design/#src.helpers.design.NO_DIALOG","title":"<code>NO_DIALOG = DialogModes.DisplayNoDialogs</code>  <code>module-attribute</code>","text":"<p>FILLING SPACE</p>"},{"location":"helpers/design/#src.helpers.design.content_aware_fill","title":"<code>content_aware_fill()</code>","text":"<p>Fills the current selection using content aware fill.</p> Source code in <code>src/helpers/design.py</code> <pre><code>def content_aware_fill() -&gt; None:\n    \"\"\"Fills the current selection using content aware fill.\"\"\"\n    desc = ActionDescriptor()\n    desc.putEnumerated(sID(\"using\"), sID(\"fillContents\"), sID(\"contentAware\"))\n    desc.putUnitDouble(sID(\"opacity\"), sID(\"percentUnit\"), 100)\n    desc.putEnumerated(sID(\"mode\"), sID(\"blendMode\"), sID(\"normal\"))\n    app.executeAction(sID(\"fill\"), desc, NO_DIALOG)\n</code></pre>"},{"location":"helpers/design/#src.helpers.design.content_aware_fill_edges","title":"<code>content_aware_fill_edges(layer=None)</code>","text":"<p>Rasterizes a given layer (or active layer) and fills remaining pixels using content-aware fill. @param layer: Layer to use for the content aware fill. Uses active if not provided.</p> Source code in <code>src/helpers/design.py</code> <pre><code>def content_aware_fill_edges(layer: Optional[ArtLayer] = None) -&gt; None:\n    \"\"\"\n    Rasterizes a given layer (or active layer) and fills remaining pixels using content-aware fill.\n    @param layer: Layer to use for the content aware fill. Uses active if not provided.\n    \"\"\"\n    # Set active layer if needed, then rasterize\n    docref = app.activeDocument\n    if layer:\n        docref.activeLayer = layer\n    docref.activeLayer.rasterize(RasterizeType.EntireLayer)\n\n    # Select pixels of active layer and invert\n    select_layer_pixels(docref.activeLayer)\n    selection = docref.selection\n    selection.invert()\n\n    # Guard against no selection made\n    try:\n        _ = selection.bounds\n    except PS_EXCEPTIONS:\n        return\n\n    # Expand and smooth selection\n    selection.expand(8)\n    selection.smooth(4)\n\n    # Content aware fill\n    content_aware_fill()\n    selection.deselect()\n</code></pre>"},{"location":"helpers/design/#src.helpers.design.fill_empty_area","title":"<code>fill_empty_area(reference, color=None)</code>","text":"<p>Fills empty gaps on an art layer, such as an expansion symbol, with a solid color. @param reference: Reference layer to put the new fill layer underneath @param color: Color of the background fill</p> Source code in <code>src/helpers/design.py</code> <pre><code>def fill_empty_area(reference: ArtLayer, color: Optional[SolidColor] = None) -&gt; ArtLayer:\n    \"\"\"\n    Fills empty gaps on an art layer, such as an expansion symbol, with a solid color.\n    @param reference: Reference layer to put the new fill layer underneath\n    @param color: Color of the background fill\n    \"\"\"\n    # Magic Wand contiguous outside symbol\n    coords = ActionDescriptor()\n    coords.putUnitDouble(cID(\"Hrzn\"), cID(\"#Pxl\"), 5)\n    coords.putUnitDouble(cID(\"Vrtc\"), cID(\"#Pxl\"), 5)\n    click1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.putProperty(cID(\"Chnl\"), cID(\"fsel\"))\n    click1.putReference(sID(\"target\"), ref1)\n    click1.putObject(cID(\"T   \"), cID(\"Pnt \"), coords)\n    click1.putInteger(cID(\"Tlrn\"), 12)\n    click1.putBoolean(cID(\"AntA\"), True)\n    app.executeAction(cID(\"setd\"), click1)\n\n    # Invert selection\n    app.activeDocument.selection.invert()\n    app.activeDocument.selection.contract(1)\n\n    # Make a new layer\n    layer = app.activeDocument.artLayers.add()\n    layer.name = \"Expansion Mask\"\n    layer.blendMode = BlendMode.NormalBlend\n    layer.moveAfter(reference)\n\n    # Fill selection with stroke color\n    app.foregroundColor = color or rgb_black()\n    click3 = ActionDescriptor()\n    click3.putObject(cID(\"From\"), cID(\"Pnt \"), coords)\n    click3.putInteger(cID(\"Tlrn\"), 0)\n    click3.putEnumerated(cID(\"Usng\"), cID(\"FlCn\"), cID(\"FrgC\"))\n    click3.putBoolean(cID(\"Cntg\"), False)\n    app.executeAction(cID(\"Fl  \"), click3)\n\n    # Clear Selection\n    app.activeDocument.selection.deselect()\n    return layer\n</code></pre>"},{"location":"helpers/design/#src.helpers.design.generative_fill","title":"<code>generative_fill()</code>","text":"<p>Call Photoshop's AI powered \"Generative Fill\" on the current selection.</p> Source code in <code>src/helpers/design.py</code> <pre><code>def generative_fill() -&gt; None:\n    \"\"\"Call Photoshop's AI powered \"Generative Fill\" on the current selection.\"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    desc2 = ActionDescriptor()\n    desc3 = ActionDescriptor()\n    ref1.putEnumerated(sID(\"document\"), sID(\"ordinal\"), sID(\"targetEnum\"))\n    desc1.putReference(sID(\"target\"), ref1)\n    desc1.putString(sID(\"prompt\"), \"\"\"\"\"\")\n    desc1.putString(sID(\"serviceID\"), \"\"\"clio\"\"\")\n    desc1.putEnumerated(sID(\"mode\"), sID(\"syntheticFillMode\"), sID(\"inpaint\"))\n    desc3.putString(sID(\"gi_PROMPT\"), \"\"\"\"\"\")\n    desc3.putString(sID(\"gi_MODE\"), \"\"\"ginp\"\"\")\n    desc3.putInteger(sID(\"gi_SEED\"), -1)\n    desc3.putInteger(sID(\"gi_NUM_STEPS\"), -1)\n    desc3.putInteger(sID(\"gi_GUIDANCE\"), 6)\n    desc3.putInteger(sID(\"gi_SIMILARITY\"), 0)\n    desc3.putBoolean(sID(\"gi_CROP\"), False)\n    desc3.putBoolean(sID(\"gi_DILATE\"), False)\n    desc3.putInteger(sID(\"gi_CONTENT_PRESERVE\"), 0)\n    desc3.putBoolean(sID(\"gi_ENABLE_PROMPT_FILTER\"), True)\n    desc2.putObject(sID(\"clio\"), sID(\"clio\"), desc3)\n    desc1.putObject(sID(\"serviceOptionsList\"), sID(\"target\"), desc2)\n    app.executeaction(sID(\"syntheticFill\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/design/#src.helpers.design.generative_fill_edges","title":"<code>generative_fill_edges(layer=None)</code>","text":"<p>Rasterizes a given layer (or active layer) and fills remaining pixels using AI powered generative fill. @param layer: Layer to use for the generative fill. Uses active if not provided.</p> Source code in <code>src/helpers/design.py</code> <pre><code>def generative_fill_edges(layer: Optional[ArtLayer] = None) -&gt; None:\n    \"\"\"\n    Rasterizes a given layer (or active layer) and fills remaining pixels using AI powered generative fill.\n    @param layer: Layer to use for the generative fill. Uses active if not provided.\n    \"\"\"\n    # Set active layer if needed, then rasterize\n    docref: Document = app.activeDocument\n    if layer:\n        docref.activeLayer = layer\n    else:\n        layer = docref.activeLayer\n    docref.activeLayer.rasterize(RasterizeType.EntireLayer)\n\n    # Create a fill layer the size of the document\n    fill_layer: ArtLayer = docref.artLayers.add()\n    fill_layer.move(layer, ElementPlacement.PlaceAfter)\n    fill_layer_primary()\n    fill_layer.opacity = 0\n    select_layers([layer, fill_layer])\n    smart = smart_layer()\n    edit_smart_layer(smart)\n\n    # Select pixels of active layer and invert\n    docref = app.activeDocument\n    select_layer_pixels(docref.activeLayer)\n    selection = docref.selection\n    selection.invert()\n\n    # Guard against no selection made\n    try:\n        _ = selection.bounds\n    except PS_EXCEPTIONS:\n        return\n\n    # Expand and smooth selection\n    selection.expand(8)\n    selection.smooth(4)\n\n    # Call Generative fill\n    generative_fill()\n    selection.deselect()\n    docref.close(SaveOptions.SaveChanges)\n</code></pre>"},{"location":"helpers/design/#src.helpers.design.repair_edges","title":"<code>repair_edges(edge=6)</code>","text":"<p>Select a small area at the edges of an image and content aware fill to repair upscale damage. @param edge: How many pixels to select at the edge.</p> Source code in <code>src/helpers/design.py</code> <pre><code>def repair_edges(edge: int = 6) -&gt; None:\n    \"\"\"\n    Select a small area at the edges of an image and content aware fill to repair upscale damage.\n    @param edge: How many pixels to select at the edge.\n    \"\"\"\n    # Select all\n    desc632724 = ActionDescriptor()\n    ref489 = ActionReference()\n    ref489.putProperty(sID(\"channel\"), sID(\"selection\"))\n    desc632724.putReference(sID(\"target\"), ref489)\n    desc632724.putEnumerated(sID(\"to\"), sID(\"ordinal\"), sID(\"allEnum\"))\n    app.ExecuteAction(sID(\"set\"), desc632724, NO_DIALOG)\n\n    # Contract selection\n    contract = ActionDescriptor()\n    contract.putUnitDouble(sID(\"by\"), sID(\"pixelsUnit\"), edge)\n    contract.putBoolean(sID(\"selectionModifyEffectAtCanvasBounds\"), True)\n    app.ExecuteAction(sID(\"contract\"), contract, NO_DIALOG)\n\n    # Inverse the selection\n    app.ExecuteAction(sID(\"inverse\"), None, NO_DIALOG)\n\n    # Content aware fill\n    desc_caf = ActionDescriptor()\n    desc_caf.putEnumerated(\n        sID(\"cafSamplingRegion\"),\n        sID(\"cafSamplingRegion\"),\n        sID(\"cafSamplingRegionRectangular\")\n    )\n    desc_caf.putBoolean(sID(\"cafSampleAllLayers\"), False)\n    desc_caf.putEnumerated(\n        sID(\"cafColorAdaptationLevel\"),\n        sID(\"cafColorAdaptationLevel\"),\n        sID(\"cafColorAdaptationDefault\")\n    )\n    desc_caf.putEnumerated(\n        sID(\"cafRotationAmount\"),\n        sID(\"cafRotationAmount\"),\n        sID(\"cafRotationAmountNone\")\n    )\n    desc_caf.putBoolean(sID(\"cafScale\"), False)\n    desc_caf.putBoolean(sID(\"cafMirror\"), False)\n    desc_caf.putEnumerated(\n        sID(\"cafOutput\"),\n        sID(\"cafOutput\"),\n        sID(\"cafOutputToNewLayer\")\n    )\n    app.ExecuteAction(sID(\"cafWorkspace\"), desc_caf, NO_DIALOG)\n\n    # Deselect\n    app.activeDocument.selection.deselect()\n</code></pre>"},{"location":"helpers/document/","title":"Document","text":"<p>DOCUMENT HELPERS</p>"},{"location":"helpers/document/#src.helpers.document.NO_DIALOG","title":"<code>NO_DIALOG = DialogModes.DisplayNoDialogs</code>  <code>module-attribute</code>","text":"<p>DOCUMENT HIERARCHY</p>"},{"location":"helpers/document/#src.helpers.document.check_active_document","title":"<code>check_active_document()</code>","text":"<p>Checks if there are any active documents loaded in Photoshop. @return: True if exists, otherwise False.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def check_active_document() -&gt; bool:\n    \"\"\"\n    Checks if there are any active documents loaded in Photoshop.\n    @return: True if exists, otherwise False.\n    \"\"\"\n    try:\n        if app.documents.length &gt; 0:\n            return True\n    except PS_EXCEPTIONS:\n        pass\n    return False\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.close_document","title":"<code>close_document()</code>","text":"<p>Close the active document.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def close_document() -&gt; None:\n    \"\"\"Close the active document.\"\"\"\n    app.activeDocument.close(SaveOptions.DoNotSaveChanges)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.get_document","title":"<code>get_document(name)</code>","text":"<p>Check if a Photoshop Document has been loaded. @param name: Filename of the document. @return: The Document if located, None if missing.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def get_document(name: str) -&gt; Optional[Document]:\n    \"\"\"\n    Check if a Photoshop Document has been loaded.\n    @param name: Filename of the document.\n    @return: The Document if located, None if missing.\n    \"\"\"\n    try:\n        if app.documents.length &lt; 1:\n            return\n        doc = app.documents.getByName(name)\n        app.activeDocument = doc\n        return doc\n    except PS_EXCEPTIONS:\n        return\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.get_layer_tree","title":"<code>get_layer_tree(group=None)</code>","text":"<p>Composes a dictionary tree of layers in the active document or a specific LayerSet. @param: A specific group to create a dictionary tree for. @return: A dictionary tree comprised of all the layers in a document or group.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def get_layer_tree(group: Optional[LayerSet] = None) -&gt; dict[str, Union[ArtLayer, dict[str, ArtLayer]]]:\n    \"\"\"\n    Composes a dictionary tree of layers in the active document or a specific LayerSet.\n    @param: A specific group to create a dictionary tree for.\n    @return: A dictionary tree comprised of all the layers in a document or group.\n    \"\"\"\n    if not group:\n        group = app.activeDocument\n    layers = {layer.name: layer for layer in group.artLayers}\n    for g in group.layerSets:\n        layers[g.name] = get_layer_tree(g)\n    return layers\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.get_leaf_layers","title":"<code>get_leaf_layers(group=None)</code>","text":"<p>Utility function to generate a list of leaf layers in a LayerSet or document. @param group: Group to grab leaf layers from. @return: A list of leaf layers in a LayerSet or document.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def get_leaf_layers(group: Optional[LayerSet] = None) -&gt; list[ArtLayer]:\n    \"\"\"\n    Utility function to generate a list of leaf layers in a LayerSet or document.\n    @param group: Group to grab leaf layers from.\n    @return: A list of leaf layers in a LayerSet or document.\n    \"\"\"\n    if not group:\n        group = app.activeDocument\n    layers = [node for node in group.artLayers]\n    for g in group.layerSets:\n        layers.extend(get_leaf_layers(g))\n    return layers\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.import_art","title":"<code>import_art(layer, file, name='Layer 1')</code>","text":"<p>Imports an art file into the active layer. @param layer: Layer to make active and receive image. @param file: Image file to import. @param name: Name of the new layer.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def import_art(layer: ArtLayer, file: Union[str, Path], name: str = \"Layer 1\") -&gt; ArtLayer:\n    \"\"\"\n    Imports an art file into the active layer.\n    @param layer: Layer to make active and receive image.\n    @param file: Image file to import.\n    @param name: Name of the new layer.\n    \"\"\"\n    desc = ActionDescriptor()\n    app.activeDocument.activeLayer = layer\n    desc.putPath(sID(\"target\"), str(file))\n    app.executeAction(sID(\"placeEvent\"), desc)\n    app.activeDocument.activeLayer.name = name\n    return app.activeDocument.activeLayer\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.import_art_into_new_layer","title":"<code>import_art_into_new_layer(file, name='New Layer')</code>","text":"<p>Creates a new layer and imports a given art into that layer. @param file: Image file to import, must have a valid image extension. @param name: Chosen name of the new layer.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def import_art_into_new_layer(file: str, name: str = \"New Layer\") -&gt; ArtLayer:\n    \"\"\"\n    Creates a new layer and imports a given art into that layer.\n    @param file: Image file to import, must have a valid image extension.\n    @param name: Chosen name of the new layer.\n    \"\"\"\n    return import_art(create_new_layer(name), file, name)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.import_svg","title":"<code>import_svg(file, ref=None, placement=None)</code>","text":"<p>Imports an SVG image, then moves it if needed. @param file: SVG file to import. @param ref: Reference used to move layer. @param placement: Placement based on the reference. @return: New layer containing SVG.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def import_svg(\n    file: Union[str, os.PathLike],\n    ref: Union[ArtLayer, LayerSet] = None,\n    placement: Optional[ElementPlacement] = None\n) -&gt; ArtLayer:\n    \"\"\"\n    Imports an SVG image, then moves it if needed.\n    @param file: SVG file to import.\n    @param ref: Reference used to move layer.\n    @param placement: Placement based on the reference.\n    @return: New layer containing SVG.\n    \"\"\"\n    # Import the art\n    desc = ActionDescriptor()\n    desc.putPath(sID(\"target\"), str(file))\n    app.executeAction(sID(\"placeEvent\"), desc)\n\n    # Position the layer if needed\n    if ref and placement:\n        app.activeDocument.activeLayer.move(ref, placement)\n    return app.activeDocument.activeLayer\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.jump_to_history_state","title":"<code>jump_to_history_state(position)</code>","text":"<p>Jump to a position in the history state relative to its current position. 2 moves forward two, -2 moves backwards two. @param position: Integer value determining how far ahead or behind in the state to move.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def jump_to_history_state(position: int):\n    \"\"\"\n    Jump to a position in the history state relative to its current position.\n    2 moves forward two, -2 moves backwards two.\n    @param position: Integer value determining how far ahead or behind in the state to move.\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.PutOffset(sID(\"historyState\"),  position)\n    desc1.PutReference(sID(\"target\"),  ref1)\n    app.Executeaction(sID(\"select\"), desc1,  NO_DIALOG)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.paste_file","title":"<code>paste_file(layer, file, action=None, action_args=None)</code>","text":"<p>Pastes the given file into the specified layer. @param layer: Layer object to paste the image into. @param file: Filepath of the image to open. @param action: Optional action function to call on the image before importing it. @param action_args: Optional arguments to pass to the action function</p> Source code in <code>src/helpers/document.py</code> <pre><code>def paste_file(\n    layer: ArtLayer,\n    file: Union[str, os.PathLike],\n    action: any = None,\n    action_args: dict = None\n) -&gt; None:\n    \"\"\"\n    Pastes the given file into the specified layer.\n    @param layer: Layer object to paste the image into.\n    @param file: Filepath of the image to open.\n    @param action: Optional action function to call on the image before importing it.\n    @param action_args: Optional arguments to pass to the action function\n    \"\"\"\n    # Select the correct layer, then load the file\n    app.activeDocument.activeLayer = layer\n    app.load(str(file))\n\n    # Optionally run action on art before importing it\n    if action:\n        action(**action_args) if action_args else action()\n\n    # Select the entire image, copy it, and close the file\n    app.activeDocument.selection.selectAll()\n    app.activeDocument.selection.copy()\n    app.activeDocument.close(SaveOptions.DoNotSaveChanges)\n\n    # Paste the image into the specific layer\n    app.activeDocument.paste()\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.pixels_to_points","title":"<code>pixels_to_points(number)</code>","text":"<p>Converts a given number in pixel units to point units. @param number: Number represented in pixel units. @return: Float representing the given value in point units.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def pixels_to_points(number: Union[int, float]) -&gt; float:\n    \"\"\"\n    Converts a given number in pixel units to point units.\n    @param number: Number represented in pixel units.\n    @return: Float representing the given value in point units.\n    \"\"\"\n    return number / (app.activeDocument.resolution / 72)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.points_to_pixels","title":"<code>points_to_pixels(number)</code>","text":"<p>Converts a given number in point units to pixel units. @param number: Number represented in point units. @return: Float representing the given value in pixel units.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def points_to_pixels(number: Union[int, float]) -&gt; float:\n    \"\"\"\n    Converts a given number in point units to pixel units.\n    @param number: Number represented in point units.\n    @return: Float representing the given value in pixel units.\n    \"\"\"\n    return (app.activeDocument.resolution / 72) * number\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.redo_action","title":"<code>redo_action()</code>","text":"<p>Redo the last action undone in the history state.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def redo_action() -&gt; None:\n    \"\"\"\n    Redo the last action undone in the history state.\n    \"\"\"\n    toggle_history_state(\"next\")\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.reset_document","title":"<code>reset_document()</code>","text":"<p>Reset to the history state to when document was first opened.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def reset_document() -&gt; None:\n    \"\"\"\n    Reset to the history state to when document was first opened.\n    \"\"\"\n    idslct = cID(\"slct\")\n    desc9 = ActionDescriptor()\n    idnull = sID(\"target\")\n    ref1 = ActionReference()\n    idSnpS = cID(\"SnpS\")\n    ref1.putName(idSnpS, app.activeDocument.name)\n    desc9.putReference(idnull, ref1)\n    app.executeAction(idslct, desc9, NO_DIALOG)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.rotate_clockwise","title":"<code>rotate_clockwise()</code>","text":"<p>Utility definition for rotating 90 degrees clockwise.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def rotate_clockwise() -&gt; None:\n    \"\"\"Utility definition for rotating 90 degrees clockwise.\"\"\"\n    rotate_document(90)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.rotate_counter_clockwise","title":"<code>rotate_counter_clockwise()</code>","text":"<p>Utility definition for rotating 90 degrees counter-clockwise.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def rotate_counter_clockwise() -&gt; None:\n    \"\"\"Utility definition for rotating 90 degrees counter-clockwise.\"\"\"\n    rotate_document(-90)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.rotate_document","title":"<code>rotate_document(angle)</code>","text":"<p>Rotate the document. @param angle: Angle to rotate the document.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def rotate_document(angle: int) -&gt; None:\n    \"\"\"\n    Rotate the document.\n    @param angle: Angle to rotate the document.\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.PutEnumerated(sID(\"document\"), sID(\"ordinal\"), sID(\"first\"))\n    desc1.PutReference(sID(\"target\"), ref1)\n    desc1.PutUnitDouble(sID(\"angle\"), sID(\"angleUnit\"), angle)\n    app.Executeaction(sID(\"rotateEventEnum\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.rotate_full","title":"<code>rotate_full()</code>","text":"<p>Utility definition for rotating a full 180 degrees.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def rotate_full() -&gt; None:\n    \"\"\"Utility definition for rotating a full 180 degrees.\"\"\"\n    rotate_document(180)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.save_document_jpeg","title":"<code>save_document_jpeg(path, optimize=True)</code>","text":"<p>Save the current document as a JPEG. @param path: Path to save the JPEG file. @param optimize: Whether to save with \"Optimize Baseline\". Reduces file size, but may cause an error on older versions of Photoshop.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def save_document_jpeg(path: Path, optimize: bool = True) -&gt; None:\n    \"\"\"\n    Save the current document as a JPEG.\n    @param path: Path to save the JPEG file.\n    @param optimize: Whether to save with \"Optimize Baseline\". Reduces file size, but\n    may cause an error on older versions of Photoshop.\n    \"\"\"\n    try:\n        jpeg_options = JPEGSaveOptions(quality=12)\n        if optimize:\n            # Reduces filesize, might cause an error on older Photoshop versions\n            jpeg_options.formatOptions = FormatOptionsType.OptimizedBaseline\n        app.activeDocument.saveAs(\n            file_path=str(path.with_suffix('.jpg')),\n            options=jpeg_options,\n            asCopy=True)\n    except PS_EXCEPTIONS as e:\n        # Retry without Optimize Baseline\n        if optimize:\n            return save_document_jpeg(path, False)\n        raise OSError from e\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.save_document_png","title":"<code>save_document_png(path)</code>","text":"<p>Save the current document as a PNG. @param path: Path to save the PNG file.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def save_document_png(path: Path) -&gt; None:\n    \"\"\"\n    Save the current document as a PNG.\n    @param path: Path to save the PNG file.\n    \"\"\"\n    png_options = PNGSaveOptions()\n    png_options.compression = 3\n    png_options.interlaced = False\n    app.activeDocument.saveAs(\n        file_path=str(path.with_suffix('.png')),\n        options=png_options,\n        asCopy=True)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.save_document_psb","title":"<code>save_document_psb(path)</code>","text":"<p>Save the current document as a PSB. @param path: Path to save the PSB file.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def save_document_psb(path: Path) -&gt; None:\n    \"\"\"\n    Save the current document as a PSB.\n    @param path: Path to save the PSB file.\n    \"\"\"\n    d1 = ActionDescriptor()\n    d2 = ActionDescriptor()\n    d2.putBoolean(sID('maximizeCompatibility'), True)\n    d1.putObject(sID('as'), sID('largeDocumentFormat'), d2)\n    d1.putPath(sID('in'), str(path.with_suffix('.psb')))\n    d1.putBoolean(sID('lowerCase'), True)\n    app.executeAction(sID('save'), d1, DialogModes.DisplayNoDialogs)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.save_document_psd","title":"<code>save_document_psd(path)</code>","text":"<p>Save the current document as a PSD. @param path: Path to save the PSD file.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def save_document_psd(path: Path) -&gt; None:\n    \"\"\"\n    Save the current document as a PSD.\n    @param path: Path to save the PSD file.\n    \"\"\"\n    app.activeDocument.saveAs(\n        file_path=str(path.with_suffix('.psd')),\n        options=PhotoshopSaveOptions(),\n        asCopy=True\n    )\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.toggle_history_state","title":"<code>toggle_history_state(direction='previous')</code>","text":"<p>Alter the history state. @param direction: Direction to move the history state (\"previous\" or \"next\").</p> Source code in <code>src/helpers/document.py</code> <pre><code>def toggle_history_state(direction: str = \"previous\") -&gt; None:\n    \"\"\"\n    Alter the history state.\n    @param direction: Direction to move the history state (\"previous\" or \"next\").\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.PutEnumerated(sID(\"historyState\"), sID(\"ordinal\"), sID(direction))\n    desc1.PutReference(sID(\"target\"), ref1)\n    app.Executeaction(sID(\"select\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.trim_transparent_pixels","title":"<code>trim_transparent_pixels()</code>","text":"<p>Trim transparent pixels from Photoshop document.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def trim_transparent_pixels() -&gt; None:\n    \"\"\"\n    Trim transparent pixels from Photoshop document.\n    \"\"\"\n    desc258 = ActionDescriptor()\n    desc258.putEnumerated(sID(\"trimBasedOn\"), sID(\"trimBasedOn\"), sID(\"transparency\"))\n    desc258.putBoolean(sID(\"top\"), True)\n    desc258.putBoolean(sID(\"bottom\"), True)\n    desc258.putBoolean(sID(\"left\"), True)\n    desc258.putBoolean(sID(\"right\"), True)\n    app.ExecuteAction(sID(\"trim\"), desc258, NO_DIALOG)\n</code></pre>"},{"location":"helpers/document/#src.helpers.document.undo_action","title":"<code>undo_action()</code>","text":"<p>Undo the last action in the history state.</p> Source code in <code>src/helpers/document.py</code> <pre><code>def undo_action() -&gt; None:\n    \"\"\"\n    Undo the last action in the history state.\n    \"\"\"\n    toggle_history_state(\"previous\")\n</code></pre>"},{"location":"helpers/effects/","title":"Effects","text":"<p>LAYER EFFECTS HELPERS</p>"},{"location":"helpers/effects/#src.helpers.effects.NO_DIALOG","title":"<code>NO_DIALOG = DialogModes.DisplayNoDialogs</code>  <code>module-attribute</code>","text":"<p>BLENDING EFFECTS UTILITIES</p>"},{"location":"helpers/effects/#src.helpers.effects.apply_fx","title":"<code>apply_fx(layer, effects)</code>","text":"<p>Apply multiple layer effects to a layer. @param layer: Layer or Layer Set object. @param effects: List of effects to apply.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def apply_fx(layer: Union[ArtLayer, LayerSet], effects: list[LayerEffects]) -&gt; None:\n    \"\"\"\n    Apply multiple layer effects to a layer.\n    @param layer: Layer or Layer Set object.\n    @param effects: List of effects to apply.\n    \"\"\"\n    # Set up the main action\n    app.activeDocument.activeLayer = layer\n    main_action = ActionDescriptor()\n    fx_action = ActionDescriptor()\n    main_ref = ActionReference()\n    main_ref.putProperty(sID(\"property\"), sID(\"layerEffects\"))\n    main_ref.putEnumerated(sID(\"layer\"), sID(\"ordinal\"), sID(\"targetEnum\"))\n    main_action.putReference(sID(\"target\"), main_ref)\n\n    # Add each action from fx dictionary\n    for fx in effects:\n        if fx['type'] == 'stroke':\n            apply_fx_stroke(fx_action, fx)\n        elif fx['type'] == 'drop-shadow':\n            apply_fx_drop_shadow(fx_action, fx)\n        elif fx['type'] == 'gradient-overlay':\n            apply_fx_gradient_overlay(fx_action, fx)\n        elif fx['type'] == 'color-overlay':\n            apply_fx_color_overlay(fx_action, fx)\n        elif fx['type'] == 'bevel':\n            apply_fx_bevel(fx_action, fx)\n\n    # Apply all fx actions\n    main_action.putObject(sID(\"to\"), sID(\"layerEffects\"), fx_action)\n    app.ExecuteAction(sID(\"set\"), main_action, DialogModes.DisplayNoDialogs)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.apply_fx_bevel","title":"<code>apply_fx_bevel(action, fx)</code>","text":"<p>Adds a bevel to layer effects action. @param action: Pending layer effects action descriptor. @param fx: Bevel effect properties.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def apply_fx_bevel(action: ActionDescriptor, fx: EffectBevel) -&gt; None:\n    \"\"\"\n    Adds a bevel to layer effects action.\n    @param action: Pending layer effects action descriptor.\n    @param fx: Bevel effect properties.\n    \"\"\"\n    d1 = ActionDescriptor()\n    d2 = ActionDescriptor()\n    d1.PutEnumerated(sID(\"highlightMode\"), sID(\"blendMode\"), sID(\"screen\"))\n    apply_color(d1, fx.get('highlight_color', [255, 255, 255]), 'highlightColor')\n    d1.PutUnitDouble(sID(\"highlightOpacity\"), sID(\"percentUnit\"),  fx.get('highlight_opacity', 70))\n    d1.PutEnumerated(sID(\"shadowMode\"), sID(\"blendMode\"), sID(\"multiply\"))\n    apply_color(d1, fx.get('shadow_color', [0, 0, 0]), 'shadowColor')\n    d1.PutUnitDouble(sID(\"shadowOpacity\"), sID(\"percentUnit\"),  fx.get('shadow_opacity', 72))\n    d1.PutEnumerated(sID(\"bevelTechnique\"), sID(\"bevelTechnique\"), sID(\"softMatte\"))\n    d1.PutEnumerated(sID(\"bevelStyle\"), sID(\"bevelEmbossStyle\"), sID(\"outerBevel\"))\n    d1.PutBoolean(sID(\"useGlobalAngle\"), False)\n    d1.PutUnitDouble(sID(\"localLightingAngle\"), sID(\"angleUnit\"),  fx.get('rotation', 45))\n    d1.PutUnitDouble(sID(\"localLightingAltitude\"), sID(\"angleUnit\"),  fx.get('altitude', 22))\n    d1.PutUnitDouble(sID(\"strengthRatio\"), sID(\"percentUnit\"),  fx.get('depth', 100))\n    d1.PutUnitDouble(sID(\"blur\"), sID(\"pixelsUnit\"),  fx.get('size', 30))\n    d1.PutEnumerated(sID(\"bevelDirection\"), sID(\"bevelEmbossStampStyle\"), sID(\"in\"))\n    d1.PutObject(sID(\"transferSpec\"), sID(\"shapeCurveType\"),  d2)\n    d1.PutBoolean(sID(\"antialiasGloss\"), False)\n    d1.PutUnitDouble(sID(\"softness\"), sID(\"pixelsUnit\"),  fx.get('softness', 14))\n    d1.PutBoolean(sID(\"useShape\"), False)\n    d1.PutBoolean(sID(\"useTexture\"), False)\n    action.PutObject(sID(\"bevelEmboss\"), sID(\"bevelEmboss\"),  d1)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.apply_fx_color_overlay","title":"<code>apply_fx_color_overlay(action, fx)</code>","text":"<p>Adds a solid color overlay to layer effects action. @param action: Pending layer effects action descriptor. @param fx: Color Overlay effect properties.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def apply_fx_color_overlay(action: ActionDescriptor, fx: EffectColorOverlay) -&gt; None:\n    \"\"\"\n    Adds a solid color overlay to layer effects action.\n    @param action: Pending layer effects action descriptor.\n    @param fx: Color Overlay effect properties.\n    \"\"\"\n    d = ActionDescriptor()\n    d.PutEnumerated(sID(\"mode\"), sID(\"blendMode\"), sID(\"normal\"))\n    apply_color(d, fx.get('color', rgb_black()))\n    d.PutUnitDouble(sID(\"opacity\"), sID(\"percentUnit\"), 100.000000)\n    action.PutObject(sID(\"solidFill\"), sID(\"solidFill\"), d)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.apply_fx_drop_shadow","title":"<code>apply_fx_drop_shadow(action, fx)</code>","text":"<p>Adds drop shadow effect to layer effects action. @param action: Pending layer effects action descriptor. @param fx: Drop Shadow effect properties.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def apply_fx_drop_shadow(action: ActionDescriptor, fx: EffectDropShadow) -&gt; None:\n    \"\"\"\n    Adds drop shadow effect to layer effects action.\n    @param action: Pending layer effects action descriptor.\n    @param fx: Drop Shadow effect properties.\n    \"\"\"\n    d1 = ActionDescriptor()\n    d2 = ActionDescriptor()\n    d1.putEnumerated(sID(\"mode\"), sID(\"blendMode\"), sID(\"multiply\"))\n    apply_color(d1, [0, 0, 0])\n    d1.putUnitDouble(sID(\"opacity\"), sID(\"percentUnit\"), float(fx.get('opacity', 100.000000)))\n    d1.putBoolean(sID(\"useGlobalAngle\"), False)\n    d1.putUnitDouble(sID(\"localLightingAngle\"), sID(\"angleUnit\"), float(fx.get('rotation', 45.000000)))\n    d1.putUnitDouble(sID(\"distance\"), sID(\"pixelsUnit\"), float(fx.get('distance', 10.000000)))\n    d1.putUnitDouble(sID(\"chokeMatte\"), sID(\"pixelsUnit\"), float(fx.get('spread', 0.000000)))\n    d1.putUnitDouble(sID(\"blur\"), sID(\"pixelsUnit\"), float(fx.get('size', 0.000000)))\n    d1.putUnitDouble(sID(\"noise\"), sID(\"percentUnit\"), float(fx.get('noise', 0.000000)))\n    d1.putBoolean(sID(\"antiAlias\"), False)\n    d2.putString(sID(\"name\"), \"Linear\")\n    d1.putObject(sID(\"transferSpec\"), sID(\"shapeCurveType\"), d2)\n    d1.putBoolean(sID(\"layerConceals\"), True)\n    action.putObject(sID(\"dropShadow\"), sID(\"dropShadow\"), d1)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.apply_fx_gradient_overlay","title":"<code>apply_fx_gradient_overlay(action, fx)</code>","text":"<p>Adds gradient effect to layer effects action. @param action: Pending layer effects action descriptor. @param fx: Gradient Overlay effect properties.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def apply_fx_gradient_overlay(action: ActionDescriptor, fx: EffectGradientOverlay) -&gt; None:\n    \"\"\"\n    Adds gradient effect to layer effects action.\n    @param action: Pending layer effects action descriptor.\n    @param fx: Gradient Overlay effect properties.\n    \"\"\"\n    d1 = ActionDescriptor()\n    d2 = ActionDescriptor()\n    d3 = ActionDescriptor()\n    d4 = ActionDescriptor()\n    d5 = ActionDescriptor()\n    color_list = ActionList()\n    transparency_list = ActionList()\n    d1.putEnumerated(sID(\"mode\"), sID(\"blendMode\"), sID(\"normal\"))\n    d1.putUnitDouble(sID(\"opacity\"), sID(\"percentUnit\"),  int(fx.get('opacity', 100)))\n    d2.putEnumerated(sID(\"gradientForm\"), sID(\"gradientForm\"), sID(\"customStops\"))\n    d2.putDouble(sID(\"interfaceIconFrameDimmed\"),  int(fx.get('size', 4096)))\n    for c in fx.get('colors', []):\n        add_color_to_gradient(\n            color_list,\n            get_color(c.get('color', [0, 0, 0])),\n            int(c.get('location', 0)),\n            int(c.get('midpoint', 50))\n        )\n    d2.putList(sID(\"colors\"),  color_list)\n    d3.putUnitDouble(sID(\"opacity\"), sID(\"percentUnit\"),  100)\n    d3.putInteger(sID(\"location\"),  0)\n    d3.putInteger(sID(\"midpoint\"),  50)\n    transparency_list.putObject(sID(\"transferSpec\"),  d3)\n    d4.putUnitDouble(sID(\"opacity\"), sID(\"percentUnit\"),  100)\n    d4.putInteger(sID(\"location\"),  int(fx.get('size', 4096)))\n    d4.putInteger(sID(\"midpoint\"),  50)\n    transparency_list.putObject(sID(\"transferSpec\"),  d4)\n    d2.putList(sID(\"transparency\"),  transparency_list)\n    d1.putObject(sID(\"gradient\"), sID(\"gradientClassEvent\"),  d2)\n    d1.putUnitDouble(sID(\"angle\"), sID(\"angleUnit\"), int(fx.get('rotation', 45)))\n    d1.putEnumerated(sID(\"type\"), sID(\"gradientType\"), sID(\"linear\"))\n    d1.putBoolean(sID(\"reverse\"), False)\n    d1.putBoolean(sID(\"dither\"), False)\n    d1.putEnumerated(cID(\"gs99\"), sID(\"gradientInterpolationMethodType\"), sID(\"classic\"))\n    d1.putBoolean(sID(\"align\"), True)\n    d1.putUnitDouble(sID(\"scale\"), sID(\"percentUnit\"), int(fx.get('scale', 70)))\n    d5.putUnitDouble(sID(\"horizontal\"), sID(\"percentUnit\"),  0)\n    d5.putUnitDouble(sID(\"vertical\"), sID(\"percentUnit\"),  0)\n    d1.putObject(sID(\"offset\"), sID(\"paint\"),  d5)\n    action.putObject(sID(\"gradientFill\"), sID(\"gradientFill\"),  d1)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.apply_fx_stroke","title":"<code>apply_fx_stroke(action, fx)</code>","text":"<p>Adds stroke effect to layer effects action. @param action: Pending layer effects action descriptor. @param fx: Stroke effect properties.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def apply_fx_stroke(action: ActionDescriptor, fx: EffectStroke) -&gt; None:\n    \"\"\"\n    Adds stroke effect to layer effects action.\n    @param action: Pending layer effects action descriptor.\n    @param fx: Stroke effect properties.\n    \"\"\"\n    d = ActionDescriptor()\n    d.putEnumerated(sID(\"style\"), sID(\"frameStyle\"), Stroke.position(fx.get('style', 'out')))\n    d.putEnumerated(sID(\"paintType\"), sID(\"frameFill\"), sID(\"solidColor\"))\n    d.putEnumerated(sID(\"mode\"), sID(\"blendMode\"), sID(\"normal\"))\n    d.putUnitDouble(sID(\"opacity\"), sID(\"percentUnit\"), int(fx.get('opacity', 100)))\n    d.putUnitDouble(sID(\"size\"), sID(\"pixelsUnit\"), int(fx.get('weight', 6)))\n    apply_color(d, get_color(fx.get('color', [0, 0, 0])))\n    d.putBoolean(sID(\"overprint\"), False)\n    action.putObject(sID(\"frameFX\"), sID(\"frameFX\"), d)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.clear_layer_fx","title":"<code>clear_layer_fx(layer)</code>","text":"<p>Removes all layer style effects. @param layer: Layer object</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def clear_layer_fx(layer: Union[ArtLayer, LayerSet, None]) -&gt; None:\n    \"\"\"\n    Removes all layer style effects.\n    @param layer: Layer object\n    \"\"\"\n    if layer:\n        app.activeDocument.activeLayer = layer\n    try:\n        desc1600 = ActionDescriptor()\n        ref126 = ActionReference()\n        ref126.putEnumerated(sID(\"layer\"), sID(\"ordinal\"), sID(\"targetEnum\"))\n        desc1600.putReference(sID(\"target\"), ref126)\n        app.ExecuteAction(sID(\"disableLayerStyle\"), desc1600, NO_DIALOG)\n    except Exception as e:\n        print(e, f'\\nLayer \"{layer.name}\" has no effects!')\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.copy_layer_fx","title":"<code>copy_layer_fx(from_layer, to_layer)</code>","text":"<p>Copies the layer effects from one layer to another layer. @param from_layer: Layer to copy effects from. @param to_layer: Layer to apply effects to.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def copy_layer_fx(from_layer: Union[ArtLayer, LayerSet], to_layer: Union[ArtLayer, LayerSet]) -&gt; None:\n    \"\"\"\n    Copies the layer effects from one layer to another layer.\n    @param from_layer: Layer to copy effects from.\n    @param to_layer: Layer to apply effects to.\n    \"\"\"\n    # Get layer effects from source layer\n    desc_get = ActionDescriptor()\n    ref_get = ActionReference()\n    ref_get.putIdentifier(sID(\"layer\"), from_layer.id)\n    desc_get.putReference(sID(\"null\"), ref_get)\n    desc_get.putEnumerated(sID(\"class\"), sID(\"class\"), sID(\"layerEffects\"))\n    result_desc = app.executeAction(sID(\"get\"), desc_get, NO_DIALOG)\n\n    # Apply layer effects to target layer\n    desc_set = ActionDescriptor()\n    ref_set = ActionReference()\n    ref_set.putIdentifier(sID(\"layer\"), to_layer.id)\n    desc_set.putReference(sID(\"null\"), ref_set)\n    desc_set.putObject(sID(\"to\"), sID(\"layerEffects\"), result_desc.getObjectValue(sID(\"layerEffects\")))\n    app.executeAction(sID(\"set\"), desc_set, NO_DIALOG)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.disable_layer_fx","title":"<code>disable_layer_fx(layer=None)</code>","text":"<p>Passthrough function for <code>change_fx_visibility</code> to disable effects on layer. @param layer: ArtLayer or LayerSet, will use active if not provided.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def disable_layer_fx(layer: Optional[Union[ArtLayer, LayerSet]] = None) -&gt; None:\n    \"\"\"\n    Passthrough function for `change_fx_visibility` to disable effects on layer.\n    @param layer: ArtLayer or LayerSet, will use active if not provided.\n    \"\"\"\n    set_layer_fx_visibility(layer, False)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.enable_layer_fx","title":"<code>enable_layer_fx(layer=None)</code>","text":"<p>Passthrough function for <code>change_fx_visibility</code> to enable effects on layer. @param layer: ArtLayer or LayerSet, will use active if not provided.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def enable_layer_fx(layer: Optional[Union[ArtLayer, LayerSet]] = None) -&gt; None:\n    \"\"\"\n    Passthrough function for `change_fx_visibility` to enable effects on layer.\n    @param layer: ArtLayer or LayerSet, will use active if not provided.\n    \"\"\"\n    set_layer_fx_visibility(layer, True)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.rasterize_layer_fx","title":"<code>rasterize_layer_fx(layer)</code>","text":"<p>Rasterizes a layer including its style. @param layer: Layer object</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def rasterize_layer_fx(layer: ArtLayer) -&gt; None:\n    \"\"\"\n    Rasterizes a layer including its style.\n    @param layer: Layer object\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.putIdentifier(sID(\"layer\"), layer.id)\n    desc1.putReference(sID(\"target\"),  ref1)\n    desc1.putEnumerated(sID(\"what\"), sID(\"rasterizeItem\"), sID(\"layerStyle\"))\n    app.ExecuteAction(sID(\"rasterizeLayer\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.set_fill_opacity","title":"<code>set_fill_opacity(opacity, layer)</code>","text":"<p>Sets the fill opacity of a given layer. @param opacity: Fill opacity to set. @param layer: ArtLayer or LayerSet object.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def set_fill_opacity(opacity: float, layer: Optional[Union[ArtLayer, LayerSet]]) -&gt; None:\n    \"\"\"\n    Sets the fill opacity of a given layer.\n    @param opacity: Fill opacity to set.\n    @param layer: ArtLayer or LayerSet object.\n    \"\"\"\n    # Set the active layer\n    if layer:\n        app.activeDocument.activeLayer = layer\n\n    # Set the layer's fill opacity\n    d = ActionDescriptor()\n    ref = ActionReference()\n    d1 = ActionDescriptor()\n    ref.PutEnumerated(sID(\"layer\"), sID(\"ordinal\"), sID(\"targetEnum\"))\n    d.PutReference(sID(\"target\"),  ref)\n    d1.PutUnitDouble(sID(\"fillOpacity\"), sID(\"percentUnit\"), opacity)\n    d.PutObject(sID(\"to\"), sID(\"layer\"),  d1)\n    app.ExecuteAction(sID(\"set\"), d, NO_DIALOG)\n</code></pre>"},{"location":"helpers/effects/#src.helpers.effects.set_layer_fx_visibility","title":"<code>set_layer_fx_visibility(layer=None, visible=True)</code>","text":"<p>Shows or hides the layer effects on a given layer. @param layer: ArtLayer or LayerSet, use active if not provided. @param visible: Make visible if True, otherwise hide.</p> Source code in <code>src/helpers/effects.py</code> <pre><code>def set_layer_fx_visibility(layer: Optional[Union[ArtLayer, LayerSet]] = None, visible: bool = True) -&gt; None:\n    \"\"\"\n    Shows or hides the layer effects on a given layer.\n    @param layer: ArtLayer or LayerSet, use active if not provided.\n    @param visible: Make visible if True, otherwise hide.\n    \"\"\"\n    # Set the active layer\n    if layer:\n        app.activeDocument.activeLayer = layer\n\n    # Set the layer's FX visibility\n    ref = ActionReference()\n    desc = ActionDescriptor()\n    action_list = ActionList()\n    ref.putClass(sID(\"layerEffects\"))\n    ref.putEnumerated(sID(\"layer\"), sID(\"ordinal\"), sID(\"targetEnum\"))\n    action_list.putReference(ref)\n    desc.putList(sID(\"target\"),  action_list)\n    app.executeAction(sID(\"show\" if visible else \"hide\"), desc, NO_DIALOG)\n</code></pre>"},{"location":"helpers/expansion_symbol/","title":"Expansion Symbol","text":"<p>EXPANSION SYMBOL HELPERS</p>"},{"location":"helpers/expansion_symbol/#src.helpers.expansion_symbol.format_expansion_symbol_dict","title":"<code>format_expansion_symbol_dict(sym, rarity)</code>","text":"<p>Returns a formatted symbol effects dictionary using a dictionary notation from the symbol library. @param sym: Symbol dictionary notation from symbol library. @param rarity: Rarity of the symbol. @return: Formatted layer effects dictionary.</p> Source code in <code>src/helpers/expansion_symbol.py</code> <pre><code>def format_expansion_symbol_dict(sym: dict, rarity: str) -&gt; dict:\n    \"\"\"\n    Returns a formatted symbol effects dictionary using a dictionary notation from the symbol library.\n    @param sym: Symbol dictionary notation from symbol library.\n    @param rarity: Rarity of the symbol.\n    @return: Formatted layer effects dictionary.\n    \"\"\"\n    # Establish initial rarity-neutral values\n    symbol: dict = {\n        'char': sym['char'],\n        'rarity': sym.get('rarity', bool(sym.get('fill') != 'rarity')),\n        'scale': sym['scale'] if isinstance(sym.get('scale'), (int, float)) else 1,\n        'drop-shadow': format_symbol_fx_drop_shadow(sym.get('drop-shadow')) if sym.get('drop-shadow') else None\n    }\n\n    # Non-common attributes\n    if rarity != Rarity.C:\n        # Stroke definition - Optional, must be explicitly disabled\n        symbol['stroke'] = format_symbol_fx_stroke(\n            sym.get('stroke', ['black', cfg.symbol_stroke]), rarity\n        ) if 'stroke' not in sym or sym['stroke'] else None\n\n        # Color definition - Optional\n        symbol['color'] = get_color(sym.get('color')) if sym.get('color') else None\n\n        # Background fill [Default: Disabled]\n        symbol['fill'] = (\n            format_symbol_fx_fill(sym['fill'], rarity) if sym['fill'] != 'rarity' else 'rarity'\n        ) if sym.get('fill') else None\n\n        # Rarity Gradient Overlay [Default: Enabled]\n        if sym.get('rarity', True) or symbol.get('fill') == 'rarity':\n            symbol['gradient'] = format_symbol_fx_gradient(rarity, sym.get('gradient'))\n        return symbol\n\n    # Stroke definition [Default: White]\n    symbol['stroke'] = format_symbol_fx_stroke(sym.get('common-stroke'), rarity) if (\n            sym.get('common-stroke') is not False\n    ) else None\n\n    # Color definition [Default: Black]\n    symbol['color'] = get_color(sym.get('common-color', 'black')) if sym.get('common-color') else None\n\n    # Background fill definition [Default: Disabled]\n    symbol['fill'] = get_color(sym.get('common-fill', 'white')) if sym.get('common-fill') else None\n    return symbol\n</code></pre>"},{"location":"helpers/expansion_symbol/#src.helpers.expansion_symbol.format_symbol_fx_drop_shadow","title":"<code>format_symbol_fx_drop_shadow(fx)</code>","text":"<p>Produces a correct dictionary for layer effects type: drop-shadow. @param fx: The drop shadow definition we were given by the user. @return: Formatted drop shadow definition for this effect.</p> Source code in <code>src/helpers/expansion_symbol.py</code> <pre><code>def format_symbol_fx_drop_shadow(fx: Union[bool, dict]) -&gt; Optional[EffectDropShadow]:\n    \"\"\"\n    Produces a correct dictionary for layer effects type: drop-shadow.\n    @param fx: The drop shadow definition we were given by the user.\n    @return: Formatted drop shadow definition for this effect.\n    \"\"\"\n    # Simple toggle\n    if isinstance(fx, bool) and fx:\n        return {\n            'type': 'drop-shadow',\n            'opacity': 100,\n            'rotation': 45,\n            'distance': 10,\n            'spread': 0,\n            'size': 0,\n        }\n    # Layer effects details notation\n    if isinstance(fx, dict):\n        return {\n            'type': 'drop-shadow',\n            'opacity': int(fx.get('opacity', 100)),\n            'rotation': int(fx.get('rotation', 45)),\n            'distance': int(fx.get('distance', 10)),\n            'spread': int(fx.get('spread', 0)),\n            'size': int(fx.get('size', 0)),\n        }\n    return\n</code></pre>"},{"location":"helpers/expansion_symbol/#src.helpers.expansion_symbol.format_symbol_fx_fill","title":"<code>format_symbol_fx_fill(fx, rarity)</code>","text":"<p>Format background fill effect info. @param fx: Background fill details. @param rarity: Card rarity. @return: Formatted background fill details.</p> Source code in <code>src/helpers/expansion_symbol.py</code> <pre><code>def format_symbol_fx_fill(fx: Union[str, list, dict], rarity: str) -&gt; Optional[SolidColor]:\n    \"\"\"\n    Format background fill effect info.\n    @param fx: Background fill details.\n    @param rarity: Card rarity.\n    @return: Formatted background fill details.\n    \"\"\"\n    # Dict typically provides a color for each rarity\n    if isinstance(fx, dict):\n        # Grab color according to rarity\n        if rarity[0] in fx:\n            return get_color(fx[rarity[0]])\n        # Rarity not found, take the first one\n        return get_color(list(fx.values())[0])\n    # List notation or named color\n    if isinstance(fx, list) or isinstance(fx, str):\n        return get_color(fx)\n    return\n</code></pre>"},{"location":"helpers/expansion_symbol/#src.helpers.expansion_symbol.format_symbol_fx_gradient","title":"<code>format_symbol_fx_gradient(rarity, gradient=None)</code>","text":"<p>Produces a correct dictionary for layer effects type: gradient overlay. @param rarity: The rarity of this symbol. @param gradient: Gradient map to overwrite default gradient map. @return: Formatted gradient definition for this effect.</p> Source code in <code>src/helpers/expansion_symbol.py</code> <pre><code>def format_symbol_fx_gradient(\n    rarity: str, gradient: Optional[dict] = None\n) -&gt; Optional[EffectGradientOverlay]:\n    \"\"\"\n    Produces a correct dictionary for layer effects type: gradient overlay.\n    @param rarity: The rarity of this symbol.\n    @param gradient: Gradient map to overwrite default gradient map.\n    @return: Formatted gradient definition for this effect.\n    \"\"\"\n    # Load and update gradient map if needed\n    color_map = con.rarity_gradients.copy()\n    gradient = {} if not isinstance(gradient, dict) else gradient\n    rarities = gradient.get('colors')\n    if isinstance(rarities, dict):\n        # Validate gradient definitions\n        for key, colors in rarities.items():\n            if not isinstance(colors, list) or not colors:\n                # None value is acceptable\n                if not colors:\n                    rarities[key] = None\n                    continue\n                # Must be a list\n                print('Encountered unsupported gradient format for this symbol!')\n                rarities[key] = color_map.get(key, color_map['u'])\n                continue\n            for i, color in enumerate(colors):\n                if not isinstance(color, dict) or not color:\n                    # Must be dict\n                    print('Encountered unsupported gradient format for this symbol!')\n                    rarities[key] = color_map.get(key, color_map['u'])\n                    continue\n                # Support some colors by name\n                color['color'] = get_color(color.get('color'))\n                color.setdefault('location', 2048)\n                color.setdefault('midpoint',  50)\n                # Validate types\n                if (\n                    not isinstance(color['color'], SolidColor)\n                    or not isinstance(color['location'], int)\n                    or not isinstance(color['midpoint'], int)\n                ):\n                    # Invalid data types given\n                    print('Encountered unsupported gradient format for this symbol!')\n                    rarities[key] = color_map.get(key, color_map['u'])\n                    continue\n        color_map.update(rarities)\n\n    # Return None if no colors given\n    gradient_colors = color_map.get(rarity[0])\n    if not gradient_colors:\n        return\n\n    # Process the new gradient map colors into SolidColor objects\n    for color in gradient_colors:\n        color['color'] = get_color(color['color'])\n\n    # Create new definition\n    return {\n        'type': 'gradient-overlay',\n        'size': gradient.get('size', 4096),\n        'scale': gradient.get('scale', 70),\n        'rotation': gradient.get('rotation', 45),\n        'opacity': gradient.get('opacity', 100),\n        'colors': gradient_colors\n    }\n</code></pre>"},{"location":"helpers/expansion_symbol/#src.helpers.expansion_symbol.format_symbol_fx_stroke","title":"<code>format_symbol_fx_stroke(fx, rarity)</code>","text":"<p>Produces a correct dictionary for layer effects type: stroke. @param fx: The stroke definition we were given by the user. @param rarity: The rarity of this symbol. @return: Formatted stroke definition for this effect.</p> Source code in <code>src/helpers/expansion_symbol.py</code> <pre><code>def format_symbol_fx_stroke(fx: Union[bool, list, dict], rarity: str) -&gt; Optional[EffectStroke]:\n    \"\"\"\n    Produces a correct dictionary for layer effects type: stroke.\n    @param fx: The stroke definition we were given by the user.\n    @param rarity: The rarity of this symbol.\n    @return: Formatted stroke definition for this effect.\n    \"\"\"\n    # Layer effects details notation\n    if isinstance(fx, dict):\n        return {\n            'type': 'stroke',\n            'weight': int(fx.get('weight', cfg.symbol_stroke)),\n            'color': get_color(fx.get('color', [255, 255, 255] if rarity == Rarity.C else [0, 0, 0])),\n            'opacity': int(fx.get('opacity', 100)),\n            'style': fx.get('style', 'out')\n        }\n    # Simple [color, weight] notation\n    if isinstance(fx, list):\n        weight = cfg.symbol_stroke if fx[1] == 'default' else int(fx[1])\n        return {\n            'type': 'stroke',\n            'weight': weight,\n            'color': get_color(fx[0]),\n            'opacity': 100,\n            'style': 'out'\n        }\n    return get_default_stroke(rarity)\n</code></pre>"},{"location":"helpers/expansion_symbol/#src.helpers.expansion_symbol.get_default_gradient","title":"<code>get_default_gradient(rarity)</code>","text":"<p>Return the gradient overlay layer effects dictionary for a given rarity. @param rarity: Rarity of the symbol. @return: Gradient Overlay FX dictionary.</p> Source code in <code>src/helpers/expansion_symbol.py</code> <pre><code>def get_default_gradient(rarity: str) -&gt; Optional[EffectGradientOverlay]:\n    \"\"\"\n    Return the gradient overlay layer effects dictionary for a given rarity.\n    @param rarity: Rarity of the symbol.\n    @return: Gradient Overlay FX dictionary.\n    \"\"\"\n    if rarity == Rarity.C:\n        return\n    return {\n        'type': 'gradient-overlay',\n        'size': 4096,\n        'scale': 70,\n        'rotation': 45,\n        'opacity': 100,\n        'colors': con.rarity_gradients.get(rarity[0])\n    }\n</code></pre>"},{"location":"helpers/expansion_symbol/#src.helpers.expansion_symbol.get_default_stroke","title":"<code>get_default_stroke(rarity)</code>","text":"<p>Return the symbol stroke layer effects dictionary for a given rarity. @param rarity: Rarity of the symbol. @return: Stroke FX dictionary.</p> Source code in <code>src/helpers/expansion_symbol.py</code> <pre><code>def get_default_stroke(rarity: str) -&gt; EffectStroke:\n    \"\"\"\n    Return the symbol stroke layer effects dictionary for a given rarity.\n    @param rarity: Rarity of the symbol.\n    @return: Stroke FX dictionary.\n    \"\"\"\n    return {\n        'type': 'stroke',\n        'weight': cfg.symbol_stroke,\n        'color': rgb_black() if rarity != Rarity.C else rgb_white(),\n        'opacity': 100,\n        'style': 'out'\n    }\n</code></pre>"},{"location":"helpers/expansion_symbol/#src.helpers.expansion_symbol.get_default_symbol_dict","title":"<code>get_default_symbol_dict(char, rarity)</code>","text":"<p>Takes in a symbol character and rarity, returns a default configured symbol dict. @param char: Symbol character to use. @param rarity: Rarity to configure for. @return: Symbol info dictionary.</p> Source code in <code>src/helpers/expansion_symbol.py</code> <pre><code>def get_default_symbol_dict(char: str, rarity: str):\n    \"\"\"\n    Takes in a symbol character and rarity, returns a default configured symbol dict.\n    @param char: Symbol character to use.\n    @param rarity: Rarity to configure for.\n    @return: Symbol info dictionary.\n    \"\"\"\n    return {\n        'char': char,\n        'scale': 1,\n        'stroke': get_default_stroke(rarity),\n        'rarity': True if rarity != Rarity.C else False,\n        'gradient': get_default_gradient(rarity)\n    }\n</code></pre>"},{"location":"helpers/expansion_symbol/#src.helpers.expansion_symbol.process_expansion_symbol_info","title":"<code>process_expansion_symbol_info(symbol, rarity)</code>","text":"<p>Takes in set code and returns information needed to build the expansion symbol. @param symbol: Symbol chosen by layout object. @param rarity: Rarity of the symbol. @return: List of dicts containing information about this symbol.</p> Source code in <code>src/helpers/expansion_symbol.py</code> <pre><code>def process_expansion_symbol_info(symbol: Union[str, list], rarity: str) -&gt; Optional[list]:\n    \"\"\"\n    Takes in set code and returns information needed to build the expansion symbol.\n    @param symbol: Symbol chosen by layout object.\n    @param rarity: Rarity of the symbol.\n    @return: List of dicts containing information about this symbol.\n    \"\"\"\n    # Define symbol layer list based on data type provided\n    if isinstance(symbol, str):\n        # Symbol as a string only\n        return [get_default_symbol_dict(symbol, rarity)]\n    elif isinstance(symbol, dict):\n        # Single layered symbol\n        return [format_expansion_symbol_dict(symbol, rarity)]\n    elif isinstance(symbol, list):\n        # Multilayered symbol\n        return [format_expansion_symbol_dict(sym, rarity) for sym in symbol]\n    # Unsupported data type, return default symbol\n    return process_expansion_symbol_info(cfg.get_default_symbol(), rarity)\n</code></pre>"},{"location":"helpers/layers/","title":"Layers","text":"<p>PHOTOSHOP HELPER FUNCTIONS</p>"},{"location":"helpers/layers/#src.helpers.layers.NO_DIALOG","title":"<code>NO_DIALOG = DialogModes.DisplayNoDialogs</code>  <code>module-attribute</code>","text":"<p>FINDING LAYERS</p>"},{"location":"helpers/layers/#src.helpers.layers.create_new_layer","title":"<code>create_new_layer(layer_name=None)</code>","text":"<p>Creates a new layer below the currently active layer. The layer will be visible. @param layer_name: Optional name for the new layer @return: Newly created layer object</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def create_new_layer(layer_name: Optional[str] = None) -&gt; ArtLayer:\n    \"\"\"\n    Creates a new layer below the currently active layer. The layer will be visible.\n    @param layer_name: Optional name for the new layer\n    @return: Newly created layer object\n    \"\"\"\n    # Create new layer at top of layers\n    active_layer = app.activeDocument.activeLayer\n    layer = app.activeDocument.artLayers.add()\n    layer.name = layer_name or \"Layer\"\n\n    # Name it &amp; set blend mode to normal\n    layer.blendMode = BlendMode.NormalBlend\n\n    # Move the layer below\n    layer.moveAfter(active_layer)\n    return layer\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.duplicate_group","title":"<code>duplicate_group(name)</code>","text":"<p>Duplicates current active layer set without renaming contents. @param name: Name to give the newly created layer set. @return: The newly created layer set object.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def duplicate_group(name: str):\n    \"\"\"\n    Duplicates current active layer set without renaming contents.\n    @param name: Name to give the newly created layer set.\n    @return: The newly created layer set object.\n    \"\"\"\n    desc241 = ActionDescriptor()\n    ref4 = ActionReference()\n    ref4.putEnumerated(sID(\"layer\"), sID(\"ordinal\"), sID(\"targetEnum\"))\n    desc241.putReference(sID(\"target\"),  ref4)\n    desc241.putString(sID(\"name\"), name)\n    desc241.putInteger(sID(\"version\"),  5)\n    app.ExecuteAction(sID(\"duplicate\"), desc241, DialogModes.DisplayNoDialogs)\n    return app.activeDocument.activeLayer\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.edit_smart_layer","title":"<code>edit_smart_layer(layer)</code>","text":"<p>Opens the contents of a given smart layer (as a separate document) for editing. @param layer: Smart layer to open for editing.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def edit_smart_layer(layer: ArtLayer):\n    \"\"\"\n    Opens the contents of a given smart layer (as a separate document) for editing.\n    @param layer: Smart layer to open for editing.\n    \"\"\"\n    desc1 = ActionDescriptor()\n    desc1.putInteger(sID(\"documentID\"), app.activeDocument.id)\n    desc1.putInteger(sID(\"layerID\"), layer.id)\n    app.executeAction(sID(\"placedLayerEditContents\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.getLayer","title":"<code>getLayer(name, group=None)</code>","text":"<p>Retrieve ArtLayer object from given name and group/group tree. @param name: Name of the layer @param group: Group name/object, or ordered list of group names/objects @return: Layer object requested</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def getLayer(name: str, group: Optional[Union[str, list, tuple, LayerSet]] = None) -&gt; Optional[ArtLayer]:\n    \"\"\"\n    Retrieve ArtLayer object from given name and group/group tree.\n    @param name: Name of the layer\n    @param group: Group name/object, or ordered list of group names/objects\n    @return: Layer object requested\n    \"\"\"\n    try:\n        # LayerSet provided?\n        if not group:\n            # LayerSet not provided\n            return app.activeDocument.artLayers[name]\n        elif isinstance(group, str):\n            # LayerSet name given\n            return app.activeDocument.layerSets[group].artLayers[name]\n        elif isinstance(group, LayerContainer):\n            # LayerSet object given\n            return group.artLayers[name]\n        elif isinstance(group, (tuple, list)):\n            # Tuple or list of LayerSets\n            layer_set = app.activeDocument\n            for g in group:\n                if isinstance(g, str):\n                    # LayerSet name given\n                    layer_set = layer_set.layerSets[g]\n                elif isinstance(g, LayerContainer):\n                    # LayerSet object given\n                    layer_set = g\n            return layer_set.artLayers[name]\n        # ArtLayer can't be located\n        raise OSError(f\"ArtLayer invalid\")\n    except PS_EXCEPTIONS:\n        # Layer couldn't be found\n        print(f'Layer \"{name}\" could not be found!')\n        if group and isinstance(group, LayerSet):\n            print(f\"LayerSet reference used: {group.name}\")\n        elif group and isinstance(group, str):\n            print(f\"LayerSet reference used: {group}\")\n    return\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.getLayerSet","title":"<code>getLayerSet(name, group=None)</code>","text":"<p>Retrieve layer group object. @param name: Name of the group @param group: Parent group name or object. @return: Group object requested.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def getLayerSet(name: str, group: Optional[Union[str, list, tuple, LayerSet]] = None) -&gt; Optional[LayerSet]:\n    \"\"\"\n    Retrieve layer group object.\n    @param name: Name of the group\n    @param group: Parent group name or object.\n    @return: Group object requested.\n    \"\"\"\n    try:\n        # Was LayerSet provided?\n        if not group:\n            # No LayerSet given\n            return app.activeDocument.layerSets[name]\n        elif isinstance(group, str):\n            # LayerSet name given\n            return app.activeDocument.layerSets[group].layerSets[name]\n        elif isinstance(group, (tuple, list)):\n            # Tuple or list of groups\n            layer_set = app.activeDocument\n            for g in group:\n                if isinstance(g, str):\n                    # LayerSet name given\n                    layer_set = layer_set.layerSets[g]\n                elif isinstance(g, LayerContainer):\n                    # LayerSet object given\n                    layer_set = g\n            return layer_set.layerSets[name]\n        elif isinstance(group, LayerContainer):\n            # LayerSet object given\n            return group.layerSets[name]\n        # LayerSet can't be located\n        raise OSError(f\"LayerSet invalid\")\n    except PS_EXCEPTIONS:\n        print(f'LayerSet \"{name}\" could not be found!')\n        if group and isinstance(group, LayerSet):\n            print(f\"LayerSet reference used: {group.name}\")\n        elif group and isinstance(group, str):\n            print(f\"LayerSet reference used: {group}\")\n    return\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.group_layers","title":"<code>group_layers(name='New Group', layers=None)</code>","text":"<p>Groups the selected layers. @param name: Name of the new group. @param layers: Layers to group, will use active if not provided. @return: The newly created group.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def group_layers(\n    name: Optional[str] = \"New Group\",\n    layers: Optional[list[Union[ArtLayer, LayerSet]]] = None,\n) -&gt; LayerSet:\n    \"\"\"\n    Groups the selected layers.\n    @param name: Name of the new group.\n    @param layers: Layers to group, will use active if not provided.\n    @return: The newly created group.\n    \"\"\"\n    # Select layers if given\n    if layers:\n        select_layers(layers)\n\n    # Group the layers\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref2 = ActionReference()\n    ref1.putClass(sID(\"layerSection\"))\n    desc1.putReference(sID('null'), ref1)\n    ref2.putEnumerated(cID('Lyr '), cID('Ordn'), cID('Trgt'))\n    desc1.putReference(cID('From'), ref2)\n    desc2 = ActionDescriptor()\n    desc2.putString(cID('Nm  '), name)\n    desc1.putObject(cID('Usng'), sID(\"layerSection\"), desc2)\n    desc1.putInteger(sID(\"layerSectionStart\"), 0)\n    desc1.putInteger(sID(\"layerSectionEnd\"), 1)\n    desc1.putString(cID('Nm  '), name)\n    app.executeAction(cID('Mk  '), desc1, DialogModes.DisplayNoDialogs)\n    return app.activeDocument.activeLayer\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.lock_layer","title":"<code>lock_layer(layer, protection='protectAll')</code>","text":"<p>Locks the given layer. @param layer: The layer to lock. @param protection: protectAll to lock, protectNone to unlock</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def lock_layer(layer: Union[ArtLayer, LayerSet], protection: str = \"protectAll\") -&gt; None:\n    \"\"\"\n    Locks the given layer.\n    @param layer: The layer to lock.\n    @param protection: protectAll to lock, protectNone to unlock\n    \"\"\"\n    desc819 = ActionDescriptor()\n    ref378 = ActionReference()\n    ref378.putIdentifier(cID(\"Lyr \"), layer.id)\n    desc819.putReference(sID(\"target\"), ref378)\n    desc820 = ActionDescriptor()\n    desc820.putBoolean(sID(protection), True)\n    idlayerLocking = sID(\"layerLocking\")\n    desc819.putObject(idlayerLocking, idlayerLocking, desc820)\n    app.executeAction(sID(\"applyLocking\"), desc819, NO_DIALOG)\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.merge_group","title":"<code>merge_group(group=None)</code>","text":"<p>Merges a layer set into a single layer. @param group: Layer set to merge. Merges active if not provided.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def merge_group(group: Optional[LayerSet] = None):\n    \"\"\"\n    Merges a layer set into a single layer.\n    @param group: Layer set to merge. Merges active if not provided.\n    \"\"\"\n    if group:\n        app.activeDocument.activeLayer = group\n    app.executeaction(sID(\"mergeLayersNew\"), None, NO_DIALOG)\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.merge_layers","title":"<code>merge_layers(layers=None, name=None)</code>","text":"<p>Merge a set of layers together. @param layers: Layers to be merged, uses active if not provided. @param name: Name of the newly created layer. @return: Returns the merged layer.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def merge_layers(layers: list[ArtLayer] = None, name: Optional[str] = None) -&gt; ArtLayer:\n    \"\"\"\n    Merge a set of layers together.\n    @param layers: Layers to be merged, uses active if not provided.\n    @param name: Name of the newly created layer.\n    @return: Returns the merged layer.\n    \"\"\"\n    # Select none, then select entire list\n    if layers:\n        select_layers(layers)\n\n    # Return layer if only one is present in the list\n    if len(layers) == 1:\n        return layers[0]\n\n    # Merge layers and return result\n    app.ExecuteAction(sID(\"mergeLayersNew\"), ActionDescriptor(), NO_DIALOG)\n    if name:\n        app.activeDocument.activeLayer.name = name\n    return app.activeDocument.activeLayer\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.select_bounds","title":"<code>select_bounds(bounds)</code>","text":"<p>Create a selection using a list of bound values. @param bounds: List of bound values (left, top, right, bottom).</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def select_bounds(bounds: list[Union[int, float]]) -&gt; None:\n    \"\"\"\n    Create a selection using a list of bound values.\n    @param bounds: List of bound values (left, top, right, bottom).\n    \"\"\"\n    left, top, right, bottom = bounds\n    app.activeDocument.selection.select([\n        [left, top],\n        [right, top],\n        [right, bottom],\n        [left, bottom]\n    ])\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.select_layer","title":"<code>select_layer(layer, add=False, make_visible=False)</code>","text":"<p>Select a layer (make active) and optionally force it to be visible. @param layer: Layer to select. @param add: Add to existing selection. @param make_visible: Make the layer visible if not currently visible?                      Doesn't work with adding layers to selection.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def select_layer(\n    layer: Union[ArtLayer, LayerSet],\n    add: bool = False,\n    make_visible: bool = False\n) -&gt; None:\n    \"\"\"\n    Select a layer (make active) and optionally force it to be visible.\n    @param layer: Layer to select.\n    @param add: Add to existing selection.\n    @param make_visible: Make the layer visible if not currently visible?\n                         Doesn't work with adding layers to selection.\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.putIdentifier(sID(\"layer\"), layer.id)\n    desc1.putReference(sID(\"target\"), ref1)\n    # Add to currently selected layers?\n    if add:\n        desc1.putEnumerated(\n            sID('selectionModifier'),\n            sID('selectionModifierType'),\n            sID('addToSelection')\n        )\n    # Force visible?\n    desc1.putBoolean(sID(\"makeVisible\"), make_visible)\n    app.executeAction(sID('select'), desc1, DialogModes.DisplayNoDialogs)\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.select_layer_bounds","title":"<code>select_layer_bounds(layer=None)</code>","text":"<p>Select the bounding box of a given layer. @param layer: Layer to select the pixels of. Uses active layer if not provided.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def select_layer_bounds(layer: ArtLayer = None):\n    \"\"\"\n    Select the bounding box of a given layer.\n    @param layer: Layer to select the pixels of. Uses active layer if not provided.\n    \"\"\"\n    if not layer:\n        layer = app.activeDocument.activeLayer\n    select_bounds(layer.bounds)\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.select_layer_pixels","title":"<code>select_layer_pixels(layer=None)</code>","text":"<p>Select pixels of the active layer, or a target layer. @param layer: Layer to select. Uses active layer if not provided.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def select_layer_pixels(layer: Optional[ArtLayer] = None) -&gt; None:\n    \"\"\"\n    Select pixels of the active layer, or a target layer.\n    @param layer: Layer to select. Uses active layer if not provided.\n    \"\"\"\n    if layer and layer.kind == LayerKind.SolidFillLayer:\n        return select_vector_layer_pixels(layer)\n    des1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref2 = ActionReference()\n    ref1.putProperty(sID(\"channel\"), sID(\"selection\"))\n    des1.putReference(sID(\"target\"), ref1)\n    ref2.putEnumerated(sID(\"channel\"), sID(\"channel\"), sID(\"transparencyEnum\"))\n    if layer:\n        ref2.putIdentifier(sID(\"layer\"), layer.id)\n    des1.putReference(sID(\"to\"), ref2)\n    app.executeAction(sID(\"set\"), des1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.select_layers","title":"<code>select_layers(layers)</code>","text":"<p>Makes a list of layers active (selected) in the layer panel. @param layers: List of layers or layer sets.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def select_layers(layers: list[ArtLayer, LayerSet]):\n    \"\"\"\n    Makes a list of layers active (selected) in the layer panel.\n    @param layers: List of layers or layer sets.\n    \"\"\"\n    # Select none, then add all layers to selection\n    select_no_layers()\n    for lay in layers:\n        select_layer(lay, add=True)\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.select_no_layers","title":"<code>select_no_layers()</code>","text":"<p>Deselect all layers.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def select_no_layers() -&gt; None:\n    \"\"\"\n    Deselect all layers.\n    \"\"\"\n    selectNone = ActionDescriptor()\n    ref = ActionReference()\n    ref.putEnumerated(sID(\"layer\"), sID(\"ordinal\"), sID(\"targetEnum\"))\n    selectNone.putReference(sID(\"target\"), ref)\n    app.executeAction(sID(\"selectNoLayers\"), selectNone, NO_DIALOG)\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.select_vector_layer_pixels","title":"<code>select_vector_layer_pixels(layer=None)</code>","text":"<p>Select pixels of the active vector layer, or a target layer. @param layer: Layer to select. Uses active layer if not provided.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def select_vector_layer_pixels(layer: Optional[ArtLayer] = None) -&gt; None:\n    \"\"\"\n    Select pixels of the active vector layer, or a target layer.\n    @param layer: Layer to select. Uses active layer if not provided.\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref2 = ActionReference()\n    ref1.putProperty(sID(\"channel\"), sID(\"selection\"))\n    desc1.putReference(sID(\"target\"), ref1)\n    ref2.putEnumerated(sID(\"path\"), sID(\"path\"), sID(\"vectorMask\"))\n    if layer:\n        ref2.putIdentifier(sID(\"layer\"), layer.id)\n    desc1.putReference(sID(\"to\"), ref2)\n    desc1.putInteger(sID(\"version\"), 1)\n    desc1.putBoolean(sID(\"vectorMaskParams\"), True)\n    app.executeaction(sID(\"set\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.smart_layer","title":"<code>smart_layer(layer=None)</code>","text":"<p>Makes the active layer or layer set a smart layer. Optionally make a given layer active first. @param layer: [Optional] Layer to make active. @return: Newly created smart layer.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def smart_layer(layer: Union[ArtLayer, LayerSet] = None) -&gt; ArtLayer:\n    \"\"\"\n    Makes the active layer or layer set a smart layer.\n    Optionally make a given layer active first.\n    @param layer: [Optional] Layer to make active.\n    @return: Newly created smart layer.\n    \"\"\"\n    if layer:\n        app.activeDocument.activeLayer = layer\n    app.ExecuteAction(sID(\"newPlacedLayer\"), None, DialogModes.DisplayNoDialogs)\n    return app.activeDocument.activeLayer\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.unlock_layer","title":"<code>unlock_layer(layer)</code>","text":"<p>Unlocks the given layer. @param layer: The layer to unlock.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def unlock_layer(layer: Union[ArtLayer, LayerSet]) -&gt; None:\n    \"\"\"\n    Unlocks the given layer.\n    @param layer: The layer to unlock.\n    \"\"\"\n    lock_layer(layer, \"protectNone\")\n</code></pre>"},{"location":"helpers/layers/#src.helpers.layers.unpack_smart_layer","title":"<code>unpack_smart_layer(layer=None)</code>","text":"<p>Converts a smart layer back into its separate components.</p> Source code in <code>src/helpers/layers.py</code> <pre><code>def unpack_smart_layer(layer: Optional[ArtLayer] = None):\n    \"\"\"Converts a smart layer back into its separate components.\"\"\"\n    if layer:\n        app.activeDocument.activeLayer = layer\n    app.ExecuteAction(sID(\"placedLayerConvertToLayers\"), None, NO_DIALOG)\n</code></pre>"},{"location":"helpers/masks/","title":"Masks","text":"<p>MASK HELPERS</p>"},{"location":"helpers/masks/#src.helpers.masks.apply_mask","title":"<code>apply_mask(layer=None)</code>","text":"<p>Applies a given layer's mask. @param layer: ArtLayer or LayerSet object, use active layer if not provided.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def apply_mask(layer: Union[ArtLayer, LayerSet, None] = None) -&gt; None:\n    \"\"\"\n    Applies a given layer's mask.\n    @param layer: ArtLayer or LayerSet object, use active layer if not provided.\n    \"\"\"\n    if layer:\n        select_layer(layer)\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.putEnumerated(sID(\"channel\"), sID(\"channel\"), sID(\"mask\"))\n    desc1.putReference(sID(\"target\"),  ref1)\n    desc1.putBoolean(sID(\"apply\"), True)\n    app.executeaction(sID(\"delete\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.apply_mask_to_layer_fx","title":"<code>apply_mask_to_layer_fx(layer=None)</code>","text":"<p>Sets the layer mask to apply only to layer effects in blending options. @param layer: ArtLayer or LayerSet object.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def apply_mask_to_layer_fx(layer: Union[ArtLayer, LayerSet] = None) -&gt; None:\n    \"\"\"\n    Sets the layer mask to apply only to layer effects in blending options.\n    @param layer: ArtLayer or LayerSet object.\n    \"\"\"\n    if not layer:\n        layer = app.activeDocument.activeLayer\n    ref = ActionReference()\n    ref.putIdentifier(sID(\"layer\"), layer.id)\n    desc = app.executeActionGet(ref)\n    layer_fx = desc.getObjectValue(sID('layerEffects'))\n    layer_fx.putBoolean(sID(\"layerMaskAsGlobalMask\"), True)\n    desc = ActionDescriptor()\n    desc.putReference(sID(\"target\"), ref)\n    desc.putObject(sID(\"to\"), sID(\"layer\"), layer_fx)\n    app.executeAction(sID(\"set\"), desc,  NO_DIALOG)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.copy_layer_mask","title":"<code>copy_layer_mask(layer_from, layer_to)</code>","text":"<p>Copies mask from one layer to another. @param layer_from: Layer to copy from. @param layer_to: Layer to copy to.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def copy_layer_mask(\n    layer_from: Union[ArtLayer, LayerSet],\n    layer_to: Union[ArtLayer, LayerSet]\n) -&gt; None:\n    \"\"\"\n    Copies mask from one layer to another.\n    @param layer_from: Layer to copy from.\n    @param layer_to: Layer to copy to.\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref17 = ActionReference()\n    ref18 = ActionReference()\n    desc1.putClass(sID(\"new\"), sID(\"channel\"))\n    ref17.putEnumerated(sID(\"channel\"), sID(\"channel\"), sID(\"mask\"))\n    ref17.putIdentifier(sID(\"layer\"), layer_to.id)\n    desc1.putReference(sID(\"at\"), ref17)\n    ref18.putEnumerated(sID(\"channel\"), sID(\"channel\"), sID(\"mask\"))\n    ref18.putIdentifier(sID(\"layer\"), layer_from.id)\n    desc1.putReference(sID(\"using\"), ref18)\n    app.executeAction(sID(\"make\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.copy_vector_mask","title":"<code>copy_vector_mask(layer_from, layer_to)</code>","text":"<p>Copies vector mask from one layer to another. @param layer_from: Layer to copy from. @param layer_to: Layer to copy to.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def copy_vector_mask(\n    layer_from: Union[ArtLayer, LayerSet],\n    layer_to: Union[ArtLayer, LayerSet]\n) -&gt; None:\n    \"\"\"\n    Copies vector mask from one layer to another.\n    @param layer_from: Layer to copy from.\n    @param layer_to: Layer to copy to.\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref2 = ActionReference()\n    ref3 = ActionReference()\n    ref1.putClass(sID(\"path\"))\n    desc1.putReference(sID(\"target\"),  ref1)\n    ref2.putEnumerated(sID(\"path\"), sID(\"path\"), sID(\"vectorMask\"))\n    ref2.putIdentifier(sID(\"layer\"),  layer_to.id)\n    desc1.putReference(sID(\"at\"),  ref2)\n    ref3.putEnumerated(sID(\"path\"), sID(\"path\"), sID(\"vectorMask\"))\n    ref3.putIdentifier(sID(\"layer\"), layer_from.id)\n    desc1.putReference(sID(\"using\"),  ref3)\n    app.executeaction(sID(\"make\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.delete_mask","title":"<code>delete_mask(layer=None)</code>","text":"<p>Removes a given layer's mask. @param layer: ArtLayer ore LayerSet object, use active layer if not provided.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def delete_mask(layer: Union[ArtLayer, LayerSet, None] = None) -&gt; None:\n    \"\"\"\n    Removes a given layer's mask.\n    @param layer: ArtLayer ore LayerSet object, use active layer if not provided.\n    \"\"\"\n    if layer:\n        app.activeDocument.activeLayer = layer\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.putEnumerated(sID(\"channel\"), sID(\"ordinal\"), sID(\"targetEnum\"))\n    desc1.putReference(sID(\"target\"), ref1)\n    app.executeAction(sID(\"delete\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.disable_mask","title":"<code>disable_mask(layer=None)</code>","text":"<p>Disables a given layer's mask. @param layer: ArtLayer object.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def disable_mask(layer: Union[ArtLayer, LayerSet, None] = None) -&gt; None:\n    \"\"\"\n    Disables a given layer's mask.\n    @param layer: ArtLayer object.\n    \"\"\"\n    set_layer_mask(layer, False)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.disable_vector_mask","title":"<code>disable_vector_mask(layer=None)</code>","text":"<p>Disables a given layer's vector mask. @param layer: ArtLayer object.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def disable_vector_mask(layer: Union[ArtLayer, LayerSet, None] = None) -&gt; None:\n    \"\"\"\n    Disables a given layer's vector mask.\n    @param layer: ArtLayer object.\n    \"\"\"\n    set_layer_vector_mask(layer, False)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.enable_mask","title":"<code>enable_mask(layer=None)</code>","text":"<p>Enables a given layer's mask. @param layer: ArtLayer object.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def enable_mask(layer: Union[ArtLayer, LayerSet, None] = None) -&gt; None:\n    \"\"\"\n    Enables a given layer's mask.\n    @param layer: ArtLayer object.\n    \"\"\"\n    set_layer_mask(layer, True)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.enable_vector_mask","title":"<code>enable_vector_mask(layer=None)</code>","text":"<p>Enables a given layer's vector mask. @param layer: ArtLayer object.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def enable_vector_mask(layer: Union[ArtLayer, LayerSet, None] = None) -&gt; None:\n    \"\"\"\n    Enables a given layer's vector mask.\n    @param layer: ArtLayer object.\n    \"\"\"\n    set_layer_vector_mask(layer, True)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.set_layer_mask","title":"<code>set_layer_mask(layer=None, visible=True)</code>","text":"<p>Set the visibility of a layer's mask. @param layer: ArtLayer object. @param visible: Whether to make the layer mask visible.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def set_layer_mask(\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    visible: bool = True\n) -&gt; None:\n    \"\"\"\n    Set the visibility of a layer's mask.\n    @param layer: ArtLayer object.\n    @param visible: Whether to make the layer mask visible.\n    \"\"\"\n    if not layer:\n        layer = app.activeDocument.activeLayer\n    desc1 = ActionDescriptor()\n    desc2 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.putIdentifier(cID(\"Lyr \"), layer.id)\n    desc1.putReference(sID(\"target\"), ref1)\n    desc2.putBoolean(cID(\"UsrM\"), visible)\n    desc1.putObject(cID(\"T   \"), cID(\"Lyr \"), desc2)\n    app.executeAction(cID(\"setd\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/masks/#src.helpers.masks.set_layer_vector_mask","title":"<code>set_layer_vector_mask(layer=None, visible=False)</code>","text":"<p>Set the visibility of a layer's vector mask. @param layer: ArtLayer object. @param visible: Whether to make the vector mask visible.</p> Source code in <code>src/helpers/masks.py</code> <pre><code>def set_layer_vector_mask(\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    visible: bool = False\n) -&gt; None:\n    \"\"\"\n    Set the visibility of a layer's vector mask.\n    @param layer: ArtLayer object.\n    @param visible: Whether to make the vector mask visible.\n    \"\"\"\n    if not layer:\n        layer = app.activeDocument.activeLayer\n    desc1 = ActionDescriptor()\n    desc2 = ActionDescriptor()\n    ref1 = ActionReference()\n    ref1.putIdentifier(sID(\"layer\"), layer.id)\n    desc1.putReference(sID(\"target\"), ref1)\n    desc2.putBoolean(sID(\"vectorMaskEnabled\"), visible)\n    desc1.putObject(sID(\"to\"), sID(\"layer\"), desc2)\n    app.executeAction(sID(\"set\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/position/","title":"Position","text":""},{"location":"helpers/position/#src.helpers.position.positions_vertical","title":"<code>positions_vertical = [Dimensions.Top, Dimensions.Bottom, Dimensions.CenterY]</code>  <code>module-attribute</code>","text":"<p>ALIGNMENT</p>"},{"location":"helpers/position/#src.helpers.position.align","title":"<code>align(axis=None, layer=None, reference=None)</code>","text":"<p>Align the currently active layer to current selection, vertically or horizontal. @param axis: Which axis use when aligning the layer, can be provided as a single axis or list. @param layer: ArtLayer or LayerSet to align. Uses active layer if not provided. @param reference: Reference to align the layer within. Uses current selection if not provided.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def align(\n    axis: Union[str, list[str], None] = None,\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    reference: Union[ArtLayer, LayerSet, dict, None] = None\n) -&gt; None:\n    \"\"\"\n    Align the currently active layer to current selection, vertically or horizontal.\n    @param axis: Which axis use when aligning the layer, can be provided as a single axis or list.\n    @param layer: ArtLayer or LayerSet to align. Uses active layer if not provided.\n    @param reference: Reference to align the layer within. Uses current selection if not provided.\n    \"\"\"\n    # Default axis is both\n    axis = axis or [Dimensions.CenterX, Dimensions.CenterY]\n\n    # Get the dimensions of the reference and layer if not provided\n    area = get_dimensions_from_bounds(app.activeDocument.selection.bounds) if not reference else (\n        reference if isinstance(reference, dict) else get_layer_dimensions(reference))\n    layer = layer or app.activeDocument.activeLayer\n    item = get_layer_dimensions(layer)\n\n    # Single axis provided\n    if isinstance(axis, str):\n        x = area[axis] - item[axis] if axis in positions_horizontal else 0\n        y = area[axis] - item[axis] if axis in positions_vertical else 0\n    else:\n        x = area[axis[0]] - item[axis[0]]\n        y = area[axis[1]] - item[axis[1]]\n\n    # Shift location using the position difference\n    layer.translate(x, y)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.align_all","title":"<code>align_all(layer=None, reference=None)</code>","text":"<p>Utility definition for passing CenterX and CenterY to align function.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def align_all(\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    reference: Union[ArtLayer, LayerSet, dict, None] = None\n) -&gt; None:\n    \"\"\"Utility definition for passing CenterX and CenterY to align function.\"\"\"\n    align([Dimensions.CenterX, Dimensions.CenterY], layer, reference)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.align_bottom","title":"<code>align_bottom(layer=None, reference=None)</code>","text":"<p>Utility definition for passing Bottom to align function.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def align_bottom(\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    reference: Union[ArtLayer, LayerSet, dict, None] = None\n) -&gt; None:\n    \"\"\"Utility definition for passing Bottom to align function.\"\"\"\n    align(Dimensions.Bottom, layer, reference)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.align_horizontal","title":"<code>align_horizontal(layer=None, reference=None)</code>","text":"<p>Utility definition for passing CenterX to align function.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def align_horizontal(\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    reference: Union[ArtLayer, LayerSet, dict, None] = None\n) -&gt; None:\n    \"\"\"Utility definition for passing CenterX to align function.\"\"\"\n    align(Dimensions.CenterX, layer, reference)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.align_left","title":"<code>align_left(layer=None, reference=None)</code>","text":"<p>Utility definition for passing Left to align function.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def align_left(\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    reference: Union[ArtLayer, LayerSet, dict, None] = None\n) -&gt; None:\n    \"\"\"Utility definition for passing Left to align function.\"\"\"\n    align(Dimensions.Left, layer, reference)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.align_right","title":"<code>align_right(layer=None, reference=None)</code>","text":"<p>Utility definition for passing Right to align function.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def align_right(\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    reference: Union[ArtLayer, LayerSet, dict, None] = None\n) -&gt; None:\n    \"\"\"Utility definition for passing Right to align function.\"\"\"\n    align(Dimensions.Right, layer, reference)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.align_top","title":"<code>align_top(layer=None, reference=None)</code>","text":"<p>Utility definition for passing Top to align function.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def align_top(\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    reference: Union[ArtLayer, LayerSet, dict, None] = None\n) -&gt; None:\n    \"\"\"Utility definition for passing Top to align function.\"\"\"\n    align(Dimensions.Top, layer, reference)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.align_vertical","title":"<code>align_vertical(layer=None, reference=None)</code>","text":"<p>Utility definition for passing CenterY to align function.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def align_vertical(\n    layer: Union[ArtLayer, LayerSet, None] = None,\n    reference: Union[ArtLayer, LayerSet, dict, None] = None\n) -&gt; None:\n    \"\"\"Utility definition for passing CenterY to align function.\"\"\"\n    align(Dimensions.CenterY, layer, reference)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.frame_layer","title":"<code>frame_layer(layer, reference, smallest=False, anchor=AnchorPosition.TopLeft, alignments=None)</code>","text":"<p>Scale and position a layer within the bounds of a reference layer. @param layer: Layer to scale and position. @param reference: Reference frame to position within. @param smallest: Whether to scale to smallest or largest edge. @param anchor: Anchor position for scaling the layer. @param alignments: Alignments used to position the layer.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def frame_layer(\n    layer: Union[ArtLayer, LayerSet],\n    reference: Union[ArtLayer, LayerSet, dict],\n    smallest: bool = False,\n    anchor: AnchorPosition = AnchorPosition.TopLeft,\n    alignments: Union[Dimensions, list[Dimensions], None] = None\n):\n    \"\"\"\n    Scale and position a layer within the bounds of a reference layer.\n    @param layer: Layer to scale and position.\n    @param reference: Reference frame to position within.\n    @param smallest: Whether to scale to smallest or largest edge.\n    @param anchor: Anchor position for scaling the layer.\n    @param alignments: Alignments used to position the layer.\n    \"\"\"\n    # Get layer and reference dimensions\n    layer_dim = get_layer_dimensions(layer)\n    ref_dim = reference if isinstance(reference, dict) else get_layer_dimensions(reference)\n\n    # Scale the layer to fit either the largest, or the smallest dimension\n    action = min if smallest else max\n    scale = 100 * action((ref_dim['width'] / layer_dim['width']), (ref_dim['height'] / layer_dim['height']))\n    layer.resize(scale, scale, anchor)\n\n    # Default alignments are center horizontal and vertical\n    align(alignments or [Dimensions.CenterX, Dimensions.CenterY], layer, ref_dim)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.position_between_layers","title":"<code>position_between_layers(layer, top_layer, bottom_layer)</code>","text":"<p>Align layer vertically between two reference layers. @param layer: Layer to align vertically @param top_layer: Reference layer above the layer to be aligned. @param bottom_layer: Reference layer below the layer to be aligned.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def position_between_layers(\n    layer: Union[ArtLayer, LayerSet],\n    top_layer: Union[ArtLayer, LayerSet],\n    bottom_layer: Union[ArtLayer, LayerSet]\n) -&gt; None:\n    \"\"\"\n    Align layer vertically between two reference layers.\n    @param layer: Layer to align vertically\n    @param top_layer: Reference layer above the layer to be aligned.\n    @param bottom_layer: Reference layer below the layer to be aligned.\n    \"\"\"\n    docref = app.activeDocument\n    bounds = [0, top_layer.bounds[3], docref.width, bottom_layer.bounds[1]]\n    align_vertical(layer, reference=get_dimensions_from_bounds(bounds))\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.position_dividers","title":"<code>position_dividers(dividers, layers)</code>","text":"<p>Positions a list of dividers between a list of layers. @param dividers: Divider layers to position, should contain 1 fewer objects than layers param. @param layers: Layers to position the dividers between.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def position_dividers(\n    dividers: list[Union[ArtLayer, LayerSet]],\n    layers: list[Union[ArtLayer, LayerSet]]\n) -&gt; None:\n    \"\"\"\n    Positions a list of dividers between a list of layers.\n    @param dividers: Divider layers to position, should contain 1 fewer objects than layers param.\n    @param layers: Layers to position the dividers between.\n    \"\"\"\n    for i in range(len(layers) - 1):\n        position_between_layers(dividers[i], layers[i], layers[i + 1])\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.space_layers_apart","title":"<code>space_layers_apart(layers, gap)</code>","text":"<p>Position list of layers apart using a given gap. @param layers: List of ArtLayers or LayerSets. @param gap: Gap in pixels.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def space_layers_apart(layers: list[Union[ArtLayer, LayerSet]], gap: Union[int, float]) -&gt; None:\n    \"\"\"\n    Position list of layers apart using a given gap.\n    @param layers: List of ArtLayers or LayerSets.\n    @param gap: Gap in pixels.\n    \"\"\"\n    # Position each layer relative to the one above it\n    for i in range((len(layers) - 1)):\n        delta = (layers[i].bounds[3] + gap) - layers[i + 1].bounds[1]\n        layers[i + 1].translate(0, delta)\n</code></pre>"},{"location":"helpers/position/#src.helpers.position.spread_layers_over_reference","title":"<code>spread_layers_over_reference(layers, ref, gap=None, inside_gap=None, outside_matching=True)</code>","text":"<p>Spread layers apart across a reference layer. @param layers: List of ArtLayers or LayerSets. @param ref: Reference used as the maximum height boundary for all layers given. @param gap: Gap between the top of the reference and the first layer, or between all layers if not provided. @param inside_gap: Gap between each layer, calculated using leftover space if not provided. @param outside_matching: If enabled, will enforce top and bottom gap to match.</p> Source code in <code>src/helpers/position.py</code> <pre><code>def spread_layers_over_reference(\n    layers: list[ArtLayer],\n    ref: ArtLayer,\n    gap: Optional[Union[int, float]] = None,\n    inside_gap: Union[int, float, None] = None,\n    outside_matching: bool = True\n) -&gt; None:\n    \"\"\"\n    Spread layers apart across a reference layer.\n    @param layers: List of ArtLayers or LayerSets.\n    @param ref: Reference used as the maximum height boundary for all layers given.\n    @param gap: Gap between the top of the reference and the first layer, or between all layers if not provided.\n    @param inside_gap: Gap between each layer, calculated using leftover space if not provided.\n    @param outside_matching: If enabled, will enforce top and bottom gap to match.\n    \"\"\"\n    # Calculate outside gap if not provided\n    outside_gap = gap\n    if not gap:\n        total_space = get_layer_dimensions(ref)['height'] - sum(\n            [get_text_layer_dimensions(layer)['height'] for layer in layers]\n        )\n        outside_gap = total_space / (len(layers) + 1)\n\n    # Position the top layer relative to the reference\n    delta = (ref.bounds[1] + outside_gap) - layers[0].bounds[1]\n    layers[0].translate(0, delta)\n\n    # Calculate inside gap if not provided\n    if gap and not inside_gap:\n        # Calculate the inside gap\n        ignored = 2 if outside_matching else 1\n        spaces = len(layers) - 1 if outside_matching else len(layers)\n        total_space = get_layer_dimensions(ref)['height'] - sum(\n            [get_text_layer_dimensions(layer)['height'] for layer in layers]\n        )\n        inside_gap = (total_space - (ignored * gap)) / spaces\n    elif not gap:\n        # Use the outside gap uniformly\n        inside_gap = outside_gap\n\n    # Position the bottom layers relative to the top\n    space_layers_apart(layers, inside_gap)\n</code></pre>"},{"location":"helpers/text/","title":"Text","text":"<p>TEXT HELPERS</p>"},{"location":"helpers/text/#src.helpers.text.NO_DIALOG","title":"<code>NO_DIALOG = DialogModes.DisplayNoDialogs</code>  <code>module-attribute</code>","text":"<p>TEXT UTILITIES</p>"},{"location":"helpers/text/#src.helpers.text.apply_text_key","title":"<code>apply_text_key(text_layer, text_key)</code>","text":"<p>Applies a TextKey action descriptor to a given TextLayer. @param text_layer: ArtLayer which must be a TextLayer kind. @param text_key: TextKey extracted from a TextLayer that has been modified.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def apply_text_key(text_layer, text_key) -&gt; None:\n    \"\"\"\n    Applies a TextKey action descriptor to a given TextLayer.\n    @param text_layer: ArtLayer which must be a TextLayer kind.\n    @param text_key: TextKey extracted from a TextLayer that has been modified.\n    \"\"\"\n    action, ref = ActionDescriptor(), ActionReference()\n    ref.putIdentifier(sID(\"layer\"), text_layer.id)\n    action.putReference(sID(\"target\"), ref)\n    action.putObject(sID(\"to\"), sID(\"textLayer\"), text_key)\n    app.executeAction(sID(\"set\"), action, DialogModes.DisplayNoDialogs)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.get_font_size","title":"<code>get_font_size(layer)</code>","text":"<p>Get scale factor adjusted font size of a given text layer. @param layer: Text layer to get size of.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def get_font_size(layer: ArtLayer) -&gt; float:\n    \"\"\"\n    Get scale factor adjusted font size of a given text layer.\n    @param layer: Text layer to get size of.\n    \"\"\"\n    return round(layer.textItem.size * get_text_scale_factor(layer), 2)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.get_line_count","title":"<code>get_line_count(layer=None)</code>","text":"<p>Get the number of lines in a paragraph text layer. @param layer: Text layer that contains a paragraph TextItem. @return: Number of lines in the TextItem.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def get_line_count(layer: Optional[ArtLayer] = None) -&gt; int:\n    \"\"\"\n    Get the number of lines in a paragraph text layer.\n    @param layer: Text layer that contains a paragraph TextItem.\n    @return: Number of lines in the TextItem.\n    \"\"\"\n    return round(pixels_to_points(get_layer_dimensions(layer)['height']) / layer.textItem.leading)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.get_text_key","title":"<code>get_text_key(layer)</code>","text":"<p>Get the textKey action reference from a TextLayer. @param layer: ArtLayer which must be a TextLayer kind.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def get_text_key(layer: ArtLayer) -&gt; Any:\n    \"\"\"\n    Get the textKey action reference from a TextLayer.\n    @param layer: ArtLayer which must be a TextLayer kind.\n    \"\"\"\n    reference = ActionReference()\n    reference.putIdentifier(sID('layer'), layer.id)\n    descriptor = app.executeActionGet(reference)\n    return descriptor.getObjectValue(sID('textKey'))\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.get_text_scale_factor","title":"<code>get_text_scale_factor(layer=None, axis='yy', text_key=None)</code>","text":"<p>Get the scale factor of the document for changing text size. @param layer: The layer to make active and run the check on. @param axis: Scale axis or list of scale axis to check              (xx: horizontal, yy: vertical) @param text_key: textKey action descriptor @return: Float scale factor</p> Source code in <code>src/helpers/text.py</code> <pre><code>def get_text_scale_factor(\n    layer: Optional[ArtLayer] = None,\n    axis: Optional[Union[str, list]] = 'yy',\n    text_key = None\n) -&gt; Union[int, float, list[Union[int, float]]]:\n    \"\"\"\n    Get the scale factor of the document for changing text size.\n    @param layer: The layer to make active and run the check on.\n    @param axis: Scale axis or list of scale axis to check\n                 (xx: horizontal, yy: vertical)\n    @param text_key: textKey action descriptor\n    @return: Float scale factor\n    \"\"\"\n    # Get the textKey if not provided\n    if not text_key:\n        # Get text key\n        text_key = get_text_key(layer)\n\n    # Check for the \"transform\" descriptor\n    if text_key.hasKey(sID('transform')):\n        transform = text_key.getObjectValue(sID('transform'))\n        # Check list of axis\n        if isinstance(axis, list):\n            return [transform.getUnitDoubleValue(sID(n)) for n in axis]\n        # Check string axis\n        if isinstance(axis, str):\n            return transform.getUnitDoubleValue(sID(axis))\n    return 1 if not isinstance(axis, list) else [1] * len(axis)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.remove_leading_text","title":"<code>remove_leading_text(layer, idx)</code>","text":"<p>Remove text up to a certain index from a TextLayer. @param layer: TextLayer containing the text to modify. @param idx: Index to remove up to.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def remove_leading_text(layer: ArtLayer, idx: int) -&gt; None:\n    \"\"\"\n    Remove text up to a certain index from a TextLayer.\n    @param layer: TextLayer containing the text to modify.\n    @param idx: Index to remove up to.\n    \"\"\"\n    # Establish our text key and descriptor ID's\n    app.activeDocument.activeLayer = layer\n    key: ActionDescriptor = get_text_key(layer)\n    current_text = key.getString(sID(\"textKey\"))\n    new_text = current_text[idx + 1:]\n    idFrom = sID(\"from\")\n    idTo = sID(\"to\")\n    offset = idx + 1\n\n    # Find the range where target text exists\n    for n in [sID(\"textStyleRange\"), sID(\"paragraphStyleRange\")]:\n\n        # Iterate over list of style ranges\n        style_ranges: list[ActionDescriptor] = []\n        text_range = key.getList(n)\n        for i in range(text_range.count):\n\n            # Get position of this style range\n            style = text_range.getObjectValue(i)\n            i_left = style.getInteger(idFrom)\n            i_right = style.getInteger(idTo)\n\n            # Compare position to excluded indexes\n            if i_right &lt; idx:\n                # Remove entirely\n                continue\n            elif i_left &lt; idx &lt;= i_right:\n                # Zero \"to\" position\n                style.putInteger(idTo, 0)\n            else:\n                # Offset \"to\" position\n                style.putInteger(idTo, i_left - offset)\n            style.putInteger(idFrom, i_right - offset)\n            style_ranges.append(style)\n\n        # Apply changes\n        style_range = ActionList()\n        for r in style_ranges:\n            style_range.putObject(n, r)\n        key.putList(n, style_range)\n        key.putString(sID(\"textKey\"), new_text)\n    apply_text_key(layer, key)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.remove_trailing_text","title":"<code>remove_trailing_text(layer, idx)</code>","text":"<p>Remove text up to a certain index from a TextLayer. @param layer: TextLayer containing the text to modify. @param idx: Index to remove up to.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def remove_trailing_text(layer: ArtLayer, idx: int) -&gt; None:\n    \"\"\"\n    Remove text up to a certain index from a TextLayer.\n    @param layer: TextLayer containing the text to modify.\n    @param idx: Index to remove up to.\n    \"\"\"\n    # Establish our text key and descriptor ID's\n    app.activeDocument.activeLayer = layer\n    key: ActionDescriptor = get_text_key(layer)\n    current_text = key.getString(sID(\"textKey\"))\n    new_text = current_text[0:idx - 1]\n    idFrom = sID(\"from\")\n    idTo = sID(\"to\")\n\n    # Find the range where target text exists\n    for n in [sID(\"textStyleRange\"), sID(\"paragraphStyleRange\")]:\n\n        # Iterate over list of style ranges\n        style_ranges: list[ActionDescriptor] = []\n        text_range = key.getList(n)\n        for i in range(text_range.count):\n\n            # Get position of this style range\n            style = text_range.getObjectValue(i)\n            i_left = style.getInteger(idFrom)\n            i_right = style.getInteger(idTo)\n\n            if idx &lt;= i_left:\n                # Skip text ouf bounds\n                continue\n            elif i_left &lt; idx &lt;= i_right:\n                # Reduce \"end\" position\n                style.putInteger(idTo, idx - 1)\n            style_ranges.append(style)\n\n        # Apply changes\n        style_range = ActionList()\n        for r in style_ranges:\n            style_range.putObject(n, r)\n        key.putList(n, style_range)\n        key.putString(sID(\"textKey\"), new_text)\n    apply_text_key(layer, key)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.replace_text","title":"<code>replace_text(layer, find, replace)</code>","text":"<p>Replaces target \"find\" text with \"replace\" text in a given TextLayer. @param layer: ArtLayer which must be a TextLayer kind. @param find: Text to find in the layer. @param replace: Text to replace the found text with.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def replace_text(layer: ArtLayer, find: str, replace: str) -&gt; None:\n    \"\"\"\n    Replaces target \"find\" text with \"replace\" text in a given TextLayer.\n    @param layer: ArtLayer which must be a TextLayer kind.\n    @param find: Text to find in the layer.\n    @param replace: Text to replace the found text with.\n    \"\"\"\n    # Establish our text key and reference text\n    text_key: ActionDescriptor = get_text_key(layer)\n    current_text = text_key.getString(sID(\"textKey\"))\n\n    # Check if our target text exists\n    if find not in current_text:\n        print(f\"Text replacement couldn't find the text '{find}' \"\n              f\"in layer with name '{layer.name}'!\")\n        return\n\n    # Track length difference and whether replacement was made\n    offset = len(replace) - len(find)\n    replaced = False\n\n    # Find the range where target text exists\n    style_range = text_key.getList(sID(\"textStyleRange\"))\n    for i in range(style_range.count):\n        style = style_range.getObjectValue(i)\n        id_from = style.getInteger(sID(\"from\"))\n        id_to = style.getInteger(sID(\"to\"))\n        text = current_text[id_from: id_to]\n        if not replaced and find in text:\n            replaced = True\n            style.putInteger(sID(\"to\"), id_to + offset)\n            style_range.putObject(sID(\"textStyleRange\"), style)\n        elif replaced:\n            style.putInteger(sID(\"from\"), id_from + offset)\n            style.putInteger(sID(\"to\"), id_to + offset)\n            style_range.putObject(sID(\"textStyleRange\"), style)\n\n    # Skip applying changes if no replacement could be made\n    if not replaced:\n        print(f\"Text replacement couldn't find the text '{find}' \"\n              f\"in layer with name '{layer.name}'!\")\n        return\n\n    # Apply changes\n    text_key.putString(sID(\"textKey\"), current_text.replace(find, replace))\n    text_key.putList(sID(\"textStyleRange\"), style_range)\n    apply_text_key(layer, text_key)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.replace_text_robust","title":"<code>replace_text_robust(layer, find, replace, targeted_replace=True)</code>","text":"<p>Replace all instances of <code>replace_this</code> in the specified layer with <code>replace_with</code>, using Photoshop's built-in search and replace feature. Slower than <code>replace_text</code>, but can handle multi-style strings. @param layer: Layer object to search through. @param find: Text string to search for. @param replace: Text string to replace matches with. @param targeted_replace: Disables layer targeting if False, if True may cause a crash on older PS versions.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def replace_text_robust(layer: ArtLayer, find: str, replace: str, targeted_replace: bool = True) -&gt; None:\n    \"\"\"\n    Replace all instances of `replace_this` in the specified layer with `replace_with`, using Photoshop's\n    built-in search and replace feature. Slower than `replace_text`, but can handle multi-style strings.\n    @param layer: Layer object to search through.\n    @param find: Text string to search for.\n    @param replace: Text string to replace matches with.\n    @param targeted_replace: Disables layer targeting if False, if True may cause a crash on older PS versions.\n    \"\"\"\n    # Set the active layer\n    app.activeDocument.activeLayer = layer\n\n    # Find and replace\n    desc31 = ActionDescriptor()\n    ref3 = ActionReference()\n    desc32 = ActionDescriptor()\n    ref3.putProperty(sID(\"property\"), sID(\"findReplace\"))\n    ref3.putEnumerated(sID(\"textLayer\"), sID(\"ordinal\"), sID(\"targetEnum\"))\n    desc31.putReference(sID(\"target\"), ref3)\n    desc32.putString(sID(\"find\"), f\"\"\"{find}\"\"\")\n    desc32.putString(sID(\"replace\"), f\"\"\"{replace}\"\"\")\n    desc32.putBoolean(\n        sID(\"checkAll\"),  # Targeted replace doesn't work on old PS versions\n        False if targeted_replace and app.supports_target_text_replace() else True\n    )\n    desc32.putBoolean(sID(\"forward\"), True)\n    desc32.putBoolean(sID(\"caseSensitive\"), True)\n    desc32.putBoolean(sID(\"wholeWord\"), False)\n    desc32.putBoolean(sID(\"ignoreAccents\"), True)\n    desc31.putObject(sID(\"using\"), sID(\"findReplace\"), desc32)\n    try:\n        app.executeAction(sID(\"findReplace\"), desc31, NO_DIALOG)\n    except PS_EXCEPTIONS:\n        replace_text_robust(layer, find, replace, False)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.set_composer_single_line","title":"<code>set_composer_single_line(layer)</code>","text":"<p>Set text layer to single line composer. @param layer: Layer containing TextItem to set composer for.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def set_composer_single_line(layer: ArtLayer) -&gt; None:\n    \"\"\"\n    Set text layer to single line composer.\n    @param layer: Layer containing TextItem to set composer for.\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    desc2 = ActionDescriptor()\n    ref1.putProperty(sID(\"property\"), sID(\"textStyle\"))\n    ref1.putIdentifier(sID(\"textLayer\"), layer.id)\n    desc1.putReference(sID(\"target\"), ref1)\n    desc2.PutInteger(sID(\"textOverrideFeatureName\"),  808464691)\n    desc2.PutBoolean(sID(\"textEveryLineComposer\"), False)\n    desc1.PutObject(sID(\"to\"), sID(\"paragraphStyle\"),  desc2)\n    app.Executeaction(sID(\"set\"), desc1,  NO_DIALOG)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.set_font","title":"<code>set_font(layer, font_name)</code>","text":"<p>Set the font of a given TextItem layer using a given name. @param layer: ArtLayer containing TextItem. @param font_name:  Name of the font to set.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def set_font(layer: ArtLayer, font_name: str) -&gt; None:\n    \"\"\"\n    Set the font of a given TextItem layer using a given name.\n    @param layer: ArtLayer containing TextItem.\n    @param font_name:  Name of the font to set.\n    \"\"\"\n    layer.textItem.font = app.fonts.getByName(font_name).postScriptName\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.set_text_leading","title":"<code>set_text_leading(layer, size)</code>","text":"<p>Manually assign font leading to a layer using action descriptors. @param layer: Layer containing TextItem to change leading of. @param size: New textItem font leading.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def set_text_leading(layer: ArtLayer, size: Union[float, int]) -&gt; None:\n    \"\"\"\n    Manually assign font leading to a layer using action descriptors.\n    @param layer: Layer containing TextItem to change leading of.\n    @param size: New textItem font leading.\n    \"\"\"\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    desc2 = ActionDescriptor()\n    ref1.putProperty(sID(\"property\"), sID(\"textStyle\"))\n    ref1.putIdentifier(sID(\"textLayer\"), layer.id)\n    desc1.putReference(sID(\"target\"), ref1)\n    desc2.putInteger(sID(\"textOverrideFeatureName\"), 808465461)\n    desc2.putInteger(sID(\"typeStyleOperationType\"), 3)\n    desc2.putUnitDouble(sID(\"leading\"), sID(\"pointsUnit\"), size)\n    desc1.putObject(sID(\"to\"), sID(\"textStyle\"), desc2)\n    app.executeaction(sID(\"set\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"helpers/text/#src.helpers.text.set_text_size","title":"<code>set_text_size(layer, size)</code>","text":"<p>Manually assign font size to a layer using action descriptors. @param layer: Layer containing TextItem to change size of. @param size: New textItem font size.</p> Source code in <code>src/helpers/text.py</code> <pre><code>def set_text_size(layer: ArtLayer, size: Union[float, int]) -&gt; None:\n    \"\"\"\n    Manually assign font size to a layer using action descriptors.\n    @param layer: Layer containing TextItem to change size of.\n    @param size: New textItem font size.\n    \"\"\"\n    # Set the new size\n    desc1 = ActionDescriptor()\n    ref1 = ActionReference()\n    desc2 = ActionDescriptor()\n    ref1.putProperty(sID(\"property\"), sID(\"textStyle\"))\n    ref1.putIdentifier(sID(\"textLayer\"), layer.id)\n    desc1.putReference(sID(\"target\"), ref1)\n    desc2.putInteger(sID(\"textOverrideFeatureName\"), 808465458)\n    desc2.putInteger(sID(\"typeStyleOperationType\"), 3)\n    desc2.putUnitDouble(sID(\"size\"), sID(\"pointsUnit\"), size)\n    desc1.putObject(sID(\"to\"), sID(\"textStyle\"), desc2)\n    app.ExecuteAction(sID(\"set\"), desc1, NO_DIALOG)\n</code></pre>"},{"location":"utils/build/","title":"Build","text":"<ul> <li>APP BUILD SCRIPT</li> </ul>"},{"location":"utils/build/#src.utils.build.DST","title":"<code>DST: Path = Path(SRC, 'dist')</code>  <code>module-attribute</code>","text":"<p>HANDLING APP FILES</p>"},{"location":"utils/build/#src.utils.build.build_app","title":"<code>build_app(version=None, beta=False, console=False, raw=False)</code>","text":"<p>Build Proxyshop as an executable release.</p> Source code in <code>src/utils/build.py</code> <pre><code>@build_cli.command()\n@click.argument('version', required=False)\n@click.option('-B', '--beta', is_flag=True, default=False, help=\"Build app as a Beta release.\")\n@click.option('-C', '--console', is_flag=True, default=False, help=\"Build app with console enabled.\")\n@click.option('-R', '--raw', is_flag=True, default=False, help=\"Build app without creating ZIP.\")\ndef build_app(version: Optional[str] = None, beta: bool = False, console: bool = False, raw: bool = False):\n    \"\"\"Build Proxyshop as an executable release.\"\"\"\n    build_app(version=version, beta=beta, console=console, zipped=not raw)\n</code></pre>"},{"location":"utils/build/#src.utils.build.build_cli","title":"<code>build_cli()</code>","text":"<p>App build tools CLI.</p> Source code in <code>src/utils/build.py</code> <pre><code>@click.group()\ndef build_cli():\n    \"\"\"App build tools CLI.\"\"\"\n    pass\n</code></pre>"},{"location":"utils/build/#src.utils.build.build_zip","title":"<code>build_zip(filename)</code>","text":"<p>Create a zip of this release. @filename: Filename to use on zip archive.</p> Source code in <code>src/utils/build.py</code> <pre><code>def build_zip(filename: str) -&gt; None:\n    \"\"\"\n    Create a zip of this release.\n    @filename: Filename to use on zip archive.\n    \"\"\"\n    ZIP_SRC = osp.join(SRC, filename)\n    with zipfile.ZipFile(ZIP_SRC, \"w\", zipfile.ZIP_DEFLATED) as zipf:\n        for fp in glob(osp.join(DST, \"**/*\"), recursive=True):\n            zipf.write(fp, arcname=fp.replace(\n                osp.commonpath([DST, fp]), \"\"))\n    move(ZIP_SRC, osp.join(DST, filename))\n</code></pre>"},{"location":"utils/build/#src.utils.build.clear_build_files","title":"<code>clear_build_files(clear_dist=True)</code>","text":"<p>Clean out pycache and venv cache, remove previous build files. @param clear_dist: Remove previous dist directory if True, otherwise skip.</p> Source code in <code>src/utils/build.py</code> <pre><code>def clear_build_files(clear_dist: bool = True) -&gt; None:\n    \"\"\"\n    Clean out __pycache__ and venv cache, remove previous build files.\n    @param clear_dist: Remove previous dist directory if True, otherwise skip.\n    \"\"\"\n    # Run pyclean on main directory and venv\n    os.system(\"pyclean -v .\")\n    if osp.exists(osp.join(SRC, '.venv')):\n        os.system(\"pyclean -v .venv\")\n\n    # Remove build directory\n    with suppress(Exception):\n        rmtree(osp.join(SRC, 'build'))\n\n    # Optionally remove dist directory\n    if clear_dist:\n        with suppress(Exception):\n            rmtree(osp.join(SRC, 'dist'))\n</code></pre>"},{"location":"utils/build/#src.utils.build.copy_app_files","title":"<code>copy_app_files(config)</code>","text":"<p>Copy necessary app files and directories. @param config: TOML config data.</p> Source code in <code>src/utils/build.py</code> <pre><code>def copy_app_files(config: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Copy necessary app files and directories.\n    @param config: TOML config data.\n    \"\"\"\n    for _, DIR in config.get('copy', {}).items():\n        # Copy directories\n        for path in DIR.get('paths', []):\n            copy_directory(\n                src=osp.join(SRC, path),\n                dst=osp.join(DST, path),\n                x_files=DIR.get('exclude_files', []),\n                x_dirs=DIR.get('exclude_dirs', []),\n                x_ext=DIR.get('exclude_ext', []),\n                recursive=bool(DIR.get('recursive', True)))\n        # Copy files\n        for file in DIR.get('files', []):\n            copy2(\n                src=osp.join(SRC, file),\n                dst=osp.join(DST, file))\n</code></pre>"},{"location":"utils/build/#src.utils.build.copy_directory","title":"<code>copy_directory(src, dst, x_files, x_dirs, x_ext=None, recursive=True)</code>","text":"<p>Copy a directory from src to dst. @param src: Source directory to copy this directory from. @param dst: Destination directory to copy this directory to. @param x_files: Excluded file names. @param x_dirs: Excluded directory names. @param x_ext: Excluded extensions. @param recursive: Will exclude all subdirectories if False.</p> Source code in <code>src/utils/build.py</code> <pre><code>def copy_directory(\n    src: str, dst: str,\n    x_files: list[str],\n    x_dirs: list[str],\n    x_ext: Optional[list[str]] = None,\n    recursive: bool = True\n) -&gt; None:\n    \"\"\"\n    Copy a directory from src to dst.\n    @param src: Source directory to copy this directory from.\n    @param dst: Destination directory to copy this directory to.\n    @param x_files: Excluded file names.\n    @param x_dirs: Excluded directory names.\n    @param x_ext: Excluded extensions.\n    @param recursive: Will exclude all subdirectories if False.\n    \"\"\"\n    # Set empty lists for None value\n    x_files = x_files or []\n    x_dirs = x_dirs or []\n    x_ext = x_ext or []\n\n    def _ignore(path: str, names: list[str]):\n        \"\"\"\n        Return a list of files to ignore based on our exclusion criteria.\n        @param path: Path to these files.\n        @names: Names of these files.\n        \"\"\"\n        ignored: list[str] = []\n        for name in names:\n            # Ignore certain names and extensions\n            p = Path(path, name)\n            if name in x_files or p.suffix in x_ext:\n                ignored.append(name)\n            # Ignore certain directories\n            elif (name in x_dirs or not recursive) and osp.isdir(osp.join(path, name)):\n                ignored.append(name)\n        return set(ignored)\n\n    # Copy the directory\n    copytree(src, dst, ignore=_ignore)\n</code></pre>"},{"location":"utils/build/#src.utils.build.make_directories","title":"<code>make_directories(config)</code>","text":"<p>Make sure necessary directories exist. @param config: TOML config data.</p> Source code in <code>src/utils/build.py</code> <pre><code>def make_directories(config: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Make sure necessary directories exist.\n    @param config: TOML config data.\n    \"\"\"\n    DST.mkdir(mode=711, parents=True, exist_ok=True)\n    for path in config['make']['paths']:\n        Path(DST, path).mkdir(mode=711, parents=True, exist_ok=True)\n</code></pre>"},{"location":"utils/compression/","title":"Compression","text":""},{"location":"utils/compression/#src.utils.compression.DictionarySize","title":"<code>DictionarySize</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Dictionary Size for 7z compression.</p> Source code in <code>src/utils/compression.py</code> <pre><code>class DictionarySize(StrEnum):\n    \"\"\"Dictionary Size for 7z compression.\"\"\"\n    DS32 = \"32\"\n    DS48 = \"48\"\n    DS64 = \"64\"\n    DS96 = \"96\"\n    DS128 = \"128\"\n    DS192 = \"192\"\n    DS256 = \"256\"\n    DS384 = \"384\"\n    DS512 = \"512\"\n    DS768 = \"768\"\n    DS1024 = \"1024\"\n    DS1536 = \"1536\"\n</code></pre>"},{"location":"utils/compression/#src.utils.compression.WordSize","title":"<code>WordSize</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Word Size for 7z compression.</p> Source code in <code>src/utils/compression.py</code> <pre><code>class WordSize(StrEnum):\n    \"\"\"Word Size for 7z compression.\"\"\"\n    WS16 = \"16\"\n    WS24 = \"24\"\n    WS32 = \"32\"\n    WS48 = \"48\"\n    WS64 = \"64\"\n    WS96 = \"96\"\n    WS128 = \"128\"\n</code></pre>"},{"location":"utils/compression/#src.utils.compression.compress_all_templates","title":"<code>compress_all_templates()</code>","text":"<p>Compress all app templates.</p> Source code in <code>src/utils/compression.py</code> <pre><code>def compress_all_templates():\n    \"\"\"Compress all app templates.\"\"\"\n    # Compress base templates\n    compress_all(con.path_templates)\n\n    # Compress plugin templates\n    _ = [compress_plugin(p) for p in ['MrTeferi', 'SilvanMTG']]\n</code></pre>"},{"location":"utils/compression/#src.utils.compression.compress_cli","title":"<code>compress_cli()</code>","text":"<p>File utilities CLI.</p> Source code in <code>src/utils/compression.py</code> <pre><code>@click.group()\ndef compress_cli():\n    \"\"\"File utilities CLI.\"\"\"\n    pass\n</code></pre>"},{"location":"utils/compression/#src.utils.compression.compress_file","title":"<code>compress_file(file_path, output_dir)</code>","text":"<p>Compress a target file and save it as a 7z archive to the output directory. @param file_path: File to compress. @param output_dir: Directory to save archive to. @return: True if compression succeeded, otherwise False.</p> Source code in <code>src/utils/compression.py</code> <pre><code>def compress_file(file_path: Union[str, os.PathLike], output_dir: Union[str, os.PathLike]) -&gt; bool:\n    \"\"\"\n    Compress a target file and save it as a 7z archive to the output directory.\n    @param file_path: File to compress.\n    @param output_dir: Directory to save archive to.\n    @return: True if compression succeeded, otherwise False.\n    \"\"\"\n    # Define the output file path\n    filename = osp.basename(file_path).replace('.psd', '.7z')\n    out_file = Path(output_dir, filename)\n    null_device = open(os.devnull, 'w')\n\n    # Compress the file\n    try:\n        subprocess.run([\n                \"7z\", \"a\", \"-t7z\", \"-m0=LZMA\", \"-mx=9\",\n                f\"-md={DictionarySize.DS96}M\",\n                f\"-mfb={WordSize.WS24}\",\n                str(out_file), str(file_path)\n            ], stdout=null_device, stderr=null_device)\n    except Exception as e:\n        # console.critical(\"An error occurred compressing file!\", exc_info=e)\n        return False\n    return True\n</code></pre>"},{"location":"utils/compression/#src.utils.compression.decompress_file","title":"<code>decompress_file(file_path)</code>","text":"<p>Decompress target 7z archive. @param file_path: Path to the 7z archive.</p> Source code in <code>src/utils/compression.py</code> <pre><code>def decompress_file(file_path: Union[str, os.PathLike]) -&gt; None:\n    \"\"\"\n    Decompress target 7z archive.\n    @param file_path: Path to the 7z archive.\n    \"\"\"\n    with py7zr.SevenZipFile(file_path, 'r') as archive:\n        archive.extractall(path=osp.dirname(file_path))\n    os.remove(file_path)\n</code></pre>"},{"location":"utils/decorators/","title":"Decorators","text":"<ul> <li>UTILITY DECORATORS</li> </ul>"},{"location":"utils/decorators/#src.utils.decorators.enum_class_prop","title":"<code>enum_class_prop</code>","text":"<p>A decorator for creating a static property for Enum classes.</p> Source code in <code>src/utils/decorators.py</code> <pre><code>class enum_class_prop:\n    \"\"\"A decorator for creating a static property for Enum classes.\"\"\"\n\n    def __init__(self, method: Callable):\n        \"\"\"\n        Initializes the property.\n        @param method: Class method being decorated.\n        \"\"\"\n        self._method = method\n        self._name = method.__name__\n\n    def __get__(self, instance, owner):\n        \"\"\"\n        Computes and caches the value of a property when accessed.\n        @param instance: Instance of the class where descriptor is accessed.\n        @param owner: The class that the descriptor exists on.\n        @return: The cached value.\n        \"\"\"\n        value = self._method(owner)\n        setattr(owner, self._name, value)\n        return value\n</code></pre>"},{"location":"utils/decorators/#src.utils.decorators.enum_class_prop.__get__","title":"<code>__get__(instance, owner)</code>","text":"<p>Computes and caches the value of a property when accessed. @param instance: Instance of the class where descriptor is accessed. @param owner: The class that the descriptor exists on. @return: The cached value.</p> Source code in <code>src/utils/decorators.py</code> <pre><code>def __get__(self, instance, owner):\n    \"\"\"\n    Computes and caches the value of a property when accessed.\n    @param instance: Instance of the class where descriptor is accessed.\n    @param owner: The class that the descriptor exists on.\n    @return: The cached value.\n    \"\"\"\n    value = self._method(owner)\n    setattr(owner, self._name, value)\n    return value\n</code></pre>"},{"location":"utils/decorators/#src.utils.decorators.enum_class_prop.__init__","title":"<code>__init__(method)</code>","text":"<p>Initializes the property. @param method: Class method being decorated.</p> Source code in <code>src/utils/decorators.py</code> <pre><code>def __init__(self, method: Callable):\n    \"\"\"\n    Initializes the property.\n    @param method: Class method being decorated.\n    \"\"\"\n    self._method = method\n    self._name = method.__name__\n</code></pre>"},{"location":"utils/decorators/#src.utils.decorators.auto_prop","title":"<code>auto_prop(func)</code>","text":"<p>Property decorator wrapper that automatically creates a setter.</p> Source code in <code>src/utils/decorators.py</code> <pre><code>def auto_prop(func: Callable) -&gt; property:\n    \"\"\"Property decorator wrapper that automatically creates a setter.\"\"\"\n    attr_type = func.__annotations__.get('return', str) if (\n        hasattr(func, '__annotations__')) else str\n    auto_name = f\"_{func.__name__}\"\n\n    def getter(self) -&gt; attr_type:\n        \"\"\"Getter for retrieving the value of the implied attribute.\"\"\"\n        return getattr(self, auto_name)\n\n    def setter(self, value: attr_type) -&gt; None:\n        \"\"\"Setter for changing the value of the implied attribute.\"\"\"\n        setattr(self, auto_name, value)\n\n    # Return complete property\n    return property(getter, setter, doc=func.__doc__)\n</code></pre>"},{"location":"utils/decorators/#src.utils.decorators.auto_prop_cached","title":"<code>auto_prop_cached(func)</code>","text":"<p>Property decorator wrapper automatically creates a setter and caches the value.</p> Source code in <code>src/utils/decorators.py</code> <pre><code>def auto_prop_cached(func: Callable) -&gt; property:\n    \"\"\"Property decorator wrapper automatically creates a setter and caches the value.\"\"\"\n    attr_type = func.__annotations__.get('return', str) if (\n        hasattr(func, '__annotations__')) else str\n    cache_name = f\"_{func.__name__}\"\n\n    def getter(self) -&gt; attr_type:\n        \"\"\"Wrapper for getting cached value. If value doesn't exist, initialize it.\"\"\"\n        try:\n            return getattr(self, cache_name)\n        except AttributeError:\n            value = func(self)\n            setattr(self, cache_name, value)\n            return value\n\n    def setter(self, value: attr_type) -&gt; None:\n        \"\"\"Setter for invalidating the property cache and caching a new value.\"\"\"\n        setattr(self, cache_name, value)\n\n    def deleter(self) -&gt; None:\n        \"\"\"Deleter for invalidating the property cache.\"\"\"\n        if hasattr(self, cache_name):\n            delattr(self, cache_name)\n\n    # Return complete property\n    return property(getter, setter, deleter, getattr(func, '__doc__', \"\"))\n</code></pre>"},{"location":"utils/decorators/#src.utils.decorators.choose_class_route","title":"<code>choose_class_route(condition)</code>","text":"<p>A decorator that routes a method call to the current class or its parent based on a bool condition. @param condition: Route to self if True, otherwise route to self's superclass. @return: The wrapped function.</p> Source code in <code>src/utils/decorators.py</code> <pre><code>def choose_class_route(condition: bool) -&gt; Callable:\n    \"\"\"\n    A decorator that routes a method call to the current class or its parent based on a bool condition.\n    @param condition: Route to self if True, otherwise route to self's superclass.\n    @return: The wrapped function.\n    \"\"\"\n    def decorator(func):\n        def wrapper(self, *args, **kwargs):\n            if condition:\n                return func(self, *args, **kwargs)\n            return getattr(super(self.__class__, self), func.__name__)(*args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"utils/decorators/#src.utils.decorators.suppress_and_return","title":"<code>suppress_and_return(return_val)</code>","text":"<p>If an exception occurs within decorated function, suppress it and return given value. @param return_val: Value to return if exception is encountered.</p> Source code in <code>src/utils/decorators.py</code> <pre><code>def suppress_and_return(return_val: Any) -&gt; Callable:\n    \"\"\"\n    If an exception occurs within decorated function, suppress it and return given value.\n    @param return_val: Value to return if exception is encountered.\n    \"\"\"\n    def decorator(func):\n        def wrapper(self, *args, **kwargs):\n            with suppress(Exception):\n                return func(self, *args, **kwargs)\n            return return_val\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"utils/dicts/","title":"Dicts","text":"<ul> <li>Dictionary Utils</li> </ul>"},{"location":"utils/dicts/#src.utils.dicts.dict_first","title":"<code>dict_first(d)</code>","text":"<p>Extract the first key, value pair from a dictionary. @param d: Dictionary to retrieve first key, value pair from. @return: Tuple containing key, value.</p> Source code in <code>src/utils/dicts.py</code> <pre><code>def dict_first(d: dict) -&gt; tuple[Hashable, Any]:\n    \"\"\"\n    Extract the first key, value pair from a dictionary.\n    @param d: Dictionary to retrieve first key, value pair from.\n    @return: Tuple containing key, value.\n    \"\"\"\n    return next(iter(d.items()))\n</code></pre>"},{"location":"utils/dicts/#src.utils.dicts.dict_last","title":"<code>dict_last(d)</code>","text":"<p>Extract the last key, value pair from a dictionary. @param d: Dictionary to retrieve last key, value pair from. @return: Tuple containing key, value.</p> Source code in <code>src/utils/dicts.py</code> <pre><code>def dict_last(d: dict) -&gt; tuple[Hashable, Any]:\n    \"\"\"\n    Extract the last key, value pair from a dictionary.\n    @param d: Dictionary to retrieve last key, value pair from.\n    @return: Tuple containing key, value.\n    \"\"\"\n    return list(d.items())[-1]\n</code></pre>"},{"location":"utils/dicts/#src.utils.dicts.dict_sort_by_key","title":"<code>dict_sort_by_key(d, reverse=False)</code>","text":"<p>Sort a dictionary by its key. @param d: Dictionary to sort by its key. @param reverse: Whether to reverse the sorting order. @return: Key sorted dictionary.</p> Source code in <code>src/utils/dicts.py</code> <pre><code>def dict_sort_by_key(d: dict, reverse: bool = False) -&gt; dict:\n    \"\"\"\n    Sort a dictionary by its key.\n    @param d: Dictionary to sort by its key.\n    @param reverse: Whether to reverse the sorting order.\n    @return: Key sorted dictionary.\n    \"\"\"\n    return dict(sorted(d.items(), reverse=reverse))\n</code></pre>"},{"location":"utils/dicts/#src.utils.dicts.dict_sort_by_val","title":"<code>dict_sort_by_val(d, reverse=False)</code>","text":"<p>Sort a dictionary by its value. @param d: Dictionary to sort by its value. @param reverse: Whether to reverse the sorting order. @return: Value sorted dictionary.</p> Source code in <code>src/utils/dicts.py</code> <pre><code>def dict_sort_by_val(d: dict, reverse: bool = False) -&gt; dict:\n    \"\"\"\n    Sort a dictionary by its value.\n    @param d: Dictionary to sort by its value.\n    @param reverse: Whether to reverse the sorting order.\n    @return: Value sorted dictionary.\n    \"\"\"\n    return dict(sorted(d.items(), key=lambda item: item[1], reverse=reverse))\n</code></pre>"},{"location":"utils/dicts/#src.utils.dicts.reverse_dict","title":"<code>reverse_dict(d)</code>","text":"<p>Flips the key, val in a dictionary to val, key. @param d: Dictionary where the values are hashable. @return: Reversed dictionary.</p> Source code in <code>src/utils/dicts.py</code> <pre><code>def reverse_dict(d: dict[Hashable, Hashable]) -&gt; dict[Hashable, Hashable]:\n    \"\"\"\n    Flips the key, val in a dictionary to val, key.\n    @param d: Dictionary where the values are hashable.\n    @return: Reversed dictionary.\n    \"\"\"\n    inverted = {}\n    for k, v in d.items():\n        inverted.setdefault(v, k)\n    return inverted\n</code></pre>"},{"location":"utils/dicts/#src.utils.dicts.reverse_dict_safe","title":"<code>reverse_dict_safe(d)</code>","text":"<p>Flips the key, val in a dictionary to val, [keys], preserving cases where the same value is mapped to multiple keys. @param d: Dictionary where the values are hashable. @return: Reversed dictionary.</p> Source code in <code>src/utils/dicts.py</code> <pre><code>def reverse_dict_safe(d: dict[Hashable, Hashable]) -&gt; dict[Hashable, Hashable]:\n    \"\"\"\n    Flips the key, val in a dictionary to val, [keys], preserving cases where the same\n    value is mapped to multiple keys.\n    @param d: Dictionary where the values are hashable.\n    @return: Reversed dictionary.\n    \"\"\"\n    inverted = {}\n    for k, v in d.items():\n        inverted.setdefault(v, []).append(k)\n    return inverted\n</code></pre>"},{"location":"utils/download/","title":"Download","text":"<p>Borrows from Gdown Project Source: https://github.com/wkentaro/gdown License: https://github.com/wkentaro/gdown/blob/main/LICENSE</p>"},{"location":"utils/download/#src.utils.download.check_for_updates","title":"<code>check_for_updates(templates=None)</code>","text":"<p>Check our app and plugin manifests for template updates. @param templates: Dict of listed template details, will pull them if not provided. @return: Dict containing templates that need an update.</p> Source code in <code>src/utils/download.py</code> <pre><code>def check_for_updates(\n    templates: Optional[dict[str, list[TemplateDetails]]] = None\n) -&gt; dict[str, list[TemplateUpdate]]:\n    \"\"\"\n    Check our app and plugin manifests for template updates.\n    @param templates: Dict of listed template details, will pull them if not provided.\n    @return: Dict containing templates that need an update.\n    \"\"\"\n    # Set up our updates return\n    updates: dict[str, list[TemplateUpdate]] = {}\n\n    # Get templates if not provided\n    if not templates:\n        templates = get_templates()\n\n    # Check for an update on each template\n    unique_temps = []\n    for card_type, temps in templates.items():\n        for template in temps:\n            if template['id'] not in unique_temps and template['id']:\n                unique_temps.append(template)\n\n    # Perform threaded version check requests\n    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:\n        results: Iterator[TemplateUpdate] = executor.map(version_check, unique_temps)\n\n    # Ensure executor is finished before building return\n    results: list[TemplateUpdate] = list(results)\n    for temp in results:\n        if temp:\n            updates.setdefault(temp['type'], []).append(temp)\n    return updates\n</code></pre>"},{"location":"utils/download/#src.utils.download.download_file","title":"<code>download_file(file, res, sess, path=None, callback=None, chunk_size=1024 * 1024)</code>","text":"<p>Download file as a temporary file, then rename to its correct filename. @param file: File path to download to. @param res: Download request. @param sess: Download session. @param path: Final path to save the completed temporary file. @param callback: Callback to update download progress. @param chunk_size: Amount of bytes to download before processing the callback. @return: True if download completed without error, otherwise False.</p> Source code in <code>src/utils/download.py</code> <pre><code>def download_file(\n    file: Union[str, os.PathLike],\n    res: requests.Response,\n    sess: requests.Session,\n    path: Union[str, os.PathLike, None] = None,\n    callback: Optional[Callable] = None,\n    chunk_size = 1024 * 1024\n) -&gt; bool:\n    \"\"\"\n    Download file as a temporary file, then rename to its correct filename.\n    @param file: File path to download to.\n    @param res: Download request.\n    @param sess: Download session.\n    @param path: Final path to save the completed temporary file.\n    @param callback: Callback to update download progress.\n    @param chunk_size: Amount of bytes to download before processing the callback.\n    @return: True if download completed without error, otherwise False.\n    \"\"\"\n    # Ensure a proper chunk_size\n    if not chunk_size or not isinstance(chunk_size, int):\n        chunk_size = 1024 * 1024\n\n    # Try to download the file\n    total = int(res.headers.get(\"Content-Length\") or 1)\n    current = int(osp.getsize(file))\n    try:\n        with open(file, \"ab\") as f:\n            for chunk in res.iter_content(chunk_size=chunk_size):\n                f.write(chunk)\n                if callback:\n                    current += int(chunk_size)\n                    callback(current, total)\n        if path and str(file) != str(path):\n            # Rename TMP file\n            shutil.move(file, path)\n            # Decompress zipped file\n            if str(path)[-3:] == '.7z':\n                with con.lock_decompress:\n                    decompress_file(path)\n    except IOError as e:\n        print(e, file=sys.stderr)\n        return False\n    finally:\n        # Close the session\n        sess.close()\n    return True\n</code></pre>"},{"location":"utils/download/#src.utils.download.download_google","title":"<code>download_google(file_id, path, callback, use_cookies=True)</code>","text":"<p>Download a file from Google Drive using its file ID. @param file_id: Google Drive file ID. @param path: Path to save downloaded file. @param callback: Function to call on each chunk downloaded. @param use_cookies: Use cookies with request if True. @return: True if successful, otherwise False.</p> Source code in <code>src/utils/download.py</code> <pre><code>def download_google(\n    file_id: str,\n    path: Union[str, os.PathLike],\n    callback: Callable,\n    use_cookies: bool = True\n) -&gt; bool:\n    \"\"\"\n    Download a file from Google Drive using its file ID.\n    @param file_id: Google Drive file ID.\n    @param path: Path to save downloaded file.\n    @param callback: Function to call on each chunk downloaded.\n    @param use_cookies: Use cookies with request if True.\n    @return: True if successful, otherwise False.\n    \"\"\"\n    Path(osp.dirname(Path(path))).mkdir(mode=711, parents=True, exist_ok=True)\n    url = \"https://drive.google.com/uc?id={id}\".format(id=file_id)\n    url_origin = url\n    sess = requests.session()\n    header = con.http_header.copy()\n\n    # Cookies\n    cookies_file = osp.join(con.path_logs, \"cookies.json\")\n    if osp.exists(cookies_file) and use_cookies:\n        with open(cookies_file) as f:\n            cookies = json.load(f)\n        for k, v in cookies:\n            sess.cookies[k] = v\n\n    # Get file resource\n    while True:\n        res = sess.get(url, headers=header, stream=True, verify=True)\n\n        # Save cookies\n        with open(cookies_file, \"w\") as f:\n            cookies = [\n                (k, v)\n                for k, v in sess.cookies.items()\n                if not k.startswith(\"download_warning_\")\n            ]\n            json.dump(cookies, f, indent=2)\n\n        # Is this the right file?\n        if \"Content-Disposition\" in res.headers:\n            break\n\n        # Need to redirect with confirmation\n        try:\n            url = get_url_from_gdrive_confirmation(res.text)\n        except RuntimeError as e:\n            print(\"Access denied with the following error:\")\n            error = \"\\n\".join(textwrap.wrap(str(e)))\n            print(\"\\n\", error, \"\\n\", file=sys.stderr)\n            print(\n                \"You may still be able to access the file from the browser:\",\n                file=sys.stderr,\n            )\n            print(\"\\n\\t\", url_origin, \"\\n\", file=sys.stderr)\n            return False\n\n    # Get temp file\n    file, current, res = get_temp_file(res, sess, path, url)\n\n    # Let the user know its downloading\n    print_download(url_origin, path, file if current != 0 else None)\n\n    # Start the download\n    return download_file(file, res, sess, path, callback)\n</code></pre>"},{"location":"utils/download/#src.utils.download.download_s3","title":"<code>download_s3(save_path, s3_path, callback=None)</code>","text":"<p>Download template from Amazon S3 bucket. @param save_path: Path to save the file to. @param s3_path: Filepath key on S3 bucket. @param callback: Callback function to update progress. @return: True if success, False if failed.</p> Source code in <code>src/utils/download.py</code> <pre><code>def download_s3(save_path: Union[str, os.PathLike], s3_path: str, callback: Optional[Callable] = None) -&gt; bool:\n    \"\"\"\n    Download template from Amazon S3 bucket.\n    @param save_path: Path to save the file to.\n    @param s3_path: Filepath key on S3 bucket.\n    @param callback: Callback function to update progress.\n    @return: True if success, False if failed.\n    \"\"\"\n    # Establish this object's cloudfront URL\n    url = f\"{ENV.API_AMAZON}/{s3_path}\"\n\n    # Establish session\n    sess = requests.session()\n    header = con.http_header.copy()\n    res = sess.get(url, headers=header, stream=True, verify=True)\n\n    # Get temp file\n    file, current, res = get_temp_file(res, sess, save_path, url)\n\n    # Let the user know its downloading\n    print_download(url, save_path, file if current != 0 else None)\n\n    # Start the download\n    return download_file(file, res, sess, save_path, callback)\n</code></pre>"},{"location":"utils/download/#src.utils.download.gdrive_metadata","title":"<code>gdrive_metadata(file_id)</code>","text":"<p>Get the metadata of a given template file. @param file_id: ID of the Google Drive file @return: Dict of metadata</p> Source code in <code>src/utils/download.py</code> <pre><code>def gdrive_metadata(file_id: str) -&gt; dict:\n    \"\"\"\n    Get the metadata of a given template file.\n    @param file_id: ID of the Google Drive file\n    @return: Dict of metadata\n    \"\"\"\n    result = requests.get(\n        f\"https://www.googleapis.com/drive/v3/files/{file_id}\",\n        headers=con.http_header,\n        params={\n            'alt': 'json',\n            'fields': 'description,name,size',\n            'key': ENV.API_GOOGLE\n        }\n    ).json()\n    return result if 'name' in result and 'size' in result else None\n</code></pre>"},{"location":"utils/download/#src.utils.download.get_current_version","title":"<code>get_current_version(file_id, file_path)</code>","text":"<p>Checks the current on-file version of this template. If the file is present, but no version tracked, fill in default. @param file_id: Google Drive file ID. @param file_path: Path to the template PSD. @return: The current version, or None if not on-file.</p> Source code in <code>src/utils/download.py</code> <pre><code>def get_current_version(file_id: str, file_path: Union[str, os.PathLike]) -&gt; Optional[str]:\n    \"\"\"\n    Checks the current on-file version of this template.\n    If the file is present, but no version tracked, fill in default.\n    @param file_id: Google Drive file ID.\n    @param file_path: Path to the template PSD.\n    @return: The current version, or None if not on-file.\n    \"\"\"\n    # Is it logged in the tracker?\n    version = con.versions[file_id] if file_id in con.versions else None\n\n    # PSD file exists\n    if os.path.exists(file_path):\n        # Version is logged\n        if version:\n            return version\n\n        # Version is not logged, use default\n        con.versions[file_id] = \"v1.0.0\"\n        con.update_version_tracker()\n        return \"v1.0.0\"\n\n    # PSD does not exist, and no version logged\n    if not version:\n        return\n\n    # PSD does not exist, version mistakenly logged\n    del con.versions[file_id]\n    con.update_version_tracker()\n    return\n</code></pre>"},{"location":"utils/download/#src.utils.download.get_temp_file","title":"<code>get_temp_file(res, sess, path, url)</code>","text":"<p>Check for an existing temporary file or create a new one. @param res: Planned download request. @param sess: Current download session. @param path: Planned path name to the completed download. @param url: If resumable, url to generate a new download request. @return: Tuple containing temp file path, total bytes downloaded, new download request.</p> Source code in <code>src/utils/download.py</code> <pre><code>def get_temp_file(\n    res: requests.Response,\n    sess: requests.Session,\n    path: str,\n    url: str,\n) -&gt; tuple:\n    \"\"\"\n    Check for an existing temporary file or create a new one.\n    @param res: Planned download request.\n    @param sess: Current download session.\n    @param path: Planned path name to the completed download.\n    @param url: If resumable, url to generate a new download request.\n    @return: Tuple containing temp file path, total bytes downloaded, new download request.\n    \"\"\"\n    existing_tmp_files = []\n    header = con.http_header.copy()\n    file_name = osp.basename(path)\n    for file in os.listdir(osp.dirname(path) or \".\"):\n        if file.startswith(file_name) and file != file_name:\n            existing_tmp_files.append(osp.join(osp.dirname(path), file))\n    if len(existing_tmp_files) != 0:\n        tmp_file = existing_tmp_files[0]\n        current = int(osp.getsize(tmp_file))\n    else:\n        current = 0\n        # mkstemp is preferred, but does not work on Windows\n        # https://github.com/wkentaro/gdown/issues/153\n        tmp_file = tempfile.mktemp(\n            suffix=tempfile.template,\n            prefix=osp.basename(path),\n            dir=osp.dirname(path),\n        )\n\n    # Resumable temp file found, update request with Range header\n    with open(tmp_file, \"ab\") as f:\n        if tmp_file is not None and f.tell() != 0:\n            header[\"Range\"] = \"bytes={}-\".format(f.tell())\n            res = sess.get(url, headers=header, stream=True, verify=True)\n    return tmp_file, current, res\n</code></pre>"},{"location":"utils/download/#src.utils.download.get_url_from_gdrive_confirmation","title":"<code>get_url_from_gdrive_confirmation(contents)</code>","text":"<p>Get the correct URL for downloading Google Drive file. @param contents: Google Drive page data. @return: Correct url for downloading.</p> Source code in <code>src/utils/download.py</code> <pre><code>def get_url_from_gdrive_confirmation(contents: str) -&gt; str:\n    \"\"\"\n    Get the correct URL for downloading Google Drive file.\n    @param contents: Google Drive page data.\n    @return: Correct url for downloading.\n    \"\"\"\n    for line in contents.splitlines():\n        if m := Reg.GDOWN_EXPORT.search(line):\n            # Google Docs URL\n            return f\"https://docs.google.com{m.groups()[0]}\".replace(\"&amp;amp;\", \"&amp;\")\n        if m := Reg.GDOWN_FORM.search(line):\n            # Download URL from Form\n            return m.groups()[0].replace(\"&amp;amp;\", \"&amp;\")\n        if m := Reg.GDOWN_URL.search(line):\n            # Download URL from JSON\n            return m.groups()[0].replace(\"\\\\u003d\", \"=\").replace(\"\\\\u0026\", \"&amp;\")\n        if m := Reg.GDOWN_ERROR.search(line):\n            # Error Returned\n            error = m.groups()[0]\n            raise RuntimeError(error)\n    raise RuntimeError(\n        \"Cannot retrieve a public link of the file. \"\n        \"You may need to change access permission, \"\n        \"or have reached the daily limit.\"\n    )\n</code></pre>"},{"location":"utils/download/#src.utils.download.print_download","title":"<code>print_download(url, path, resume=None)</code>","text":"<p>Print the details of an initiated download. @param url: Url file is being received from. @param path: Path the file is being saved to. @param resume: Temporary file we're resuming download on, if provided.</p> Source code in <code>src/utils/download.py</code> <pre><code>def print_download(url: str, path: str, resume: str = None) -&gt; None:\n    \"\"\"\n    Print the details of an initiated download.\n    @param url: Url file is being received from.\n    @param path: Path the file is being saved to.\n    @param resume: Temporary file we're resuming download on, if provided.\n    \"\"\"\n    print(\"Downloading...\", file=sys.stderr)\n    if resume:\n        print(\"Resume:\", resume, file=sys.stderr)\n    print(\"From:\", url, file=sys.stderr)\n    print(\"To:\", path, file=sys.stderr)\n</code></pre>"},{"location":"utils/download/#src.utils.download.update_template","title":"<code>update_template(temp, callback)</code>","text":"<p>Update a given template to the latest version. @param temp: Dict containing template information. @param callback: Callback method to update progress bar. @return: True if succeeded, False if failed.</p> Source code in <code>src/utils/download.py</code> <pre><code>def update_template(temp: TemplateUpdate, callback: Callable) -&gt; bool:\n    \"\"\"\n    Update a given template to the latest version.\n    @param temp: Dict containing template information.\n    @param callback: Callback method to update progress bar.\n    @return: True if succeeded, False if failed.\n    \"\"\"\n    try:\n        # Adjust to 7z if needed\n        file_path = temp['path'].with_suffix('.7z') if '.7z' in temp['filename'] else temp['path']\n\n        # Download using Google Drive\n        result = download_google(temp['id'], file_path, callback)\n        if not result:\n            # Google Drive failed, download from Amazon S3\n            url = f\"{temp['plugin']}/{temp['filename']}\" if temp['plugin'] else temp['filename']\n            result = download_s3(file_path, url, callback)\n        if not result:\n            # All Downloads failed\n            raise ConnectionError(f\"Downloading '{temp['name']} ({temp['type']})' was unsuccessful!\")\n    except Exception as e:\n        print(e)\n        return False\n\n    # Update version tracker, return succeeded\n    con.versions[temp['id']] = temp['version']\n    con.update_version_tracker()\n    return result\n</code></pre>"},{"location":"utils/download/#src.utils.download.version_check","title":"<code>version_check(template)</code>","text":"<p>Check if a template is up-to-date based on the live file metadata. @param template: Dict containing template details. @return: TemplateUpdate if update needed, else None.</p> Source code in <code>src/utils/download.py</code> <pre><code>def version_check(template: TemplateDetails) -&gt; Optional[TemplateUpdate]:\n    \"\"\"\n    Check if a template is up-to-date based on the live file metadata.\n    @param template: Dict containing template details.\n    @return: TemplateUpdate if update needed, else None.\n    \"\"\"\n    # Get our metadata\n    data = gdrive_metadata(template['id'])\n    if not data:\n        # File couldn't be located on Google Drive\n        print(f\"{template['name']} ({template['type']}) not found on Google Drive!\")\n        return\n\n    # Compare the versions\n    latest = data.get('description', \"v1.0.0\")\n    current = get_current_version(template['id'], template['template_path'])\n    if current and current == latest:\n        # Version is up-to-date\n        return\n\n    # Add 'Front' or 'Back' to name if needed\n    updated_name = template['name']\n    if 'front' in template['layout']:\n        updated_name = f\"{updated_name} Front\"\n    if 'back' in template['layout']:\n        updated_name = f\"{updated_name} Back\"\n\n    # Return our TemplateUpdate dict\n    return {\n        'id': template['id'],\n        'name': updated_name,\n        'name_base': template['name'],\n        'type': template['type'],\n        'filename': data['name'],\n        'path': template['template_path'],\n        'plugin': os.path.basename(\n            os.path.dirname(template['plugin_path'])\n        ) if template['plugin_path'] else None,\n        'version': latest,\n        'size': int(data['size'])\n    }\n</code></pre>"},{"location":"utils/env/","title":"Env","text":"<ul> <li>ENVIRONMENT VARIABLES</li> </ul>"},{"location":"utils/exceptions/","title":"Exceptions","text":"<p>EXCEPTION UTILITIES</p>"},{"location":"utils/exceptions/#src.utils.exceptions.PS_ERROR_CODES","title":"<code>PS_ERROR_CODES: dict[int:str] = {-2147417846: 'Photoshop is currently busy, close any dialog boxes and stop any pending actions.', -2147023170: 'Unable to make connection with Photoshop, please check the FAQ for solutions.', -2147352565: \"Failed to load a PSD template or other file, ensure template file isn't corrupted and that you have allocated enough scratch disk space and RAM to Photoshop.\", -2147352567: 'Photoshop does not appear to be installed. If Photoshop is installed, check the FAQ for solutions.', -2147220261: 'Invalid data type passed to action descriptor function.', -2147213497: 'Tried to transform, select, or translate an empty layer.', -2147212704: 'Action descriptor or layer object key/property is missing.', -2147220262: \"Photoshop tried to load a PSD template or file that doesn't exist.\", -2147220279: 'Wrong type of value passed to a Photoshop object property.', -2147213327: 'Tried to interact with a text layer that is rasterized or has an uninstalled font.', -2147213404: \"Tried to delete a layer that doesn't exist.\"}</code>  <code>module-attribute</code>","text":"<p>EXCEPTION CLASSES</p>"},{"location":"utils/exceptions/#src.utils.exceptions.ScryfallError","title":"<code>ScryfallError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception representing a failure to retrieve Scryfall data.</p> Source code in <code>src/utils/exceptions.py</code> <pre><code>class ScryfallError(Exception):\n    \"\"\"Exception representing a failure to retrieve Scryfall data.\"\"\"\n\n    def __init__(\n        self,\n        url: Optional[str] = None,\n        name: Optional[str] = '',\n        code: Optional[str] = '',\n        number: Optional[str] = '',\n        lang: Optional[str] = '',\n\n    ):\n        # Establish string patterns\n        name = f\"{name} \" if name else ''\n        code = f\"[{code}] \" if code else ''\n        number = f\"{{{number}}} \" if number else ''\n        lang = f\"&lt;{lang}&gt;\" if lang else ''\n\n        # Pass the correct message\n        super().__init__(\n            f\"Scryfall request failed\"\n        ) if not any([url, name, code, number, lang]) else (\n            f\"Couldn't find card: {name}{code}{number}{lang}\\n\"\n            f\"Scryfall: {url or 'Request Rejected'}\"\n        )\n</code></pre>"},{"location":"utils/exceptions/#src.utils.exceptions.get_com_error","title":"<code>get_com_error(signed_int)</code>","text":"<p>Check for an error message for both the signed and unsigned version of a COMError code (HRESULT). @param signed_int: Signed integer representing a COMError exception. @return: The string error message associated with this COMError code.</p> Source code in <code>src/utils/exceptions.py</code> <pre><code>def get_com_error(signed_int: int) -&gt; str:\n    \"\"\"\n    Check for an error message for both the signed and unsigned version of a COMError code (HRESULT).\n    @param signed_int: Signed integer representing a COMError exception.\n    @return: The string error message associated with this COMError code.\n    \"\"\"\n    try:\n        err = FormatMessage(signed_int)\n    except BaseException as e:\n        try:\n            unsigned_int = c_uint32(signed_int).value\n            err = FormatMessage(unsigned_int)\n        except BaseException as e:\n            err = e.args[2]\n    return err\n</code></pre>"},{"location":"utils/exceptions/#src.utils.exceptions.get_photoshop_error_message","title":"<code>get_photoshop_error_message(err)</code>","text":"<p>Gets a user-facing error message based on a given Photoshop access exception. @param err: Exception object containing the reason an action failed. @return: Proper user response for this exception.</p> Source code in <code>src/utils/exceptions.py</code> <pre><code>def get_photoshop_error_message(err: Exception) -&gt; str:\n    \"\"\"\n    Gets a user-facing error message based on a given Photoshop access exception.\n    @param err: Exception object containing the reason an action failed.\n    @return: Proper user response for this exception.\n    \"\"\"\n    return (\n        \"Photoshop is currently busy, close any dialogs and stop any actions.\\n\"\n    ) if 'busy' in str(err).lower() else (\n        \"Photoshop does not appear to be installed on your system.\\n\"\n        \"Please close Proxyshop and install a fresh copy of Photoshop,\\n\"\n        \"if Photoshop is installed, view the FAQ for troubleshooting.\\n\"\n    )\n</code></pre>"},{"location":"utils/files/","title":"Files","text":"<ul> <li>File Utilities</li> </ul>"},{"location":"utils/files/#src.utils.files.data_types","title":"<code>data_types: dict[str, DataFileType] = {'toml': {'load': toml_load, 'load_kw': {}, 'dump': toml_dump, 'dump_kw': {'sort_keys': True}}, 'yaml': {'load': yaml_load, 'load_kw': {'Loader': yamlLoader}, 'dump': yaml_dump, 'dump_kw': {'Dumper': yamlDumper, 'sort_keys': True, 'indent': 2, 'allow_unicode': True}}, 'json': {'load': json.load, 'load_kw': {}, 'dump': json.dump, 'dump_kw': {'sort_keys': True, 'indent': 2, 'ensure_ascii': False}}}</code>  <code>module-attribute</code>","text":"<ul> <li>File Info Utils</li> </ul>"},{"location":"utils/files/#src.utils.files.DataFileType","title":"<code>DataFileType</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Data file type (json, toml, yaml, etc).</p> Source code in <code>src/utils/files.py</code> <pre><code>class DataFileType (TypedDict):\n    \"\"\"Data file type (json, toml, yaml, etc).\"\"\"\n    load: Callable\n    dump: Callable\n    load_kw: dict[str, Union[Callable, bool, str]]\n    dump_kw: dict[str, Union[Callable, bool, str]]\n</code></pre>"},{"location":"utils/files/#src.utils.files.check_valid_file","title":"<code>check_valid_file(path, ext=None)</code>","text":"<p>Checks if a file path provided exists, optionally validate an extension type. @param path: Path to the file to verify. @param ext: Extension to check, if provided. @return: True if file is valid, otherwise False.</p> Source code in <code>src/utils/files.py</code> <pre><code>def check_valid_file(path: Union[str, os.PathLike], ext: Optional[str] = None) -&gt; bool:\n    \"\"\"\n    Checks if a file path provided exists, optionally validate an extension type.\n    @param path: Path to the file to verify.\n    @param ext: Extension to check, if provided.\n    @return: True if file is valid, otherwise False.\n    \"\"\"\n    with suppress(Exception):\n        check = str(path).lower()\n        if osp.isfile(check):\n            if ext:\n                ext = (ext if ext.startswith('.') else f'.{ext}').lower()\n                if not check.endswith(ext):\n                    return False\n            return True\n    return False\n</code></pre>"},{"location":"utils/files/#src.utils.files.copy_config_or_verify","title":"<code>copy_config_or_verify(path_from, path_to, data_file)</code>","text":"<p>Copy one config to another, or verify it if it exists. @param path_from: Path to the file to be copied. @param path_to: Path to the file to create, if it doesn't exist. @param data_file: Data schema file to use for validating an existing INI file.</p> Source code in <code>src/utils/files.py</code> <pre><code>def copy_config_or_verify(path_from: Path, path_to: Path, data_file: Path) -&gt; None:\n    \"\"\"\n    Copy one config to another, or verify it if it exists.\n    @param path_from: Path to the file to be copied.\n    @param path_to: Path to the file to create, if it doesn't exist.\n    @param data_file: Data schema file to use for validating an existing INI file.\n    \"\"\"\n    if osp.isfile(path_to):\n        return verify_config_fields(path_to, data_file)\n    shutil.copy(path_from, path_to)\n</code></pre>"},{"location":"utils/files/#src.utils.files.dump_data_file","title":"<code>dump_data_file(obj, data_file, config=None)</code>","text":"<p>Dump object to a data file. @param obj: Iterable or dict object to save to data file. @param data_file: Path to the data file to be dumps. @param config: Dict data to modify DataFileType configuration for this data dump procedure. @raise ValueError: If data file type not supported. @raise OSError: If dumping to data file fails.</p> Source code in <code>src/utils/files.py</code> <pre><code>def dump_data_file(\n    obj: Union[list, dict, tuple, set],\n    data_file: Union[str, os.PathLike],\n    config: Optional[dict] = None\n) -&gt; None:\n    \"\"\"\n    Dump object to a data file.\n    @param obj: Iterable or dict object to save to data file.\n    @param data_file: Path to the data file to be dumps.\n    @param config: Dict data to modify DataFileType configuration for this data dump procedure.\n    @raise ValueError: If data file type not supported.\n    @raise OSError: If dumping to data file fails.\n    \"\"\"\n    data_type = Path(data_file).suffix[1:]\n    parser: DataFileType = data_types.get(data_type, {})\n    if not parser:\n        raise ValueError(\"Data file provided does not match a supported data file type.\\n\"\n                         f\"Types supported: {', '.join(data_types.keys())}\\n\"\n                         f\"Type received: {data_type}\")\n    if config:\n        parser.update(config)\n    with util_file_lock:\n        with open(data_file, 'w', encoding='utf-8') as f:\n            try:\n                parser['dump'](obj, f, **parser['dump_kw'])\n            except Exception as e:\n                raise OSError(f\"Unable to dump data to data file:\\n{data_file}\") from e\n</code></pre>"},{"location":"utils/files/#src.utils.files.ensure_path_exists","title":"<code>ensure_path_exists(path)</code>","text":"<p>Ensure that directories in path exists. @param path: Folder path to check and create if necessary.</p> Source code in <code>src/utils/files.py</code> <pre><code>def ensure_path_exists(path: Union[str, os.PathLike]) -&gt; None:\n    \"\"\"\n    Ensure that directories in path exists.\n    @param path: Folder path to check and create if necessary.\n    \"\"\"\n    Path(osp.dirname(path)).mkdir(mode=711, parents=True, exist_ok=True)\n</code></pre>"},{"location":"utils/files/#src.utils.files.get_config_object","title":"<code>get_config_object(path)</code>","text":"<p>Returns a ConfigParser object using a valid ini path. @param path: Path to ini config file. @return: ConfigParser object. @raise: ValueError if valid ini file wasn't received.</p> Source code in <code>src/utils/files.py</code> <pre><code>def get_config_object(path: Union[str, os.PathLike, list[Union[str, os.PathLike]]]) -&gt; ConfigParser:\n    \"\"\"\n    Returns a ConfigParser object using a valid ini path.\n    @param path: Path to ini config file.\n    @return: ConfigParser object.\n    @raise: ValueError if valid ini file wasn't received.\n    \"\"\"\n    config = ConfigParser(allow_no_value=True)\n    config.optionxform = str\n    config.read(path, encoding='utf-8')\n    return config\n</code></pre>"},{"location":"utils/files/#src.utils.files.get_file_size_mb","title":"<code>get_file_size_mb(file_path, decimal=1)</code>","text":"<p>Get a file's size in megabytes rounded. @param file_path: Path to the file. @param decimal: Number of decimal places to allow when rounding. @return: Float representing the filesize in megabytes rounded.</p> Source code in <code>src/utils/files.py</code> <pre><code>def get_file_size_mb(file_path: Union[str, os.PathLike], decimal: int = 1) -&gt; float:\n    \"\"\"\n    Get a file's size in megabytes rounded.\n    @param file_path: Path to the file.\n    @param decimal: Number of decimal places to allow when rounding.\n    @return: Float representing the filesize in megabytes rounded.\n    \"\"\"\n    return round(os.path.getsize(file_path) / (1024 * 1024), decimal)\n</code></pre>"},{"location":"utils/files/#src.utils.files.get_kivy_config_from_schema","title":"<code>get_kivy_config_from_schema(config)</code>","text":"<p>Return valid JSON data for use with Kivy settings panel. @param config: Path to config schema file, JSON or TOML. @return: Json string dump of validated data.</p> Source code in <code>src/utils/files.py</code> <pre><code>def get_kivy_config_from_schema(config: Path) -&gt; str:\n    \"\"\"\n    Return valid JSON data for use with Kivy settings panel.\n    @param config: Path to config schema file, JSON or TOML.\n    @return: Json string dump of validated data.\n    \"\"\"\n    # Need to load data as JSON\n    raw = load_data_file(data_file=config)\n\n    # Use correct parser\n    if config.suffix == '.toml':\n        raw = parse_kivy_config_toml(raw)\n    return json.dumps(parse_kivy_config_json(raw))\n</code></pre>"},{"location":"utils/files/#src.utils.files.get_unique_filename","title":"<code>get_unique_filename(path, name, ext, suffix)</code>","text":"<p>If a filepath exists, number the file according to the lowest number that doesn't exist. @param path: Path to the file. @param name: Name of the file. @param ext: Extension of the file. @param suffix: Suffix to add before the number. @return: Unique filename.</p> Source code in <code>src/utils/files.py</code> <pre><code>def get_unique_filename(path: Union[str, os.PathLike], name: str, ext: str, suffix: str) -&gt; str:\n    \"\"\"\n    If a filepath exists, number the file according to the lowest number that doesn't exist.\n    @param path: Path to the file.\n    @param name: Name of the file.\n    @param ext: Extension of the file.\n    @param suffix: Suffix to add before the number.\n    @return: Unique filename.\n    \"\"\"\n    num = 0\n    new_name = f\"{name} ({suffix})\" if suffix else name\n    suffix = f' ({suffix}'+' {})' if suffix else ' ({})'\n    while Path(path, f\"{new_name}{ext}\").is_file():\n        num += 1\n        new_name = f\"{name}{suffix.format(num)}\"\n    return new_name\n</code></pre>"},{"location":"utils/files/#src.utils.files.load_data_file","title":"<code>load_data_file(data_file, config=None)</code>","text":"<p>Load object from a data file. @param data_file: Path to the data file to be loaded. @param config: Dict data to modify DataFileType configuration for this data load procedure. @return: Iterable or dict object loaded from data file. @raise ValueError: If data file type not supported. @raise OSError: If loading data file fails.</p> Source code in <code>src/utils/files.py</code> <pre><code>def load_data_file(\n    data_file: Union[str, os.PathLike],\n    config: Optional[dict] = None\n) -&gt; Union[list, dict, tuple, set]:\n    \"\"\"\n    Load object from a data file.\n    @param data_file: Path to the data file to be loaded.\n    @param config: Dict data to modify DataFileType configuration for this data load procedure.\n    @return: Iterable or dict object loaded from data file.\n    @raise ValueError: If data file type not supported.\n    @raise OSError: If loading data file fails.\n    \"\"\"\n    data_type = Path(data_file).suffix[1:]\n    parser: DataFileType = data_types.get(data_type, {})\n    if not parser:\n        raise ValueError(\"Data file provided does not match a supported data file type.\\n\"\n                         f\"Types supported: {', '.join(data_types.keys())}\\n\"\n                         f\"Type received: {data_type}\")\n    if config:\n        parser.update(config)\n    with util_file_lock:\n        with open(data_file, 'r', encoding='utf-8') as f:\n            try:\n                return parser['load'](f, **parser['load_kw']) or {}\n            except Exception as e:\n                raise OSError(f\"Unable to load data from data file:\\n{data_file}\") from e\n</code></pre>"},{"location":"utils/files/#src.utils.files.parse_kivy_config_json","title":"<code>parse_kivy_config_json(raw)</code>","text":"<p>Parse config JSON data for use with Kivy settings panel. @param raw: Raw loaded JSON data. @return: Properly parsed data safe for use with Kivy.</p> Source code in <code>src/utils/files.py</code> <pre><code>def parse_kivy_config_json(raw: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Parse config JSON data for use with Kivy settings panel.\n    @param raw: Raw loaded JSON data.\n    @return: Properly parsed data safe for use with Kivy.\n    \"\"\"\n    # Remove unsupported keys\n    for row in raw:\n        if 'default' in row:\n            row.pop('default')\n    return raw\n</code></pre>"},{"location":"utils/files/#src.utils.files.parse_kivy_config_toml","title":"<code>parse_kivy_config_toml(raw)</code>","text":"<p>Parse config TOML data for use with Kivy settings panel. @param raw: Raw loaded TOML data. @return: Properly parsed data safe for use with Kivy.</p> Source code in <code>src/utils/files.py</code> <pre><code>def parse_kivy_config_toml(raw: dict) -&gt; list[dict]:\n    \"\"\"\n    Parse config TOML data for use with Kivy settings panel.\n    @param raw: Raw loaded TOML data.\n    @return: Properly parsed data safe for use with Kivy.\n    \"\"\"\n\n    # Process __CONFIG__ header if present\n    cfg_header = raw.pop('__CONFIG__', {})\n    prefix = cfg_header.get('prefix', '')\n\n    # Process data\n    data: list[dict] = []\n    for section, settings in raw.items():\n\n        # Add section title if it exists\n        if title := settings.pop('title', None):\n            data.append({\n                'type': 'title',\n                'title': title\n            })\n\n        # Add each setting within this section\n        for key, field in settings.items():\n\n            # Establish data type and default value\n            data_type = field.get('type', 'bool')\n            display_default = default = field.get('default', 0)\n            if data_type == 'bool':\n                display_default = 'True' if default else 'False'\n            elif data_type in ['string', 'options', 'path']:\n                display_default = f\"'{default}'\"\n            setting = {\n                'type': data_type,\n                'title': msg_bold(field.get('title', 'Broken Setting')),\n                'desc': f\"{field.get('desc', '')}\\n\"\n                        f\"{msg_bold(f'(Default: {display_default})')}\",\n                'section': f'{prefix}.{section}' if prefix else section,\n                'key': key, 'default': default}\n            if options := field.get('options'):\n                setting['options'] = options\n            data.append(setting)\n\n    # Return parsed data\n    return data\n</code></pre>"},{"location":"utils/files/#src.utils.files.remove_config_file","title":"<code>remove_config_file(ini_file)</code>","text":"<p>Check if config file exists, then remove it. @return: True if removed, False if not.</p> Source code in <code>src/utils/files.py</code> <pre><code>def remove_config_file(ini_file: str) -&gt; bool:\n    \"\"\"\n    Check if config file exists, then remove it.\n    @return: True if removed, False if not.\n    \"\"\"\n    if osp.isfile(ini_file):\n        with suppress(Exception):\n            remove(ini_file)\n            return True\n    return False\n</code></pre>"},{"location":"utils/files/#src.utils.files.verify_config_fields","title":"<code>verify_config_fields(ini_file, data_file)</code>","text":"<p>Validate that all settings fields present in a given json data are present in config file. If any are missing, add them and return @param ini_file: Config file to verify contains the proper fields. @param data_file: Data file containing config fields to check for, JSON or TOML.</p> Source code in <code>src/utils/files.py</code> <pre><code>def verify_config_fields(ini_file: Path, data_file: Path) -&gt; None:\n    \"\"\"\n    Validate that all settings fields present in a given json data are present in config file.\n    If any are missing, add them and return\n    @param ini_file: Config file to verify contains the proper fields.\n    @param data_file: Data file containing config fields to check for, JSON or TOML.\n    \"\"\"\n    # Track data and changes\n    data, changed = {}, False\n\n    # Data file doesn't exist or is unsupported data type\n    if not data_file.is_file() or data_file.suffix not in ['.toml', '.json']:\n        return\n\n    # Load data from JSON or TOML file\n    raw = load_data_file(data_file)\n    raw = parse_kivy_config_toml(raw) if data_file.suffix == '.toml' else raw\n\n    # Ensure INI file exists and load ConfigParser\n    ensure_path_exists(ini_file)\n    config = get_config_object(ini_file)\n\n    # Build a dictionary of the necessary values\n    for row in raw:\n        # Add row if it's not a title\n        if row.get('type', 'title') == 'title':\n            continue\n        data.setdefault(\n            row.get('section', 'BROKEN'), []\n        ).append({\n            'key': row.get('key', ''),\n            'value': row.get('default', 0)\n        })\n\n    # Add the data to ini where missing\n    for section, settings in data.items():\n        # Check if the section exists\n        if not config.has_section(section):\n            config.add_section(section)\n            changed = True\n        # Check if each setting exists\n        for setting in settings:\n            if not config.has_option(section, setting['key']):\n                config.set(section, setting['key'], str(setting['value']))\n                changed = True\n\n    # If ini has changed, write changes\n    if changed:\n        with open(ini_file, \"w\", encoding=\"utf-8\") as f:\n            config.write(f)\n</code></pre>"},{"location":"utils/fonts/","title":"Fonts","text":"<p>FONT UTILITIES</p>"},{"location":"utils/fonts/#src.utils.fonts.check_app_fonts","title":"<code>check_app_fonts(folders)</code>","text":"<p>Checks each font in a folder to see if it is installed or outdated. @param folders: Folder paths containing fonts to check. @return: A tuple containing a dict of missing fonts and a dict of outdated fonts.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def check_app_fonts(folders: list[str]) -&gt; tuple[dict[str, FontDetails], dict[str, FontDetails]]:\n    \"\"\"\n    Checks each font in a folder to see if it is installed or outdated.\n    @param folders: Folder paths containing fonts to check.\n    @return: A tuple containing a dict of missing fonts and a dict of outdated fonts.\n    \"\"\"\n    # Get a dictionary of fonts found in target folder and fonts installed\n    fonts: dict[str, FontDetails] = {}\n    for f in folders:\n        fonts.update(get_fonts_from_folder(f))\n    missing, found = get_missing_fonts(fonts)\n    return missing, get_outdated_fonts(found, missing)\n</code></pre>"},{"location":"utils/fonts/#src.utils.fonts.get_document_fonts","title":"<code>get_document_fonts(container=None, fonts=None, ps_fonts=None)</code>","text":"<p>Get a list of all fonts used in a given Photoshop Document or LayerSet. @param container: Photoshop Document or LayerSet object. @param fonts: Existing fonts list to build onto. @param ps_fonts: Pre-computed Photoshop fonts list. @return: Unique list of font names.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def get_document_fonts(\n    container: Optional[type[LayerContainer]] = None,\n    fonts: Optional[dict] = None,\n    ps_fonts: Optional[dict] = None\n) -&gt; dict:\n    \"\"\"\n    Get a list of all fonts used in a given Photoshop Document or LayerSet.\n    @param container: Photoshop Document or LayerSet object.\n    @param fonts: Existing fonts list to build onto.\n    @param ps_fonts: Pre-computed Photoshop fonts list.\n    @return: Unique list of font names.\n    \"\"\"\n    # Establish starting fonts and Photoshop fonts\n    fonts = fonts or {}\n    ps_fonts = ps_fonts or get_ps_font_dict()\n    container = container or con.app.activeDocument\n\n    # Check each layer for a TextItem with a font\n    for layer in [n for n in container.artLayers if n.kind == LayerKind.TextLayer]:\n        try:\n            # Log a new font or update an existing one\n            font = str(layer.textItem.font)\n            if font in fonts:\n                fonts[font]['count'] += 1\n            else:\n                fonts[font] = {\n                    'name': ps_fonts.get(font, None),\n                    'count': 1\n                }\n        except PS_EXCEPTIONS:\n            # Font property couldn't be accessed\n            print(f\"Font unreadable for layer: {layer.name}\")\n\n    # Make additional calls for nested groups\n    for group in container.layerSets:\n        fonts = get_document_fonts(group, fonts, ps_fonts=ps_fonts)\n    return fonts\n</code></pre>"},{"location":"utils/fonts/#src.utils.fonts.get_font_details","title":"<code>get_font_details(path)</code>","text":"<p>Gets the font name and postscript name for a given font file. @param path: Path to ttf or otf file. @return: Tuple containing name and postscript name.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def get_font_details(path: str) -&gt; Optional[tuple[str, FontDetails]]:\n    \"\"\"\n    Gets the font name and postscript name for a given font file.\n    @param path: Path to ttf or otf file.\n    @return: Tuple containing name and postscript name.\n    \"\"\"\n    with suppress(PS_EXCEPTIONS, TTLibError):\n        with TTFont(path) as font:\n            font_name = font['name'].getName(4, 3, 1, 1033).toUnicode()\n            font_postscript = font['name'].getDebugName(6)\n            version_match = Reg.VERSION.search(font['name'].getDebugName(5))\n            font_version = version_match.group(1).lstrip('0') if version_match else None\n        return font_postscript, {'name': font_name, 'version': font_version}\n    return\n</code></pre>"},{"location":"utils/fonts/#src.utils.fonts.get_fonts_from_folder","title":"<code>get_fonts_from_folder(folder)</code>","text":"<p>Return a dictionary of font details for the fonts contained in a target directory. @param folder: Directory containing font files to read (supports TTF and OTF fonts). @return: Dictionary of FontDetails.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def get_fonts_from_folder(folder: str) -&gt; dict[str, FontDetails]:\n    \"\"\"\n    Return a dictionary of font details for the fonts contained in a target directory.\n    @param folder: Directory containing font files to read (supports TTF and OTF fonts).\n    @return: Dictionary of FontDetails.\n    \"\"\"\n    # Get a list of the font names in your `fonts` folder\n    with suppress(Exception):\n        ext = (\".otf\", \".ttf\", \".OTF\", \".TTF\")\n        local_fonts = [osp.join(folder, f) for f in os.listdir(folder) if f.endswith(ext)]\n        return {n[0]: n[1] for n in [get_font_details(f) for f in local_fonts] if n}\n    return {}\n</code></pre>"},{"location":"utils/fonts/#src.utils.fonts.get_installed_fonts_dict","title":"<code>get_installed_fonts_dict()</code>","text":"<p>Gets a dictionary of every font installed by the user. @return: Dictionary with postScriptName as key, and tuple of display name and version as value.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def get_installed_fonts_dict() -&gt; dict[str, FontDetails]:\n    \"\"\"\n    Gets a dictionary of every font installed by the user.\n    @return: Dictionary with postScriptName as key, and tuple of display name and version as value.\n    \"\"\"\n    with suppress(Exception):\n        installed_fonts_dir = os.path.expandvars(r'%userprofile%\\AppData\\Local\\Microsoft\\Windows\\Fonts')\n        system_fonts_dir = os.path.join(os.path.join(os.environ['WINDIR']), 'Fonts')\n        return {\n            **get_fonts_from_folder(installed_fonts_dir),\n            **get_fonts_from_folder(system_fonts_dir)\n        }\n    return {}\n</code></pre>"},{"location":"utils/fonts/#src.utils.fonts.get_missing_fonts","title":"<code>get_missing_fonts(fonts)</code>","text":"<p>Checks each font to see if it's present in the Photoshop font list. @param fonts: A dictionary of fonts to check for. @return: Tuple containing a dictionary of fonts missing and fonts found.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def get_missing_fonts(fonts: dict[str, FontDetails]) -&gt; tuple[dict[str, FontDetails], dict[str, FontDetails]]:\n    \"\"\"\n    Checks each font to see if it's present in the Photoshop font list.\n    @param fonts: A dictionary of fonts to check for.\n    @return: Tuple containing a dictionary of fonts missing and fonts found.\n    \"\"\"\n    # Figure out which fonts are missing\n    found: dict[str, FontDetails] = {}\n    missing: dict[str, FontDetails] = {}\n    for script_name, data in fonts.items():\n        try:\n            # Check if font exists in Photoshop\n            _ = con.app.fonts.app[script_name]\n            found[script_name] = data\n        except PS_EXCEPTIONS:\n            # Font not found in Photoshop\n            missing[script_name] = data\n    return missing, found\n</code></pre>"},{"location":"utils/fonts/#src.utils.fonts.get_outdated_fonts","title":"<code>get_outdated_fonts(fonts, missing=None)</code>","text":"<p>Compares the version of each font given against installed fonts. @param fonts: A dictionary of fonts to check against installed fonts. @param missing: An optional dictionary of fonts Photoshop couldn't locate, check in install dir. @return: A dict of fonts with outdated version number. Dict contains the newer version.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def get_outdated_fonts(\n    fonts: dict[str, FontDetails],\n    missing: Optional[dict[str, FontDetails]] = None\n) -&gt; dict[str, FontDetails]:\n    \"\"\"\n    Compares the version of each font given against installed fonts.\n    @param fonts: A dictionary of fonts to check against installed fonts.\n    @param missing: An optional dictionary of fonts Photoshop couldn't locate, check in install dir.\n    @return: A dict of fonts with outdated version number. Dict contains the newer version.\n    \"\"\"\n    # Check each confirmed font for version changes\n    outdated: dict[str, FontDetails] = {}\n    installed: dict[str, FontDetails] = get_installed_fonts_dict()\n    if not missing:\n        missing = {}\n\n    # Check fonts for any outdated\n    for name, data in fonts.items():\n        if name in installed and installed[name].get('version'):\n            if parse(installed[name]['version']) &lt; parse(data['version']):\n                outdated[name] = data\n\n    # Check missing fonts to see if found in installed dict, if so check for version change\n    for k in list(missing.keys()):\n        if k in installed and installed[k].get('version'):\n            if parse(installed[k]['version']) &lt; parse(missing[k]['version']):\n                outdated[k] = missing[k]\n            del missing[k]\n\n    return outdated\n</code></pre>"},{"location":"utils/fonts/#src.utils.fonts.get_ps_font_dict","title":"<code>get_ps_font_dict()</code>","text":"<p>Gets a dictionary of every font accessible in Photoshop. @return: Dictionary with postScriptName as key, display name as value.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def get_ps_font_dict() -&gt; dict[str, str]:\n    \"\"\"\n    Gets a dictionary of every font accessible in Photoshop.\n    @return: Dictionary with postScriptName as key, display name as value.\n    \"\"\"\n    fonts = {}\n    for f in con.app.fonts:\n        with suppress(PS_EXCEPTIONS):\n            fonts[f.name] = f.postScriptName\n    return fonts\n</code></pre>"},{"location":"utils/fonts/#src.utils.fonts.register_font","title":"<code>register_font(font_path)</code>","text":"<p>Add FontResource using given font file, refresh Photoshop fonts. @param font_path: Path to compatible font file. @return: True if succeeded, False if failed.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def register_font(font_path: str) -&gt; bool:\n    \"\"\"\n    Add FontResource using given font file, refresh Photoshop fonts.\n    @param font_path: Path to compatible font file.\n    @return: True if succeeded, False if failed.\n    \"\"\"\n    result = ctypes.windll.gdi32.AddFontResourceW(osp.abspath(font_path))\n    if result != 0:\n        # Font Resource added successfully\n        try:\n            # Notify all programs\n            print(f\"{osp.basename(font_path)} added to font cache!\")\n            hwnd_broadcast = wintypes.HWND(-1)\n            ctypes.windll.user32.SendMessageW(\n                hwnd_broadcast, wintypes.UINT(0x001D), wintypes.WPARAM(0), wintypes.LPARAM(0)\n            )\n            con.app.refreshFonts()\n        except Exception as e:\n            print(e)\n        return True\n    return False\n</code></pre>"},{"location":"utils/fonts/#src.utils.fonts.unregister_font","title":"<code>unregister_font(font_path)</code>","text":"<p>Remove FontResource using given font file, refresh Photoshop fonts. @param font_path: Path to compatible font file. @return: True if succeeded, False if failed.</p> Source code in <code>src/utils/fonts.py</code> <pre><code>def unregister_font(font_path: str) -&gt; bool:\n    \"\"\"\n    Remove FontResource using given font file, refresh Photoshop fonts.\n    @param font_path: Path to compatible font file.\n    @return: True if succeeded, False if failed.\n    \"\"\"\n    result = ctypes.windll.gdi32.RemoveFontResourceW(osp.abspath(font_path))\n    if result != 0:\n        # Font Resource removed successfully\n        try:\n            # Notify all programs\n            print(f\"{osp.basename(font_path)} removed from font cache!\")\n            hwnd_broadcast = wintypes.HWND(-1)\n            ctypes.windll.user32.SendMessageW(\n                hwnd_broadcast, wintypes.UINT(0x001D), wintypes.WPARAM(0), wintypes.LPARAM(0)\n            )\n            con.app.refreshFonts()\n        except Exception as e:\n            print(e)\n        return True\n    return False\n</code></pre>"},{"location":"utils/image/","title":"Image","text":"<p>IMAGE UTILITIES</p>"},{"location":"utils/image/#src.utils.image.downscale_image","title":"<code>downscale_image(path, **kwargs)</code>","text":"<p>Downscale an image to max width of MAX_WIDTH. @param path: Path to the image. @keyword width (int): Maximum width, default: 3264 @keyword optimize (bool): Whether to use Pillow optimize, default: True @keyword quality (int): JPEG quality, 1-100, default: 3264 @keyword resample (Resampling): Resampling algorithm, default: LANCZOS</p> Source code in <code>src/utils/image.py</code> <pre><code>def downscale_image(path: Path, **kwargs) -&gt; None:\n    \"\"\"\n    Downscale an image to max width of MAX_WIDTH.\n    @param path: Path to the image.\n    @keyword width (int): Maximum width, default: 3264\n    @keyword optimize (bool): Whether to use Pillow optimize, default: True\n    @keyword quality (int): JPEG quality, 1-100, default: 3264\n    @keyword resample (Resampling): Resampling algorithm, default: LANCZOS\n    \"\"\"\n    # Establish our source and destination directories\n    path_out = Path(path.parent, 'compressed')\n    path_out.mkdir(mode=711, parents=True, exist_ok=True)\n    save_path = Path(\n        path_out, kwargs.get('name', path.name)\n    ).with_suffix('.jpg')\n\n    # Establish our optional parameters\n    max_width = kwargs.get('max_width', 3264)\n    optimize = kwargs.get('optimize', True)\n    quality = kwargs.get('quality', 95)\n\n    # Open the image, get dimensions\n    with Image.open(path) as image:\n\n        # Calculate dimensions\n        width, height = image.size\n        if width &gt; max_width:\n            image.thumbnail(\n                size=(max_width, round((height * max_width) / width)),\n                resample=kwargs.get('resample', Resampling.LANCZOS))\n\n        # Save the new image\n        image.save(\n            fp=save_path,\n            format='JPEG',\n            quality=quality,\n            optimize=optimize)\n</code></pre>"},{"location":"utils/modules/","title":"Modules","text":"<p>MODULE UTILITIES</p>"},{"location":"utils/modules/#src.utils.modules.get_loaded_module","title":"<code>get_loaded_module(module_path, module_name, recache=False)</code>","text":"<p>Lookup a loaded module by its filepath and reload it. If not found, load the module fresh. @param module_path: File path to the module. @param module_name: Name to give the module if loading it fresh. @param recache: If True, reload the module before returning it. @return: True if loaded, otherwise False.</p> Source code in <code>src/utils/modules.py</code> <pre><code>def get_loaded_module(module_path: Path, module_name: str, recache: bool = False) -&gt; ModuleType:\n    \"\"\"\n    Lookup a loaded module by its filepath and reload it. If not found, load the module fresh.\n    @param module_path: File path to the module.\n    @param module_name: Name to give the module if loading it fresh.\n    @param recache: If True, reload the module before returning it.\n    @return: True if loaded, otherwise False.\n    \"\"\"\n    # Check if this module has been imported before\n    if module_name in sys.modules:\n        if recache:\n            del sys.modules[module_name]\n            return get_new_module(module_path, module_name)\n        return sys.modules[module_name]\n\n    # Model not loaded, load it now\n    return get_new_module(module_path, module_name)\n</code></pre>"},{"location":"utils/modules/#src.utils.modules.get_new_module","title":"<code>get_new_module(module_path, module_name)</code>","text":"<p>Loads a module from a given path with assigned name. @param module_path: Path to module file. @param module_name: Name of the loaded module. @return: Loaded module.</p> Source code in <code>src/utils/modules.py</code> <pre><code>def get_new_module(module_path: Path, module_name: str) -&gt; ModuleType:\n    \"\"\"\n    Loads a module from a given path with assigned name.\n    @param module_path: Path to module file.\n    @param module_name: Name of the loaded module.\n    @return: Loaded module.\n    \"\"\"\n    spec = spec_from_file_location(module_name, module_path)\n    module = module_from_spec(spec)\n    spec.loader.exec_module(module)\n    sys.modules[module_name] = module\n    return module\n</code></pre>"},{"location":"utils/objects/","title":"Objects","text":"<p>OBJECT UTILITIES</p>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler","title":"<code>PhotoshopHandler</code>","text":"<p>             Bases: <code>Application</code></p> <p>Wrapper for the Photoshop Application object to maintain a single instance globally, caching mechanisms, app instance refresh, etc.</p> Source code in <code>src/utils/objects.py</code> <pre><code>class PhotoshopHandler(Application):\n    \"\"\"\n    Wrapper for the Photoshop Application object to maintain a single instance globally,\n    caching mechanisms, app instance refresh, etc.\n    \"\"\"\n    DIMS_1200 = (3264, 4440)\n    DIMS_800 = (2176, 2960)\n    DIMS_600 = (1632, 2220)\n    _instance = None\n\n    def __new__(cls, version: Optional[str] = None) -&gt; 'PhotoshopHandler':\n        \"\"\"Always return the same Photoshop Application instance on successive calls.\"\"\"\n        # Use existing Photoshop instance or create new one\n        if cls._instance is None:\n            try:\n                cls._instance = super().__new__(cls)\n            except PS_EXCEPTIONS:\n                cls._instance = super(Photoshop, cls).__new__(cls)\n        # Establish the version initially passed and return instance\n        cls._instance._version = version\n        return cls._instance\n\n    \"\"\"\n    CLASS METHODS\n    \"\"\"\n\n    def refresh_app(self):\n        \"\"\"Replace the existing Photoshop Application instance with a new one.\"\"\"\n        if not self.is_running():\n            try:\n                # Load Photoshop and default preferences\n                super(PhotoshopHandler, self).__init__(version=self._version)\n                self.preferences.rulerUnits = Units.Pixels\n                self.preferences.typeUnits = Units.Points\n            except Exception as e:\n                # Photoshop is either busy or unresponsive\n                return OSError(get_photoshop_error_message(e))\n        return\n\n    @classmethod\n    def is_running(cls) -&gt; bool:\n        \"\"\"Check if the current Photoshop Application instance is still valid.\"\"\"\n        with suppress(Exception):\n            _ = cls._instance.version\n            return True\n        return False\n\n    \"\"\"\n    CONVERTING CHARACTER ID\n    \"\"\"\n\n    @cache\n    def charIDToTypeID(self, index: str) -&gt; int:\n        \"\"\"\n        Caching handler for charIDToTypeID.\n        @param index: ID to convert to TypeID.\n        \"\"\"\n        return super().charIDToTypeID(index)\n\n    @cache\n    def CharIDToTypeID(self, index: str) -&gt; int:\n        \"\"\"Utility definition redirecting to charIDToTypeID.\"\"\"\n        return self.charIDToTypeID(index)\n\n    @cache\n    def cID(self, index: str) -&gt; int:\n        \"\"\"Shorthand for charIDToTypeID.\"\"\"\n        return self.charIDToTypeID(index)\n\n    @cache\n    def typeIDToCharID(self, index: int) -&gt; str:\n        \"\"\"\n        Caching handler for typeIDToCharID.\n        @param index: ID to convert to CharID.\n        \"\"\"\n        return super().typeIDToCharID(index)\n\n    @cache\n    def t2c(self, index: int) -&gt; str:\n        \"\"\"Shorthand for typeIDToCharID.\"\"\"\n        return self.typeIDToCharID(index)\n\n    \"\"\"\n    CONVERTING STRING ID\n    \"\"\"\n\n    @cache\n    def stringIDToTypeID(self, index: str) -&gt; int:\n        \"\"\"\n        Caching handler for stringIDToTypeID.\n        @param index: ID to convert to TypeID.\n        \"\"\"\n        return super().stringIDToTypeID(index)\n\n    @cache\n    def StringIDToTypeID(self, index: str) -&gt; int:\n        \"\"\"Utility definition redirecting to stringIDTotypeID.\"\"\"\n        return self.stringIDToTypeID(index)\n\n    @cache\n    def sID(self, index: str) -&gt; int:\n        \"\"\"Shorthand for stringIDToTypeID.\"\"\"\n        return self.stringIDToTypeID(index)\n\n    @cache\n    def typeIDToStringID(self, index: int) -&gt; str:\n        \"\"\"\n        Caching handler for typeIDToStringID.\n        @param index: ID to convert to StringID.\n        \"\"\"\n        return super().typeIDToStringID(index)\n\n    @cache\n    def t2s(self, index: int) -&gt; str:\n        \"\"\"Shorthand for typeIDToStringID.\"\"\"\n        return self.typeIDToStringID(index)\n\n    \"\"\"\n    EXECUTING ACTION DESCRIPTORS\n    \"\"\"\n\n    def executeAction(\n            self, event_id: int,\n            descriptor: ActionDescriptor,\n            dialogs: DialogModes = DialogModes.DisplayNoDialogs\n    ) -&gt; Any:\n        \"\"\"\n        Middleware to allow all dialogs when an error occurs upon calling executeAction in development mode.\n        @param event_id: Action descriptor event ID.\n        @param descriptor: Main action descriptor tree to execute.\n        @param dialogs: DialogMode which governs whether to display dialogs.\n        \"\"\"\n        if not ENV.PS_ERROR_DIALOG:\n            return super().executeAction(event_id, descriptor, dialogs)\n        # Allow error dialogs within development environment\n        return super().executeAction(event_id, descriptor, DialogModes.DisplayErrorDialogs)\n\n    def ExecuteAction(\n            self, event_id: int,\n            descriptor: ActionDescriptor,\n            dialogs: DialogModes = DialogModes.DisplayNoDialogs\n    ) -&gt; Any:\n        \"\"\"Utility definition rerouting to original executeAction function.\"\"\"\n        self.executeAction(event_id, descriptor, dialogs)\n\n    \"\"\"\n    VERSION CHECKS\n    \"\"\"\n\n    @cache\n    def supports_target_text_replace(self) -&gt; bool:\n        \"\"\"\n        Checks if Photoshop version supports targeted text replacement.\n        @return: True if supported.\n        \"\"\"\n        return self.version_meets_requirement('22.0.0')\n\n    @cache\n    def supports_webp(self) -&gt; bool:\n        \"\"\"\n        Checks if Photoshop version supports WEBP files.\n        @return: True if supported.\n        \"\"\"\n        return self.version_meets_requirement('23.2.0')\n\n    @cache\n    def supports_generative_fill(self) -&gt; bool:\n        \"\"\"\n        Checks if Photoshop version supports Generative Fill.\n        @return: True if supported.\n        \"\"\"\n        return self.version_meets_requirement('24.6.0')\n\n    def version_meets_requirement(self, value: str) -&gt; bool:\n        \"\"\"\n        Checks if Photoshop version meets or exceeds required value.\n        @return: True if supported.\n        \"\"\"\n        if parse(self.version) &gt;= parse(value):\n            return True\n        return False\n\n    \"\"\"\n    DIMENSION CHECKS\n    \"\"\"\n\n    def scale_by_dpi(self, value: Union[int, float]) -&gt; int:\n        \"\"\"\n        Scales a value by comparing document DPI to ideal DPI.\n        @param value: Integer or float value to adjust by DPI ratio.\n        @return: Adjusted value as an integer.\n        \"\"\"\n        return int((self.activeDocument.width / 3264) * value)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.CharIDToTypeID","title":"<code>CharIDToTypeID(index)</code>  <code>cached</code>","text":"<p>Utility definition redirecting to charIDToTypeID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef CharIDToTypeID(self, index: str) -&gt; int:\n    \"\"\"Utility definition redirecting to charIDToTypeID.\"\"\"\n    return self.charIDToTypeID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.ExecuteAction","title":"<code>ExecuteAction(event_id, descriptor, dialogs=DialogModes.DisplayNoDialogs)</code>","text":"<p>Utility definition rerouting to original executeAction function.</p> Source code in <code>src/utils/objects.py</code> <pre><code>def ExecuteAction(\n        self, event_id: int,\n        descriptor: ActionDescriptor,\n        dialogs: DialogModes = DialogModes.DisplayNoDialogs\n) -&gt; Any:\n    \"\"\"Utility definition rerouting to original executeAction function.\"\"\"\n    self.executeAction(event_id, descriptor, dialogs)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.StringIDToTypeID","title":"<code>StringIDToTypeID(index)</code>  <code>cached</code>","text":"<p>Utility definition redirecting to stringIDTotypeID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef StringIDToTypeID(self, index: str) -&gt; int:\n    \"\"\"Utility definition redirecting to stringIDTotypeID.\"\"\"\n    return self.stringIDToTypeID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.__new__","title":"<code>__new__(version=None)</code>","text":"<p>Always return the same Photoshop Application instance on successive calls.</p> Source code in <code>src/utils/objects.py</code> <pre><code>def __new__(cls, version: Optional[str] = None) -&gt; 'PhotoshopHandler':\n    \"\"\"Always return the same Photoshop Application instance on successive calls.\"\"\"\n    # Use existing Photoshop instance or create new one\n    if cls._instance is None:\n        try:\n            cls._instance = super().__new__(cls)\n        except PS_EXCEPTIONS:\n            cls._instance = super(Photoshop, cls).__new__(cls)\n    # Establish the version initially passed and return instance\n    cls._instance._version = version\n    return cls._instance\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.cID","title":"<code>cID(index)</code>  <code>cached</code>","text":"<p>Shorthand for charIDToTypeID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef cID(self, index: str) -&gt; int:\n    \"\"\"Shorthand for charIDToTypeID.\"\"\"\n    return self.charIDToTypeID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.charIDToTypeID","title":"<code>charIDToTypeID(index)</code>  <code>cached</code>","text":"<p>Caching handler for charIDToTypeID. @param index: ID to convert to TypeID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef charIDToTypeID(self, index: str) -&gt; int:\n    \"\"\"\n    Caching handler for charIDToTypeID.\n    @param index: ID to convert to TypeID.\n    \"\"\"\n    return super().charIDToTypeID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.executeAction","title":"<code>executeAction(event_id, descriptor, dialogs=DialogModes.DisplayNoDialogs)</code>","text":"<p>Middleware to allow all dialogs when an error occurs upon calling executeAction in development mode. @param event_id: Action descriptor event ID. @param descriptor: Main action descriptor tree to execute. @param dialogs: DialogMode which governs whether to display dialogs.</p> Source code in <code>src/utils/objects.py</code> <pre><code>def executeAction(\n        self, event_id: int,\n        descriptor: ActionDescriptor,\n        dialogs: DialogModes = DialogModes.DisplayNoDialogs\n) -&gt; Any:\n    \"\"\"\n    Middleware to allow all dialogs when an error occurs upon calling executeAction in development mode.\n    @param event_id: Action descriptor event ID.\n    @param descriptor: Main action descriptor tree to execute.\n    @param dialogs: DialogMode which governs whether to display dialogs.\n    \"\"\"\n    if not ENV.PS_ERROR_DIALOG:\n        return super().executeAction(event_id, descriptor, dialogs)\n    # Allow error dialogs within development environment\n    return super().executeAction(event_id, descriptor, DialogModes.DisplayErrorDialogs)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.is_running","title":"<code>is_running()</code>  <code>classmethod</code>","text":"<p>Check if the current Photoshop Application instance is still valid.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@classmethod\ndef is_running(cls) -&gt; bool:\n    \"\"\"Check if the current Photoshop Application instance is still valid.\"\"\"\n    with suppress(Exception):\n        _ = cls._instance.version\n        return True\n    return False\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.refresh_app","title":"<code>refresh_app()</code>","text":"<p>Replace the existing Photoshop Application instance with a new one.</p> Source code in <code>src/utils/objects.py</code> <pre><code>def refresh_app(self):\n    \"\"\"Replace the existing Photoshop Application instance with a new one.\"\"\"\n    if not self.is_running():\n        try:\n            # Load Photoshop and default preferences\n            super(PhotoshopHandler, self).__init__(version=self._version)\n            self.preferences.rulerUnits = Units.Pixels\n            self.preferences.typeUnits = Units.Points\n        except Exception as e:\n            # Photoshop is either busy or unresponsive\n            return OSError(get_photoshop_error_message(e))\n    return\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.sID","title":"<code>sID(index)</code>  <code>cached</code>","text":"<p>Shorthand for stringIDToTypeID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef sID(self, index: str) -&gt; int:\n    \"\"\"Shorthand for stringIDToTypeID.\"\"\"\n    return self.stringIDToTypeID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.scale_by_dpi","title":"<code>scale_by_dpi(value)</code>","text":"<p>Scales a value by comparing document DPI to ideal DPI. @param value: Integer or float value to adjust by DPI ratio. @return: Adjusted value as an integer.</p> Source code in <code>src/utils/objects.py</code> <pre><code>def scale_by_dpi(self, value: Union[int, float]) -&gt; int:\n    \"\"\"\n    Scales a value by comparing document DPI to ideal DPI.\n    @param value: Integer or float value to adjust by DPI ratio.\n    @return: Adjusted value as an integer.\n    \"\"\"\n    return int((self.activeDocument.width / 3264) * value)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.stringIDToTypeID","title":"<code>stringIDToTypeID(index)</code>  <code>cached</code>","text":"<p>Caching handler for stringIDToTypeID. @param index: ID to convert to TypeID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef stringIDToTypeID(self, index: str) -&gt; int:\n    \"\"\"\n    Caching handler for stringIDToTypeID.\n    @param index: ID to convert to TypeID.\n    \"\"\"\n    return super().stringIDToTypeID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.supports_generative_fill","title":"<code>supports_generative_fill()</code>  <code>cached</code>","text":"<p>Checks if Photoshop version supports Generative Fill. @return: True if supported.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef supports_generative_fill(self) -&gt; bool:\n    \"\"\"\n    Checks if Photoshop version supports Generative Fill.\n    @return: True if supported.\n    \"\"\"\n    return self.version_meets_requirement('24.6.0')\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.supports_target_text_replace","title":"<code>supports_target_text_replace()</code>  <code>cached</code>","text":"<p>Checks if Photoshop version supports targeted text replacement. @return: True if supported.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef supports_target_text_replace(self) -&gt; bool:\n    \"\"\"\n    Checks if Photoshop version supports targeted text replacement.\n    @return: True if supported.\n    \"\"\"\n    return self.version_meets_requirement('22.0.0')\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.supports_webp","title":"<code>supports_webp()</code>  <code>cached</code>","text":"<p>Checks if Photoshop version supports WEBP files. @return: True if supported.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef supports_webp(self) -&gt; bool:\n    \"\"\"\n    Checks if Photoshop version supports WEBP files.\n    @return: True if supported.\n    \"\"\"\n    return self.version_meets_requirement('23.2.0')\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.t2c","title":"<code>t2c(index)</code>  <code>cached</code>","text":"<p>Shorthand for typeIDToCharID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef t2c(self, index: int) -&gt; str:\n    \"\"\"Shorthand for typeIDToCharID.\"\"\"\n    return self.typeIDToCharID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.t2s","title":"<code>t2s(index)</code>  <code>cached</code>","text":"<p>Shorthand for typeIDToStringID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef t2s(self, index: int) -&gt; str:\n    \"\"\"Shorthand for typeIDToStringID.\"\"\"\n    return self.typeIDToStringID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.typeIDToCharID","title":"<code>typeIDToCharID(index)</code>  <code>cached</code>","text":"<p>Caching handler for typeIDToCharID. @param index: ID to convert to CharID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef typeIDToCharID(self, index: int) -&gt; str:\n    \"\"\"\n    Caching handler for typeIDToCharID.\n    @param index: ID to convert to CharID.\n    \"\"\"\n    return super().typeIDToCharID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.typeIDToStringID","title":"<code>typeIDToStringID(index)</code>  <code>cached</code>","text":"<p>Caching handler for typeIDToStringID. @param index: ID to convert to StringID.</p> Source code in <code>src/utils/objects.py</code> <pre><code>@cache\ndef typeIDToStringID(self, index: int) -&gt; str:\n    \"\"\"\n    Caching handler for typeIDToStringID.\n    @param index: ID to convert to StringID.\n    \"\"\"\n    return super().typeIDToStringID(index)\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.PhotoshopHandler.version_meets_requirement","title":"<code>version_meets_requirement(value)</code>","text":"<p>Checks if Photoshop version meets or exceeds required value. @return: True if supported.</p> Source code in <code>src/utils/objects.py</code> <pre><code>def version_meets_requirement(self, value: str) -&gt; bool:\n    \"\"\"\n    Checks if Photoshop version meets or exceeds required value.\n    @return: True if supported.\n    \"\"\"\n    if parse(self.version) &gt;= parse(value):\n        return True\n    return False\n</code></pre>"},{"location":"utils/objects/#src.utils.objects.Singleton","title":"<code>Singleton</code>","text":"<p>             Bases: <code>type</code></p> <p>Maintains a single instance of any child class.</p> Source code in <code>src/utils/objects.py</code> <pre><code>class Singleton(type):\n    \"\"\"Maintains a single instance of any child class.\"\"\"\n    _instances: dict = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n</code></pre>"},{"location":"utils/regex/","title":"Regex","text":"<p>PRECOMPILED REGEX PATTERNS</p>"},{"location":"utils/scryfall/","title":"Scryfall","text":"<p>FUNCTIONS THAT INTERACT WITH SCRYFALL</p>"},{"location":"utils/scryfall/#src.utils.scryfall.MTGJSON_SET_DATA_EXTRA","title":"<code>MTGJSON_SET_DATA_EXTRA = ['sealedProduct', 'booster', 'cards']</code>  <code>module-attribute</code>","text":"<p>ERROR HANDLING</p>"},{"location":"utils/scryfall/#src.utils.scryfall.card_scan","title":"<code>card_scan(img_url)</code>","text":"<p>Downloads scryfall art from URL @param img_url: Scryfall URI for image. @return: Filename of the saved image, None if unsuccessful.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>@handle_request_failure(None)\ndef card_scan(img_url: str) -&gt; Optional[str]:\n    \"\"\"\n    Downloads scryfall art from URL\n    @param img_url: Scryfall URI for image.\n    @return: Filename of the saved image, None if unsuccessful.\n    \"\"\"\n    r = requests.get(img_url, stream=True)\n    with open(con.path_scryfall_scan, 'wb') as f:\n        copyfileobj(r.raw, f)\n        return f.name\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.check_playable_card","title":"<code>check_playable_card(card_json)</code>","text":"<p>Checks if this card object is a playable game piece. @param card_json: Scryfall data for this card. @return: Valid scryfall data if check passed, else None.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>def check_playable_card(card_json: dict) -&gt; bool:\n    \"\"\"\n    Checks if this card object is a playable game piece.\n    @param card_json: Scryfall data for this card.\n    @return: Valid scryfall data if check passed, else None.\n    \"\"\"\n    if card_json.get('set_type') in [\"minigame\"]:\n        return False\n    if card_json.get('layout') in ['art_series', 'reversible_card']:\n        return False\n    return True\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.get_basic_land","title":"<code>get_basic_land(card_name, name_normalized, set_code)</code>  <code>cached</code>","text":"<p>Generate fake Scryfall data from basic land. @param card_name: Name of the basic land card. @param name_normalized: Normalized version of the name string. @param set_code: Desired set code for the basic land. @return: Fake scryfall data.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>@cache\ndef get_basic_land(card_name: str, name_normalized: str, set_code: Optional[str]) -&gt; dict:\n    \"\"\"\n    Generate fake Scryfall data from basic land.\n    @param card_name: Name of the basic land card.\n    @param name_normalized: Normalized version of the name string.\n    @param set_code: Desired set code for the basic land.\n    @return: Fake scryfall data.\n    \"\"\"\n    return {\n        'name': card_name,\n        'set': (set_code or 'MTG').upper(),\n        'layout': 'basic',\n        'rarity': 'common',\n        'collector_number': None,\n        'printed_count': None,\n        'type_line': BASIC_LANDS.get(\n            name_normalized, 'Basic Land')\n    }\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.get_card_data","title":"<code>get_card_data(card_name, card_set=None, card_number=None)</code>","text":"<p>Fetch card data from Scryfall API. @param card_name: Name of the card. @param card_set: Set code of the card. @param card_number: Collector number of the card. @return: Scryfall dict or Exception.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>def get_card_data(\n    card_name: str,\n    card_set: Optional[str] = None,\n    card_number: Optional[str] = None\n) -&gt; Union[dict, Exception]:\n    \"\"\"\n    Fetch card data from Scryfall API.\n    @param card_name: Name of the card.\n    @param card_set: Set code of the card.\n    @param card_number: Collector number of the card.\n    @return: Scryfall dict or Exception.\n    \"\"\"\n\n    # Establish Scryfall fetch action\n    name_normalized = normalize_str(card_name, True)\n    action = get_card_unique if card_number else get_card_search\n    params = [card_set, str(card_number).lstrip('0 ')] if card_number else [card_name, card_set]\n\n    # Query the card in alternate language\n    if cfg.lang != \"en\":\n        card = action(*params, lang=cfg.lang)\n\n        # Was the result correct?\n        if isinstance(card, dict):\n            card['name_normalized'] = name_normalized\n            return process_scryfall_data(card)\n        elif not cfg.test_mode:\n            # Language couldn't be found\n            console.update(msg_warn(f\"Reverting to English: [b]{card_name}[/b]\"))\n\n    # Query the card in English, retry with extras if failed\n    card = action(*params)\n    if not isinstance(card, dict) and not cfg.scry_extras:\n        card = action(*params, extras=True)\n    # Return valid card or return Exception\n    if isinstance(card, dict):\n        card['name_normalized'] = name_normalized\n        return process_scryfall_data(card)\n    return card\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.get_card_search","title":"<code>get_card_search(card_name, card_set=None, lang='en', extras=False)</code>","text":"<p>Get card using /cards/search Scryfall API endpoint. @note: https://scryfall.com/docs/api/cards/search @param card_name: Name of the card, ex: Damnation @param card_set: Set code to look for, ex: MH2 @param lang: Lang code to look for, ex: en @param extras: Forces include_extras if True, otherwise use setting. @return: Card dict or ScryfallError</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>@handle_request_failure()\ndef get_card_search(\n    card_name: str,\n    card_set: Optional[str] = None,\n    lang: str = 'en',\n    extras: bool = False\n) -&gt; Union[dict, ScryfallError]:\n    \"\"\"\n    Get card using /cards/search Scryfall API endpoint.\n    @note: https://scryfall.com/docs/api/cards/search\n    @param card_name: Name of the card, ex: Damnation\n    @param card_set: Set code to look for, ex: MH2\n    @param lang: Lang code to look for, ex: en\n    @param extras: Forces include_extras if True, otherwise use setting.\n    @return: Card dict or ScryfallError\n    \"\"\"\n    # Query Scryfall\n    res = requests.get(\n        url = SCRY_API_CARDS_SEARCH,\n        headers=con.http_header,\n        params={\n            'unique': cfg.scry_unique,\n            'order': cfg.scry_sorting,\n            'dir': 'asc' if cfg.scry_ascending else 'desc',\n            'include_extras': extras if extras else cfg.scry_extras,\n            'q': f'!\"{card_name}\"'\n                 f\" lang:{lang}\"\n                 f\"{f' set:{card_set.lower()}' if card_set else ''}\"})\n\n    # Card data returned, Scryfall encoded URL\n    card, url = res.json() or {}, res.url\n\n    # Check for a playable card\n    for c in card.get('data', []):\n        if check_playable_card(c):\n            return c\n\n    # No playable results\n    return ScryfallError(url, name=card_name, code=card_set, lang=lang)\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.get_card_unique","title":"<code>get_card_unique(card_set, card_number, lang='en')</code>","text":"<p>Get card using /cards/:code/:number(/:lang) Scryfall API endpoint. @note: https://scryfall.com/docs/api/cards/collector @param card_set: Set code of the card, ex: MH2 @param card_number: Collector number of the card @param lang: Lang code to look for, ex: en @return: Card dict or ScryfallError</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>@handle_request_failure()\ndef get_card_unique(\n    card_set: str,\n    card_number: str,\n    lang: str = 'en'\n) -&gt; Union[dict, ScryfallError]:\n    \"\"\"\n    Get card using /cards/:code/:number(/:lang) Scryfall API endpoint.\n    @note: https://scryfall.com/docs/api/cards/collector\n    @param card_set: Set code of the card, ex: MH2\n    @param card_number: Collector number of the card\n    @param lang: Lang code to look for, ex: en\n    @return: Card dict or ScryfallError\n    \"\"\"\n    lang = '' if lang == 'en' else f'/{lang}'\n    res = requests.get(\n        url=f'{SCRY_API_CARDS}/{card_set.lower()}/{card_number}{lang}',\n        headers=con.http_header\n    )\n    card, url = res.json(), res.url\n\n    # Ensure playable card was returned\n    if card.get('object') != 'error' and check_playable_card(card):\n        return card\n    return ScryfallError(url, code=card_set, number=card_number, lang=lang)\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.get_cards_oracle","title":"<code>get_cards_oracle(oracle_id, all_pages=False, **kwargs)</code>","text":"<p>Grab paginated card list from a Scryfall API endpoint using the Oracle ID of the card. @param oracle_id: Scryfall Oracle ID of the card. @param all_pages: Whether to return all additional pages, or just the first. @param kwargs: Optional parameters to pass to API endpoint.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>@handle_request_failure([])\ndef get_cards_oracle(oracle_id: str, all_pages: bool = False, **kwargs) -&gt; list[dict]:\n    \"\"\"\n    Grab paginated card list from a Scryfall API endpoint using the Oracle ID of the card.\n    @param oracle_id: Scryfall Oracle ID of the card.\n    @param all_pages: Whether to return all additional pages, or just the first.\n    @param kwargs: Optional parameters to pass to API endpoint.\n    \"\"\"\n    return get_cards_paged(\n        url=SCRY_API_CARDS_SEARCH,\n        all_pages=all_pages,\n        **{\n            'q': f'oracleid:{oracle_id}',\n            'dir': kwargs.pop('dir', 'asc'),\n            'order': kwargs.pop('order', 'released'),\n            'unique': kwargs.pop('unique', 'prints'),\n            **kwargs\n        })\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.get_cards_paged","title":"<code>get_cards_paged(url=SCRY_API_CARDS_SEARCH, all_pages=True, **kwargs)</code>","text":"<p>Grab paginated card list from a Scryfall API endpoint. @param url: Scryfall API URL endpoint to access. @param all_pages: Whether to return all additional pages, or just the first. @param kwargs: Optional parameters to pass to API endpoint.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>@handle_request_failure([])\ndef get_cards_paged(url: str = SCRY_API_CARDS_SEARCH, all_pages: bool = True, **kwargs) -&gt; list[dict]:\n    \"\"\"\n    Grab paginated card list from a Scryfall API endpoint.\n    @param url: Scryfall API URL endpoint to access.\n    @param all_pages: Whether to return all additional pages, or just the first.\n    @param kwargs: Optional parameters to pass to API endpoint.\n    \"\"\"\n    # Query Scryfall\n    res = requests.get(url=url, headers=con.http_header, params=kwargs).json()\n    cards = res.get('data', [])\n\n    # Add additional pages if any exist\n    if all_pages and res.get(\"has_more\") and res.get(\"next_page\"):\n        cards.extend(\n            get_cards_paged(\n                url=res.get['next_page'],\n                all_pages=all_pages\n            ))\n    return cards\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.get_set_data","title":"<code>get_set_data(card_set)</code>","text":"<p>Grab available set data. @param card_set: The set to look for, ex: MH2 @return: MTG set dict or empty dict.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>def get_set_data(card_set: str) -&gt; Optional[dict]:\n    \"\"\"\n    Grab available set data.\n    @param card_set: The set to look for, ex: MH2\n    @return: MTG set dict or empty dict.\n    \"\"\"\n    # Has this set been logged?\n    path = Path(con.path_data_sets, f\"SET-{card_set.upper()}.json\")\n    if os.path.exists(path):\n        try:\n            # Try to load existing data file\n            data = load_data_file(path)\n            if 'scryfall' in data:\n                return data\n        except Exception as e:\n            console.log_exception(e)\n\n    # Get Scryfall data, then check for token set\n    data_scry = get_set_scryfall(card_set)\n    if data_scry.get('set_type', '') == 'token':\n        card_set = data_scry.get('parent_set_code', card_set)\n\n    # Get MTGJSON data and fold it in\n    data_mtg = get_set_mtgjson(card_set)\n    data_scry.update(data_mtg)\n\n    # Save the data if both lookups were valid, or 'printed_size' is present\n    if (data_mtg and data_scry) or 'printed_size' in data_scry:\n        try:\n            # Try to dump set data\n            dump_data_file(data_scry, path)\n        except Exception as e:\n            console.log_exception(e)\n\n    # Enforce valid data\n    return data_scry if isinstance(data_scry, dict) else {}\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.get_set_mtgjson","title":"<code>get_set_mtgjson(card_set)</code>","text":"<p>Grab available set data from MTG Json. @param card_set: The set to look for, ex: MH2 @return: MTGJson set dict or empty dict.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>@handle_request_failure({})\ndef get_set_mtgjson(card_set: str) -&gt; dict:\n    \"\"\"\n    Grab available set data from MTG Json.\n    @param card_set: The set to look for, ex: MH2\n    @return: MTGJson set dict or empty dict.\n    \"\"\"\n    # Grab from MTG JSON\n    j = requests.get(\n        f\"{MTGJSON_API}/{card_set.upper()}.json\",\n        headers=con.http_header\n    ).json().get('data', {})\n\n    # Add token count if tokens present\n    j['tokenCount'] = len(j.pop('tokens', []))\n\n    # Remove unneeded data\n    [j.pop(n) for n in MTGJSON_SET_DATA_EXTRA]\n\n    # Return data if valid\n    return j if j.get('name') else {}\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.get_set_scryfall","title":"<code>get_set_scryfall(card_set)</code>","text":"<p>Grab available set data from MTG Json. @param card_set: The set to look for, ex: MH2 @return: Scryfall set dict or empty dict.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>@handle_request_failure({})\ndef get_set_scryfall(card_set: str) -&gt; dict:\n    \"\"\"\n    Grab available set data from MTG Json.\n    @param card_set: The set to look for, ex: MH2\n    @return: Scryfall set dict or empty dict.\n    \"\"\"\n    # Grab from Scryfall\n    source = requests.get(\n        f\"{SCRY_API_SETS}/{card_set.upper()}\",\n        headers=con.http_header\n    ).text\n    j = json.loads(source)\n\n    # Return data if valid\n    j.setdefault('scryfall', True)\n    return j if j.get('name') else {}\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.handle_final_exception","title":"<code>handle_final_exception(fail_response)</code>","text":"<p>Decorator to handle any exception and return appropriate failure value. @param fail_response: Return value if Exception occurs. @return: Return value of the function, or fail_response.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>def handle_final_exception(fail_response: Optional[Any]) -&gt; Callable:\n    \"\"\"\n    Decorator to handle any exception and return appropriate failure value.\n    @param fail_response: Return value if Exception occurs.\n    @return: Return value of the function, or fail_response.\n    \"\"\"\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            # Final exception catch\n            try:\n                return func(*args, **kwargs)\n            except Exception as e:\n                # All requests failed\n                console.log_exception(e)\n                if fail_response == 'error':\n                    # Return formatted Scryfall Error\n                    return ScryfallError()\n                return fail_response\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.handle_request_failure","title":"<code>handle_request_failure(fail_response='error')</code>","text":"<p>Decorator to handle all Scryfall request failure cases, and return appropriate failure value. @param fail_response: The value to return if request failed entirely. By default, it                       tries to return a ScryfallError formatting proper failure message. @return: Requested data if successful, fail_response if not.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>def handle_request_failure(\n    fail_response: Optional[Any] = 'error'\n) -&gt; Callable:\n    \"\"\"\n    Decorator to handle all Scryfall request failure cases, and return appropriate failure value.\n    @param fail_response: The value to return if request failed entirely. By default, it\n                          tries to return a ScryfallError formatting proper failure message.\n    @return: Requested data if successful, fail_response if not.\n    \"\"\"\n    def decorator(func):\n        @sleep_and_retry\n        @scryfall_rate_limit\n        @on_exception(expo, requests.exceptions.RequestException, max_tries=3, max_time=1)\n        @handle_final_exception(fail_response)\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.parse_card_info","title":"<code>parse_card_info(file_path)</code>","text":"<p>Retrieve card name from the input file, and optional tags (artist, set, number). @param file_path: Path to the image file. @return: Dict of card details.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>def parse_card_info(file_path: Path) -&gt; CardDetails:\n    \"\"\"\n    Retrieve card name from the input file, and optional tags (artist, set, number).\n    @param file_path: Path to the image file.\n    @return: Dict of card details.\n    \"\"\"\n    # Extract just the card name\n    file_name = file_path.stem\n\n    # Match pattern and format data\n    name_split = Reg.PATH_SPLIT.split(file_name)\n    artist = Reg.PATH_ARTIST.search(file_name)\n    number = Reg.PATH_NUM.search(file_name)\n    code = Reg.PATH_SET.search(file_name)\n\n    # Return dictionary\n    return {\n        'filename': file_path,\n        'name': name_split[0].strip(),\n        'set': code.group(1) if code else '',\n        'artist': artist.group(1) if artist else '',\n        'number': number.group(1) if number and code else '',\n        'creator': name_split[-1] if '$' in file_name else '',\n    }\n</code></pre>"},{"location":"utils/scryfall/#src.utils.scryfall.process_scryfall_data","title":"<code>process_scryfall_data(data)</code>","text":"<p>Process any additional required data before sending it to the layout object. @param data: Unprocessed scryfall data. @return: Processed scryfall data.</p> Source code in <code>src/utils/scryfall.py</code> <pre><code>def process_scryfall_data(data: dict) -&gt; dict:\n    \"\"\"\n    Process any additional required data before sending it to the layout object.\n    @param data: Unprocessed scryfall data.\n    @return: Processed scryfall data.\n    \"\"\"\n    # Modify meld card data to fit transform layout\n    if data['layout'] == 'meld':\n        # Ignore tokens and other objects\n        front, back = [], None\n        for part in data.get('all_parts', []):\n            if part.get('component') == 'meld_part':\n                front.append(part)\n            if part.get('component') == 'meld_result':\n                back = part\n\n        # Figure out if card is a front or a back\n        faces = [front[0], back] if (\n            data['name_normalized'] == normalize_str(back['name'], True) or\n            data['name_normalized'] == normalize_str(front[0]['name'], True)\n        ) else [front[1], back]\n\n        # Pull JSON data for each face and set object to card_face\n        data['card_faces'] = [\n            {**requests.get(n['uri'], headers=con.http_header).json(), 'object': 'card_face'}\n            for n in faces\n        ]\n\n        # Add meld transform icon if none provided\n        if not any([bool(n in TransformIcons) for n in data.get('frame_effects', [])]):\n            data.setdefault('frame_effects', []).append(TransformIcons.MELD)\n        data['layout'] = 'transform'\n\n    # Check for alternate MDFC / Transform layouts\n    if 'card_faces' in data:\n        # Select the corresponding face\n        card = data['card_faces'][0] if (\n            normalize_str(data['card_faces'][0]['name'], True) == data['name_normalized']\n        ) else data['card_faces'][1]\n        # Transform / MDFC Planeswalker layout\n        if 'Planeswalker' in card['type_line']:\n            data['layout'] = 'planeswalker_tf' if data['layout'] == 'transform' else 'planeswalker_mdfc'\n        # Transform Saga layout\n        if 'Saga' in card['type_line']:\n            data['layout'] = 'saga'\n        # Battle layout\n        if 'Battle' in card['type_line']:\n            data['layout'] = 'battle'\n        return data\n\n    # Add Mutate layout\n    if 'Mutate' in data.get('keywords', []):\n        data['layout'] = 'mutate'\n        return data\n\n    # Add Planeswalker layout\n    if 'Planeswalker' in data.get('type_line', ''):\n        data['layout'] = 'planeswalker'\n        return data\n\n    # Return updated data\n    return data\n</code></pre>"},{"location":"utils/strings/","title":"Strings","text":"<p>Utility Helpers Module</p>"},{"location":"utils/strings/#src.utils.strings.STR_BOOL_MAP","title":"<code>STR_BOOL_MAP = {'1': True, 'y': True, 't': True, 'on': True, 'yes': True, 'true': True, '0': False, 'n': False, 'f': False, 'no': False, 'off': False, 'false': False}</code>  <code>module-attribute</code>","text":"<ul> <li>Util classes</li> </ul>"},{"location":"utils/strings/#src.utils.strings.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Enum where the value is always a string.</p> Source code in <code>src/utils/strings.py</code> <pre><code>class StrEnum(str, Enum, metaclass=StrEnumMeta):\n    \"\"\"Enum where the value is always a string.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return self.value\n\n    @cached_property\n    def value(self) -&gt; str:\n        return str(self._value_)\n\n    @cached_property\n    def Default(self) -&gt; str:\n        return \"default\"\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.StrEnumMeta","title":"<code>StrEnumMeta</code>","text":"<p>             Bases: <code>EnumMeta</code></p> <p>Metaclass for StrEnum.</p> Source code in <code>src/utils/strings.py</code> <pre><code>class StrEnumMeta(EnumMeta):\n    \"\"\"Metaclass for StrEnum.\"\"\"\n\n    def __contains__(cls, item: str):\n        return item in cls._value2member_map_\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.get_bullet_points","title":"<code>get_bullet_points(text, char='\u2022')</code>","text":"<p>Turns a list of strings into a joined string bullet point list. @param text: List of strings. @param char: Character to use as bullet. @return: Joined string with bullet points and newlines.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def get_bullet_points(text: list[str], char: str = '\u2022') -&gt; str:\n    \"\"\"\n    Turns a list of strings into a joined string bullet point list.\n    @param text: List of strings.\n    @param char: Character to use as bullet.\n    @return: Joined string with bullet points and newlines.\n    \"\"\"\n    if not text:\n        return \"\"\n    bullet = f\"\\n{char} \"\n    return str(bullet + bullet.join(text))\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.get_line","title":"<code>get_line(text, i, sep='\\n')</code>","text":"<pre><code>Get line by index from a multiline string.\n@param text: Multiline string.\n@param i: Index of the line.\n@param sep: Newline separator to use for split, defaults to '\n</code></pre> <p>'.     @return: Isolated line.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def get_line(text: str, i: int, sep: str = '\\n') -&gt; str:\n    \"\"\"\n    Get line by index from a multiline string.\n    @param text: Multiline string.\n    @param i: Index of the line.\n    @param sep: Newline separator to use for split, defaults to '\\n'.\n    @return: Isolated line.\n    \"\"\"\n    if abs(i) &gt; text.count('\\n'):\n        raise IndexError(f\"Not enough lines in multiline string. Index of {i} is invalid.\")\n    return text.split(sep)[i]\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.get_lines","title":"<code>get_lines(text, num, sep='\\n')</code>","text":"<pre><code>Separate a number of lines from a multiline string.\n@param text: Multiline string.\n@param num: Number of lines to separate and return, negative integer for trailing lines.\n@param sep: Newline separator to use for split, defaults to '\n</code></pre> <p>'.     @return: Isolated lines.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def get_lines(text: str, num: int, sep: str = '\\n') -&gt; str:\n    \"\"\"\n    Separate a number of lines from a multiline string.\n    @param text: Multiline string.\n    @param num: Number of lines to separate and return, negative integer for trailing lines.\n    @param sep: Newline separator to use for split, defaults to '\\n'.\n    @return: Isolated lines.\n    \"\"\"\n    if num == 0 or abs(num) &gt; text.count('\\n') + 1:\n        return text\n    if num &lt; 0:\n        return '\\n'.join(text.split(sep)[num:])\n    return '\\n'.join(text.split(sep)[:num])\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.is_multiline","title":"<code>is_multiline(text)</code>","text":"<p>Check if text or list of texts given contains multiline text (a newline character). @param text: String to check or list of strings to check. @return: True/False or list of True/False values.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def is_multiline(text: Union[str, list[str]]) -&gt; Union[bool, list[bool]]:\n    \"\"\"\n    Check if text or list of texts given contains multiline text (a newline character).\n    @param text: String to check or list of strings to check.\n    @return: True/False or list of True/False values.\n    \"\"\"\n    # String Given\n    if isinstance(text, str):\n        if '\\n' in text or '\\r' in text:\n            return True\n        return False\n    # List Given\n    if isinstance(text, list):\n        return [bool('\\n' in t or '\\r' in t) for t in text]\n    # Invalid data type provided\n    raise Exception(\"Invalid type passed to 'is_multiline', can only accept a string or list of strings.\\n\"\n                    f\"Received the value: {text}\")\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.msg_bold","title":"<code>msg_bold(msg)</code>","text":"<p>Wraps a console string with a bold tag. @param msg: Message to wrap. @return: Wrapped message.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def msg_bold(msg: str) -&gt; str:\n    \"\"\"\n    Wraps a console string with a bold tag.\n    @param msg: Message to wrap.\n    @return: Wrapped message.\n    \"\"\"\n    return f\"[b]{msg}[/b]\"\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.msg_error","title":"<code>msg_error(msg, reason=None)</code>","text":"<p>Adds unified error color tag to Proxyshop console message. @param msg: String to add tag to. @param reason: Reason for the error, if needed. @return: Formatted string.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def msg_error(msg: str, reason: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Adds unified error color tag to Proxyshop console message.\n    @param msg: String to add tag to.\n    @param reason: Reason for the error, if needed.\n    @return: Formatted string.\n    \"\"\"\n    msg = f'[color={ConsoleMessages.error}]{msg}[/color]'\n    return f\"{msg_bold(msg)} - {msg_italics(reason)}\" if reason else msg\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.msg_info","title":"<code>msg_info(msg)</code>","text":"<p>Adds unified info color tag to Proxyshop console message. @param msg: String to add tag to. @return: Formatted string.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def msg_info(msg: str) -&gt; str:\n    \"\"\"\n    Adds unified info color tag to Proxyshop console message.\n    @param msg: String to add tag to.\n    @return: Formatted string.\n    \"\"\"\n    return f'[color={ConsoleMessages.info}]{msg}[/color]'\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.msg_italics","title":"<code>msg_italics(msg)</code>","text":"<p>Wraps a console string with an italics tag. @param msg: Message to wrap. @return: Wrapped message.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def msg_italics(msg: str) -&gt; str:\n    \"\"\"\n    Wraps a console string with an italics tag.\n    @param msg: Message to wrap.\n    @return: Wrapped message.\n    \"\"\"\n    return f\"[i]{msg}[/i]\"\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.msg_success","title":"<code>msg_success(msg)</code>","text":"<p>Adds unified success color tag to Proxyshop console message. @param msg: String to add tag to. @return: Formatted string.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def msg_success(msg: str) -&gt; str:\n    \"\"\"\n    Adds unified success color tag to Proxyshop console message.\n    @param msg: String to add tag to.\n    @return: Formatted string.\n    \"\"\"\n    return f'[color={ConsoleMessages.success}]{msg}[/color]'\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.msg_warn","title":"<code>msg_warn(msg, reason=None)</code>","text":"<p>Adds unified warning color tag to Proxyshop console message. @param msg: String to add tag to. @param reason: Reason for the warning, if needed. @return: Formatted string.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def msg_warn(msg: str, reason: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Adds unified warning color tag to Proxyshop console message.\n    @param msg: String to add tag to.\n    @param reason: Reason for the warning, if needed.\n    @return: Formatted string.\n    \"\"\"\n    msg = f'[color={ConsoleMessages.warning}]{msg}[/color]'\n    return f\"{msg_bold(msg)} - {msg_italics(reason)}\" if reason else msg\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.normalize_str","title":"<code>normalize_str(st, no_space=False)</code>","text":"<p>Normalizes a string for safe comparison. @param st: String to normalize. @param no_space: Remove spaces. @return: Normalized string.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def normalize_str(st: str, no_space: bool = False) -&gt; str:\n    \"\"\"\n    Normalizes a string for safe comparison.\n    @param st: String to normalize.\n    @param no_space: Remove spaces.\n    @return: Normalized string.\n    \"\"\"\n    # Ignore accents and unusual characters, all lowercase\n    st = unicodedata.normalize(\"NFD\", st).encode(\"ascii\", \"ignore\").decode(\"utf8\").lower()\n\n    # Remove spaces?\n    if no_space:\n        st = st.replace(' ', '')\n\n    # Remove punctuation\n    return st.translate(str.maketrans(\"\", \"\", string.punctuation))\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.str_to_bool","title":"<code>str_to_bool(st)</code>","text":"<p>Converts a truthy string value to a bool. Conversion is case-insensitive. @param st: True values are y, yes, t, true, on and 1. False values are n, no, f, false, off and 0. @return: Adjacent boolean value. @raise: ValueError if string provided isn't a recognized truthy expression.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def str_to_bool(st: str) -&gt; bool:\n    \"\"\"\n    Converts a truthy string value to a bool. Conversion is case-insensitive.\n    @param st: True values are y, yes, t, true, on and 1.\n    False values are n, no, f, false, off and 0.\n    @return: Adjacent boolean value.\n    @raise: ValueError if string provided isn't a recognized truthy expression.\n    \"\"\"\n    try:\n        return STR_BOOL_MAP[st.lower()]\n    except KeyError:\n        raise ValueError(f\"Couldn't discern boolean value of string '{st}'!\")\n</code></pre>"},{"location":"utils/strings/#src.utils.strings.strip_lines","title":"<code>strip_lines(text, num, sep='\\n')</code>","text":"<pre><code>Removes a number of leading or trailing lines from a multiline string.\n@param text: Multiline string.\n@param num: Positive integer for number leading lines, negative integer for number of trailing lines.\n@param sep: Newline separator to use for split, defaults to '\n</code></pre> <p>'.     @return: String with lines stripped.</p> Source code in <code>src/utils/strings.py</code> <pre><code>def strip_lines(text: str, num: int, sep: str = '\\n') -&gt; str:\n    \"\"\"\n    Removes a number of leading or trailing lines from a multiline string.\n    @param text: Multiline string.\n    @param num: Positive integer for number leading lines, negative integer for number of trailing lines.\n    @param sep: Newline separator to use for split, defaults to '\\n'.\n    @return: String with lines stripped.\n    \"\"\"\n    if num == 0:\n        return text\n    if num &lt; 0:\n        return '\\n'.join(text.split(sep)[:num])\n    return '\\n'.join(text.split(sep)[num:])\n</code></pre>"},{"location":"utils/testing/","title":"Testing","text":"<p>TESTING UTILITIES</p>"},{"location":"utils/testing/#src.utils.testing.test_execution_time","title":"<code>test_execution_time(new_func, old_func, iterations=1000, args=None, args_old=None, check_result=True, reset_func=None)</code>","text":"<p>Test the execution time of a new function against an older function. @param new_func: New callable function to test. @param old_func: Older callable function to compare against. @param iterations: How many times to run these functions, higher means better sample size. @param args: Args to pass to the newer function, and older function unless specified in args_old. @param args_old: Args to pass to the older function. @param check_result: Whether to check if results match. @param reset_func: Optional function to call to reset app state between actions.</p> Source code in <code>src/utils/testing.py</code> <pre><code>def test_execution_time(\n    new_func: Callable,\n    old_func: Callable,\n    iterations=1000,\n    args=None,\n    args_old=None,\n    check_result=True,\n    reset_func: Optional[Callable] = None\n) -&gt; None:\n    \"\"\"\n    Test the execution time of a new function against an older function.\n    @param new_func: New callable function to test.\n    @param old_func: Older callable function to compare against.\n    @param iterations: How many times to run these functions, higher means better sample size.\n    @param args: Args to pass to the newer function, and older function unless specified in args_old.\n    @param args_old: Args to pass to the older function.\n    @param check_result: Whether to check if results match.\n    @param reset_func: Optional function to call to reset app state between actions.\n    \"\"\"\n    # TODO: Needs some major refactoring\n    # Test configuration\n    args = args or []\n    args_old = args_old or args\n    colorama.init(autoreset=True)\n    results: list[dict[str, Union[None, int, float, str, list]]] = [\n        {\n            'value': None,\n            'average': 0,\n            'times': [],\n            'type': 'Newer'\n        },\n        {\n            'value': None,\n            'average': 0,\n            'times': [],\n            'type': 'Older'\n        }\n    ]\n\n    # Test new functionality\n    for i in range(iterations):\n        s = perf_counter()\n        results[0]['value'] = new_func(*args)\n        results[0]['times'].append(perf_counter()-s)\n        if reset_func:\n            reset_func()\n    results[0]['average'] = sum(results[0]['times'])/len(results[0]['times'])\n\n    # Test old functionality\n    for i in range(iterations):\n        s = perf_counter()\n        results[1]['value'] = old_func(*args_old)\n        results[1]['times'].append(perf_counter()-s)\n        if reset_func:\n            reset_func()\n    results[1]['average'] = sum(results[1]['times'])/len(results[1]['times'])\n\n    # Report results\n    for i, res in enumerate(results):\n        print(f\"{res['type']} method: {res['average']}\")\n\n    # Compare results\n    final = sorted(results, key=itemgetter('average'))\n    slower = final[1]['average']\n    faster = final[0]['average']\n    delta = slower - faster\n    percent = round(delta/((slower + faster)/2) * 100, 2)\n    print(f\"{Fore.GREEN}The {final[0]['type']} method is {percent}% faster!\")\n    if check_result:\n        print(f\"Results check: {Fore.GREEN+'SUCCESS' if final[0]['value'] == final[1]['value'] else Fore.RED+'FAILED'}\")\n        if final[0]['value']:\n            print(final[0]['value'])\n            print(final[1]['value'])\n</code></pre>"},{"location":"utils/testing/#src.utils.testing.time_function","title":"<code>time_function(func)</code>","text":"<p>Print the execution time in seconds of any decorated function.</p> Source code in <code>src/utils/testing.py</code> <pre><code>def time_function(func):\n    \"\"\"Print the execution time in seconds of any decorated function.\"\"\"\n    def wrapper(*args, **kwargs):\n        start_time = time.perf_counter()\n        result = func(*args, **kwargs)\n        end_time = time.perf_counter()\n        execution_time = end_time - start_time\n        print(f\"Executed {func.__name__} in {execution_time:.4f} seconds\")\n        return result\n    return wrapper\n</code></pre>"}]}